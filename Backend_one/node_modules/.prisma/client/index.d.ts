
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type AccountPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Account"
  objects: {
    account_ban_history: account_ban_historyPayload<ExtArgs>[]
    account_bans: account_bansPayload<ExtArgs> | null
    account_storage: account_storagePayload<ExtArgs>[]
    account_viplist: account_viplistPayload<ExtArgs>[]
    players: PlayerPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    password: string
    secret: string | null
    type: number
    premium_ends_at: number
    email: string
    creation: number
    premium_points: number
    premdays: number
    wallet: string | null
    alpha_key: string | null
  }, ExtArgs["result"]["account"]>
  composites: {}
}

/**
 * Model Account
 * 
 */
export type Account = runtime.Types.DefaultSelection<AccountPayload>
export type PlayerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Player"
  objects: {
    account_ban_history: account_ban_historyPayload<ExtArgs>[]
    account_bans: account_bansPayload<ExtArgs>[]
    account_viplist: account_viplistPayload<ExtArgs>[]
    guild_invites: guild_invitesPayload<ExtArgs>[]
    guild_membership: guild_membershipPayload<ExtArgs> | null
    guilds: guildsPayload<ExtArgs> | null
    ip_bans: ip_bansPayload<ExtArgs>[]
    market_history: market_historyPayload<ExtArgs>[]
    market_offers: market_offersPayload<ExtArgs>[]
    player_depotitems: player_depotitemsPayload<ExtArgs>[]
    player_inboxitems: player_inboxitemsPayload<ExtArgs>[]
    player_namelocks_player_namelocks_player_idToplayers: player_namelocksPayload<ExtArgs> | null
    player_namelocks_player_namelocks_namelocked_byToplayers: player_namelocksPayload<ExtArgs>[]
    player_storage: player_storagePayload<ExtArgs>[]
    player_storeinboxitems: player_storeinboxitemsPayload<ExtArgs>[]
    accounts: AccountPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    group_id: number
    account_id: number
    level: number
    vocation: number
    health: number
    healthmax: number
    experience: bigint
    lookbody: number
    lookfeet: number
    lookhead: number
    looklegs: number
    looktype: number
    lookaddons: number
    direction: number
    maglevel: number
    mana: number
    manamax: number
    manaspent: bigint
    soul: number
    town_id: number
    posx: number
    posy: number
    posz: number
    conditions: Buffer
    cap: number
    sex: number
    lastlogin: bigint
    lastip: number
    save: boolean
    skull: boolean
    skulltime: bigint
    lastlogout: bigint
    blessings: number
    onlinetime: bigint
    deletion: bigint
    balance: bigint
    offlinetraining_time: number
    offlinetraining_skill: number
    stamina: number
    skill_fist: number
    skill_fist_tries: bigint
    skill_club: number
    skill_club_tries: bigint
    skill_sword: number
    skill_sword_tries: bigint
    skill_axe: number
    skill_axe_tries: bigint
    skill_dist: number
    skill_dist_tries: bigint
    skill_shielding: number
    skill_shielding_tries: bigint
    skill_fishing: number
    skill_fishing_tries: bigint
    stat_str: number
    stat_int: number
    stat_dex: number
    stat_vit: number
    stat_spr: number
    stat_wis: number
  }, ExtArgs["result"]["player"]>
  composites: {}
}

/**
 * Model Player
 * 
 */
export type Player = runtime.Types.DefaultSelection<PlayerPayload>
export type HousePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "House"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    owner: number
    paid: number
    warnings: number
    name: string
    rent: number
    town_id: number
    bid: number
    bid_end: number
    last_bid: number
    highest_bidder: number
    size: number
    beds: number
    land_zone: string
    land_plot: string
    bioma: string
    land_size: string
    plant: string
    harvest: string
    mining: string
    livestock: string
    fishing_boat: string
    json_data: Prisma.JsonValue | null
    enable: boolean
  }, ExtArgs["result"]["house"]>
  composites: {}
}

/**
 * Model House
 * 
 */
export type House = runtime.Types.DefaultSelection<HousePayload>
export type account_ban_historyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "account_ban_history"
  objects: {
    accounts: AccountPayload<ExtArgs>
    players: PlayerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    account_id: number
    reason: string
    banned_at: bigint
    expired_at: bigint
    banned_by: number
  }, ExtArgs["result"]["account_ban_history"]>
  composites: {}
}

/**
 * Model account_ban_history
 * 
 */
export type account_ban_history = runtime.Types.DefaultSelection<account_ban_historyPayload>
export type account_bansPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "account_bans"
  objects: {
    accounts: AccountPayload<ExtArgs>
    players: PlayerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    account_id: number
    reason: string
    banned_at: bigint
    expires_at: bigint
    banned_by: number
  }, ExtArgs["result"]["account_bans"]>
  composites: {}
}

/**
 * Model account_bans
 * 
 */
export type account_bans = runtime.Types.DefaultSelection<account_bansPayload>
export type account_storagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "account_storage"
  objects: {
    accounts: AccountPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    account_id: number
    key: number
    value: number
  }, ExtArgs["result"]["account_storage"]>
  composites: {}
}

/**
 * Model account_storage
 * 
 */
export type account_storage = runtime.Types.DefaultSelection<account_storagePayload>
export type account_viplistPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "account_viplist"
  objects: {
    accounts: AccountPayload<ExtArgs>
    players: PlayerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    account_id: number
    player_id: number
    description: string
    icon: number
    notify: boolean
  }, ExtArgs["result"]["account_viplist"]>
  composites: {}
}

/**
 * Model account_viplist
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type account_viplist = runtime.Types.DefaultSelection<account_viplistPayload>
export type guild_invitesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "guild_invites"
  objects: {
    players: PlayerPayload<ExtArgs>
    guilds: guildsPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    player_id: number
    guild_id: number
  }, ExtArgs["result"]["guild_invites"]>
  composites: {}
}

/**
 * Model guild_invites
 * 
 */
export type guild_invites = runtime.Types.DefaultSelection<guild_invitesPayload>
export type guild_membershipPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "guild_membership"
  objects: {
    players: PlayerPayload<ExtArgs>
    guilds: guildsPayload<ExtArgs>
    guild_ranks: guild_ranksPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    player_id: number
    guild_id: number
    rank_id: number
    nick: string
  }, ExtArgs["result"]["guild_membership"]>
  composites: {}
}

/**
 * Model guild_membership
 * 
 */
export type guild_membership = runtime.Types.DefaultSelection<guild_membershipPayload>
export type guild_ranksPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "guild_ranks"
  objects: {
    guild_membership: guild_membershipPayload<ExtArgs>[]
    guilds: guildsPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    guild_id: number
    name: string
    level: number
  }, ExtArgs["result"]["guild_ranks"]>
  composites: {}
}

/**
 * Model guild_ranks
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type guild_ranks = runtime.Types.DefaultSelection<guild_ranksPayload>
export type guild_warsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "guild_wars"
  objects: {
    guildwar_kills: guildwar_killsPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    guild1: number
    guild2: number
    name1: string
    name2: string
    status: number
    started: bigint
    ended: bigint
  }, ExtArgs["result"]["guild_wars"]>
  composites: {}
}

/**
 * Model guild_wars
 * 
 */
export type guild_wars = runtime.Types.DefaultSelection<guild_warsPayload>
export type guildsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "guilds"
  objects: {
    guild_invites: guild_invitesPayload<ExtArgs>[]
    guild_membership: guild_membershipPayload<ExtArgs>[]
    guild_ranks: guild_ranksPayload<ExtArgs>[]
    players: PlayerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    ownerid: number
    creationdata: number
    motd: string
  }, ExtArgs["result"]["guilds"]>
  composites: {}
}

/**
 * Model guilds
 * 
 */
export type guilds = runtime.Types.DefaultSelection<guildsPayload>
export type guildwar_killsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "guildwar_kills"
  objects: {
    guild_wars: guild_warsPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    killer: string
    target: string
    killerguild: number
    targetguild: number
    warid: number
    time: bigint
  }, ExtArgs["result"]["guildwar_kills"]>
  composites: {}
}

/**
 * Model guildwar_kills
 * 
 */
export type guildwar_kills = runtime.Types.DefaultSelection<guildwar_killsPayload>
export type ip_bansPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ip_bans"
  objects: {
    players: PlayerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    ip: number
    reason: string
    banned_at: bigint
    expires_at: bigint
    banned_by: number
  }, ExtArgs["result"]["ip_bans"]>
  composites: {}
}

/**
 * Model ip_bans
 * 
 */
export type ip_bans = runtime.Types.DefaultSelection<ip_bansPayload>
export type market_historyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "market_history"
  objects: {
    players: PlayerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    player_id: number
    sale: boolean
    itemtype: number
    amount: number
    price: number
    expires_at: bigint
    inserted: bigint
    state: number
  }, ExtArgs["result"]["market_history"]>
  composites: {}
}

/**
 * Model market_history
 * 
 */
export type market_history = runtime.Types.DefaultSelection<market_historyPayload>
export type market_offersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "market_offers"
  objects: {
    players: PlayerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    player_id: number
    sale: boolean
    itemtype: number
    amount: number
    created: bigint
    anonymous: boolean
    price: number
  }, ExtArgs["result"]["market_offers"]>
  composites: {}
}

/**
 * Model market_offers
 * 
 */
export type market_offers = runtime.Types.DefaultSelection<market_offersPayload>
export type petsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "pets"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    type: number
    rank: number
    stage: number
    name: string
    pet: string
    owner: string
    level: number
    experience: number
    addonItem: number
    strength: number
    wisdom: number
    agility: number
    sustain: number
    magicResistance: number
    lucky: number
    hungry: number
    hygiene: number
    happiness: number
    health: bigint
    cooldowns: string
    world_id: boolean
    wallet: string
  }, ExtArgs["result"]["pets"]>
  composites: {}
}

/**
 * Model pets
 * 
 */
export type pets = runtime.Types.DefaultSelection<petsPayload>
export type player_depotitemsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "player_depotitems"
  objects: {
    players: PlayerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    player_id: number
    sid: number
    pid: number
    itemtype: number
    count: number
    attributes: Buffer
    json_data: Prisma.JsonValue | null
  }, ExtArgs["result"]["player_depotitems"]>
  composites: {}
}

/**
 * Model player_depotitems
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type player_depotitems = runtime.Types.DefaultSelection<player_depotitemsPayload>
export type player_inboxitemsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "player_inboxitems"
  objects: {
    players: PlayerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    player_id: number
    sid: number
    pid: number
    itemtype: number
    count: number
    attributes: Buffer
    json_data: Prisma.JsonValue | null
  }, ExtArgs["result"]["player_inboxitems"]>
  composites: {}
}

/**
 * Model player_inboxitems
 * 
 */
export type player_inboxitems = runtime.Types.DefaultSelection<player_inboxitemsPayload>
export type player_namelocksPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "player_namelocks"
  objects: {
    players_player_namelocks_player_idToplayers: PlayerPayload<ExtArgs>
    players_player_namelocks_namelocked_byToplayers: PlayerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    player_id: number
    reason: string
    namelocked_at: bigint
    namelocked_by: number
  }, ExtArgs["result"]["player_namelocks"]>
  composites: {}
}

/**
 * Model player_namelocks
 * 
 */
export type player_namelocks = runtime.Types.DefaultSelection<player_namelocksPayload>
export type player_storagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "player_storage"
  objects: {
    players: PlayerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    player_id: number
    key: number
    value: number
  }, ExtArgs["result"]["player_storage"]>
  composites: {}
}

/**
 * Model player_storage
 * 
 */
export type player_storage = runtime.Types.DefaultSelection<player_storagePayload>
export type player_storeinboxitemsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "player_storeinboxitems"
  objects: {
    players: PlayerPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    player_id: number
    sid: number
    pid: number
    itemtype: number
    count: number
    attributes: Buffer
    json_data: Prisma.JsonValue | null
  }, ExtArgs["result"]["player_storeinboxitems"]>
  composites: {}
}

/**
 * Model player_storeinboxitems
 * 
 */
export type player_storeinboxitems = runtime.Types.DefaultSelection<player_storeinboxitemsPayload>
export type players_onlinePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "players_online"
  objects: {}
  scalars: $Extensions.GetResult<{
    player_id: number
  }, ExtArgs["result"]["players_online"]>
  composites: {}
}

/**
 * Model players_online
 * 
 */
export type players_online = runtime.Types.DefaultSelection<players_onlinePayload>
export type server_configPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "server_config"
  objects: {}
  scalars: $Extensions.GetResult<{
    config: string
    value: string
  }, ExtArgs["result"]["server_config"]>
  composites: {}
}

/**
 * Model server_config
 * 
 */
export type server_config = runtime.Types.DefaultSelection<server_configPayload>
export type shop_historyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "shop_history"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    account: number
    player: number
    date: Date
    title: string
    cost: number
    details: string
  }, ExtArgs["result"]["shop_history"]>
  composites: {}
}

/**
 * Model shop_history
 * 
 */
export type shop_history = runtime.Types.DefaultSelection<shop_historyPayload>
export type townsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "towns"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    posx: number
    posy: number
    posz: number
  }, ExtArgs["result"]["towns"]>
  composites: {}
}

/**
 * Model towns
 * 
 */
export type towns = runtime.Types.DefaultSelection<townsPayload>
export type znotePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    version: string
    installed: number
    cached: number | null
  }, ExtArgs["result"]["znote"]>
  composites: {}
}

/**
 * Model znote
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type znote = runtime.Types.DefaultSelection<znotePayload>
export type znote_accountsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_accounts"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    account_id: number
    ip: bigint
    created: number
    points: number | null
    cooldown: number | null
    active: number
    active_email: number
    activekey: number
    flag: string
    secret: string | null
  }, ExtArgs["result"]["znote_accounts"]>
  composites: {}
}

/**
 * Model znote_accounts
 * 
 */
export type znote_accounts = runtime.Types.DefaultSelection<znote_accountsPayload>
export type znote_auction_playerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_auction_player"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    player_id: number
    original_account_id: number
    bidder_account_id: number
    time_begin: number
    time_end: number
    price: number
    bid: number
    deposit: number
    sold: number
    claimed: number
  }, ExtArgs["result"]["znote_auction_player"]>
  composites: {}
}

/**
 * Model znote_auction_player
 * 
 */
export type znote_auction_player = runtime.Types.DefaultSelection<znote_auction_playerPayload>
export type znote_changelogPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_changelog"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    text: string
    time: number
    report_id: number
    status: number
  }, ExtArgs["result"]["znote_changelog"]>
  composites: {}
}

/**
 * Model znote_changelog
 * 
 */
export type znote_changelog = runtime.Types.DefaultSelection<znote_changelogPayload>
export type znote_deleted_charactersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_deleted_characters"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    original_account_id: number
    character_name: string
    time: Date
    done: number
  }, ExtArgs["result"]["znote_deleted_characters"]>
  composites: {}
}

/**
 * Model znote_deleted_characters
 * 
 */
export type znote_deleted_characters = runtime.Types.DefaultSelection<znote_deleted_charactersPayload>
export type znote_forumPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_forum"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    access: number
    closed: number
    hidden: number
    guild_id: number
  }, ExtArgs["result"]["znote_forum"]>
  composites: {}
}

/**
 * Model znote_forum
 * 
 */
export type znote_forum = runtime.Types.DefaultSelection<znote_forumPayload>
export type znote_forum_postsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_forum_posts"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    thread_id: number
    player_id: number
    player_name: string
    text: string
    created: number
    updated: number
  }, ExtArgs["result"]["znote_forum_posts"]>
  composites: {}
}

/**
 * Model znote_forum_posts
 * 
 */
export type znote_forum_posts = runtime.Types.DefaultSelection<znote_forum_postsPayload>
export type znote_forum_threadsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_forum_threads"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    forum_id: number
    player_id: number
    player_name: string
    title: string
    text: string
    created: number
    updated: number
    sticky: number
    hidden: number
    closed: number
  }, ExtArgs["result"]["znote_forum_threads"]>
  composites: {}
}

/**
 * Model znote_forum_threads
 * 
 */
export type znote_forum_threads = runtime.Types.DefaultSelection<znote_forum_threadsPayload>
export type znote_global_storagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_global_storage"
  objects: {}
  scalars: $Extensions.GetResult<{
    key: string
    value: string
  }, ExtArgs["result"]["znote_global_storage"]>
  composites: {}
}

/**
 * Model znote_global_storage
 * 
 */
export type znote_global_storage = runtime.Types.DefaultSelection<znote_global_storagePayload>
export type znote_guild_warsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_guild_wars"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    limit: number
  }, ExtArgs["result"]["znote_guild_wars"]>
  composites: {}
}

/**
 * Model znote_guild_wars
 * 
 */
export type znote_guild_wars = runtime.Types.DefaultSelection<znote_guild_warsPayload>
export type znote_imagesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_images"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    title: string
    desc: string
    date: number
    status: number
    image: string
    delhash: string
    account_id: number
  }, ExtArgs["result"]["znote_images"]>
  composites: {}
}

/**
 * Model znote_images
 * 
 */
export type znote_images = runtime.Types.DefaultSelection<znote_imagesPayload>
export type znote_newsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_news"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    title: string
    text: string
    date: number
    pid: number
  }, ExtArgs["result"]["znote_news"]>
  composites: {}
}

/**
 * Model znote_news
 * 
 */
export type znote_news = runtime.Types.DefaultSelection<znote_newsPayload>
export type znote_paygolPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_paygol"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    account_id: number
    price: number
    points: number
    message_id: string
    service_id: string
    shortcode: string
    keyword: string
    message: string
    sender: string
    operator: string
    country: string
    currency: string
  }, ExtArgs["result"]["znote_paygol"]>
  composites: {}
}

/**
 * Model znote_paygol
 * 
 */
export type znote_paygol = runtime.Types.DefaultSelection<znote_paygolPayload>
export type znote_paypalPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_paypal"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    txn_id: string
    email: string
    accid: number
    price: number
    points: number
  }, ExtArgs["result"]["znote_paypal"]>
  composites: {}
}

/**
 * Model znote_paypal
 * 
 */
export type znote_paypal = runtime.Types.DefaultSelection<znote_paypalPayload>
export type znote_player_reportsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_player_reports"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    name: string
    posx: number
    posy: number
    posz: number
    report_description: string
    date: number
    status: number
  }, ExtArgs["result"]["znote_player_reports"]>
  composites: {}
}

/**
 * Model znote_player_reports
 * 
 */
export type znote_player_reports = runtime.Types.DefaultSelection<znote_player_reportsPayload>
export type znote_playersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_players"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    player_id: number
    created: number
    hide_char: number
    comment: string
  }, ExtArgs["result"]["znote_players"]>
  composites: {}
}

/**
 * Model znote_players
 * 
 */
export type znote_players = runtime.Types.DefaultSelection<znote_playersPayload>
export type znote_shopPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_shop"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    type: number
    itemid: number | null
    count: number
    description: string
    points: number
  }, ExtArgs["result"]["znote_shop"]>
  composites: {}
}

/**
 * Model znote_shop
 * 
 */
export type znote_shop = runtime.Types.DefaultSelection<znote_shopPayload>
export type znote_shop_logsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_shop_logs"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    account_id: number
    player_id: number
    type: number
    itemid: number
    count: number
    points: number
    time: number
  }, ExtArgs["result"]["znote_shop_logs"]>
  composites: {}
}

/**
 * Model znote_shop_logs
 * 
 */
export type znote_shop_logs = runtime.Types.DefaultSelection<znote_shop_logsPayload>
export type znote_shop_ordersPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_shop_orders"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    account_id: number
    type: number
    itemid: number
    count: number
    time: number
  }, ExtArgs["result"]["znote_shop_orders"]>
  composites: {}
}

/**
 * Model znote_shop_orders
 * 
 */
export type znote_shop_orders = runtime.Types.DefaultSelection<znote_shop_ordersPayload>
export type znote_ticketsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_tickets"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    owner: number
    username: string
    subject: string
    message: string
    ip: bigint
    creation: number
    status: string
  }, ExtArgs["result"]["znote_tickets"]>
  composites: {}
}

/**
 * Model znote_tickets
 * 
 */
export type znote_tickets = runtime.Types.DefaultSelection<znote_ticketsPayload>
export type znote_tickets_repliesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_tickets_replies"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    tid: number
    username: string
    message: string
    created: number
  }, ExtArgs["result"]["znote_tickets_replies"]>
  composites: {}
}

/**
 * Model znote_tickets_replies
 * 
 */
export type znote_tickets_replies = runtime.Types.DefaultSelection<znote_tickets_repliesPayload>
export type znote_visitorsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_visitors"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    ip: bigint
    value: number
  }, ExtArgs["result"]["znote_visitors"]>
  composites: {}
}

/**
 * Model znote_visitors
 * 
 */
export type znote_visitors = runtime.Types.DefaultSelection<znote_visitorsPayload>
export type znote_visitors_detailsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "znote_visitors_details"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    ip: bigint
    time: number
    type: number
    account_id: number
  }, ExtArgs["result"]["znote_visitors_details"]>
  composites: {}
}

/**
 * Model znote_visitors_details
 * 
 */
export type znote_visitors_details = runtime.Types.DefaultSelection<znote_visitors_detailsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.house`: Exposes CRUD operations for the **House** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Houses
    * const houses = await prisma.house.findMany()
    * ```
    */
  get house(): Prisma.HouseDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.account_ban_history`: Exposes CRUD operations for the **account_ban_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Account_ban_histories
    * const account_ban_histories = await prisma.account_ban_history.findMany()
    * ```
    */
  get account_ban_history(): Prisma.account_ban_historyDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.account_bans`: Exposes CRUD operations for the **account_bans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Account_bans
    * const account_bans = await prisma.account_bans.findMany()
    * ```
    */
  get account_bans(): Prisma.account_bansDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.account_storage`: Exposes CRUD operations for the **account_storage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Account_storages
    * const account_storages = await prisma.account_storage.findMany()
    * ```
    */
  get account_storage(): Prisma.account_storageDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.account_viplist`: Exposes CRUD operations for the **account_viplist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Account_viplists
    * const account_viplists = await prisma.account_viplist.findMany()
    * ```
    */
  get account_viplist(): Prisma.account_viplistDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.guild_invites`: Exposes CRUD operations for the **guild_invites** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guild_invites
    * const guild_invites = await prisma.guild_invites.findMany()
    * ```
    */
  get guild_invites(): Prisma.guild_invitesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.guild_membership`: Exposes CRUD operations for the **guild_membership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guild_memberships
    * const guild_memberships = await prisma.guild_membership.findMany()
    * ```
    */
  get guild_membership(): Prisma.guild_membershipDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.guild_ranks`: Exposes CRUD operations for the **guild_ranks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guild_ranks
    * const guild_ranks = await prisma.guild_ranks.findMany()
    * ```
    */
  get guild_ranks(): Prisma.guild_ranksDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.guild_wars`: Exposes CRUD operations for the **guild_wars** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guild_wars
    * const guild_wars = await prisma.guild_wars.findMany()
    * ```
    */
  get guild_wars(): Prisma.guild_warsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.guilds`: Exposes CRUD operations for the **guilds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guilds
    * const guilds = await prisma.guilds.findMany()
    * ```
    */
  get guilds(): Prisma.guildsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.guildwar_kills`: Exposes CRUD operations for the **guildwar_kills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guildwar_kills
    * const guildwar_kills = await prisma.guildwar_kills.findMany()
    * ```
    */
  get guildwar_kills(): Prisma.guildwar_killsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.ip_bans`: Exposes CRUD operations for the **ip_bans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ip_bans
    * const ip_bans = await prisma.ip_bans.findMany()
    * ```
    */
  get ip_bans(): Prisma.ip_bansDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.market_history`: Exposes CRUD operations for the **market_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Market_histories
    * const market_histories = await prisma.market_history.findMany()
    * ```
    */
  get market_history(): Prisma.market_historyDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.market_offers`: Exposes CRUD operations for the **market_offers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Market_offers
    * const market_offers = await prisma.market_offers.findMany()
    * ```
    */
  get market_offers(): Prisma.market_offersDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.pets`: Exposes CRUD operations for the **pets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pets
    * const pets = await prisma.pets.findMany()
    * ```
    */
  get pets(): Prisma.petsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.player_depotitems`: Exposes CRUD operations for the **player_depotitems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Player_depotitems
    * const player_depotitems = await prisma.player_depotitems.findMany()
    * ```
    */
  get player_depotitems(): Prisma.player_depotitemsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.player_inboxitems`: Exposes CRUD operations for the **player_inboxitems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Player_inboxitems
    * const player_inboxitems = await prisma.player_inboxitems.findMany()
    * ```
    */
  get player_inboxitems(): Prisma.player_inboxitemsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.player_namelocks`: Exposes CRUD operations for the **player_namelocks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Player_namelocks
    * const player_namelocks = await prisma.player_namelocks.findMany()
    * ```
    */
  get player_namelocks(): Prisma.player_namelocksDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.player_storage`: Exposes CRUD operations for the **player_storage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Player_storages
    * const player_storages = await prisma.player_storage.findMany()
    * ```
    */
  get player_storage(): Prisma.player_storageDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.player_storeinboxitems`: Exposes CRUD operations for the **player_storeinboxitems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Player_storeinboxitems
    * const player_storeinboxitems = await prisma.player_storeinboxitems.findMany()
    * ```
    */
  get player_storeinboxitems(): Prisma.player_storeinboxitemsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.players_online`: Exposes CRUD operations for the **players_online** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players_onlines
    * const players_onlines = await prisma.players_online.findMany()
    * ```
    */
  get players_online(): Prisma.players_onlineDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.server_config`: Exposes CRUD operations for the **server_config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Server_configs
    * const server_configs = await prisma.server_config.findMany()
    * ```
    */
  get server_config(): Prisma.server_configDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.shop_history`: Exposes CRUD operations for the **shop_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shop_histories
    * const shop_histories = await prisma.shop_history.findMany()
    * ```
    */
  get shop_history(): Prisma.shop_historyDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.towns`: Exposes CRUD operations for the **towns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Towns
    * const towns = await prisma.towns.findMany()
    * ```
    */
  get towns(): Prisma.townsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote`: Exposes CRUD operations for the **znote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znotes
    * const znotes = await prisma.znote.findMany()
    * ```
    */
  get znote(): Prisma.znoteDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_accounts`: Exposes CRUD operations for the **znote_accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_accounts
    * const znote_accounts = await prisma.znote_accounts.findMany()
    * ```
    */
  get znote_accounts(): Prisma.znote_accountsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_auction_player`: Exposes CRUD operations for the **znote_auction_player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_auction_players
    * const znote_auction_players = await prisma.znote_auction_player.findMany()
    * ```
    */
  get znote_auction_player(): Prisma.znote_auction_playerDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_changelog`: Exposes CRUD operations for the **znote_changelog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_changelogs
    * const znote_changelogs = await prisma.znote_changelog.findMany()
    * ```
    */
  get znote_changelog(): Prisma.znote_changelogDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_deleted_characters`: Exposes CRUD operations for the **znote_deleted_characters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_deleted_characters
    * const znote_deleted_characters = await prisma.znote_deleted_characters.findMany()
    * ```
    */
  get znote_deleted_characters(): Prisma.znote_deleted_charactersDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_forum`: Exposes CRUD operations for the **znote_forum** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_forums
    * const znote_forums = await prisma.znote_forum.findMany()
    * ```
    */
  get znote_forum(): Prisma.znote_forumDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_forum_posts`: Exposes CRUD operations for the **znote_forum_posts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_forum_posts
    * const znote_forum_posts = await prisma.znote_forum_posts.findMany()
    * ```
    */
  get znote_forum_posts(): Prisma.znote_forum_postsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_forum_threads`: Exposes CRUD operations for the **znote_forum_threads** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_forum_threads
    * const znote_forum_threads = await prisma.znote_forum_threads.findMany()
    * ```
    */
  get znote_forum_threads(): Prisma.znote_forum_threadsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_global_storage`: Exposes CRUD operations for the **znote_global_storage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_global_storages
    * const znote_global_storages = await prisma.znote_global_storage.findMany()
    * ```
    */
  get znote_global_storage(): Prisma.znote_global_storageDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_guild_wars`: Exposes CRUD operations for the **znote_guild_wars** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_guild_wars
    * const znote_guild_wars = await prisma.znote_guild_wars.findMany()
    * ```
    */
  get znote_guild_wars(): Prisma.znote_guild_warsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_images`: Exposes CRUD operations for the **znote_images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_images
    * const znote_images = await prisma.znote_images.findMany()
    * ```
    */
  get znote_images(): Prisma.znote_imagesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_news`: Exposes CRUD operations for the **znote_news** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_news
    * const znote_news = await prisma.znote_news.findMany()
    * ```
    */
  get znote_news(): Prisma.znote_newsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_paygol`: Exposes CRUD operations for the **znote_paygol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_paygols
    * const znote_paygols = await prisma.znote_paygol.findMany()
    * ```
    */
  get znote_paygol(): Prisma.znote_paygolDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_paypal`: Exposes CRUD operations for the **znote_paypal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_paypals
    * const znote_paypals = await prisma.znote_paypal.findMany()
    * ```
    */
  get znote_paypal(): Prisma.znote_paypalDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_player_reports`: Exposes CRUD operations for the **znote_player_reports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_player_reports
    * const znote_player_reports = await prisma.znote_player_reports.findMany()
    * ```
    */
  get znote_player_reports(): Prisma.znote_player_reportsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_players`: Exposes CRUD operations for the **znote_players** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_players
    * const znote_players = await prisma.znote_players.findMany()
    * ```
    */
  get znote_players(): Prisma.znote_playersDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_shop`: Exposes CRUD operations for the **znote_shop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_shops
    * const znote_shops = await prisma.znote_shop.findMany()
    * ```
    */
  get znote_shop(): Prisma.znote_shopDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_shop_logs`: Exposes CRUD operations for the **znote_shop_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_shop_logs
    * const znote_shop_logs = await prisma.znote_shop_logs.findMany()
    * ```
    */
  get znote_shop_logs(): Prisma.znote_shop_logsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_shop_orders`: Exposes CRUD operations for the **znote_shop_orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_shop_orders
    * const znote_shop_orders = await prisma.znote_shop_orders.findMany()
    * ```
    */
  get znote_shop_orders(): Prisma.znote_shop_ordersDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_tickets`: Exposes CRUD operations for the **znote_tickets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_tickets
    * const znote_tickets = await prisma.znote_tickets.findMany()
    * ```
    */
  get znote_tickets(): Prisma.znote_ticketsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_tickets_replies`: Exposes CRUD operations for the **znote_tickets_replies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_tickets_replies
    * const znote_tickets_replies = await prisma.znote_tickets_replies.findMany()
    * ```
    */
  get znote_tickets_replies(): Prisma.znote_tickets_repliesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_visitors`: Exposes CRUD operations for the **znote_visitors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_visitors
    * const znote_visitors = await prisma.znote_visitors.findMany()
    * ```
    */
  get znote_visitors(): Prisma.znote_visitorsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.znote_visitors_details`: Exposes CRUD operations for the **znote_visitors_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Znote_visitors_details
    * const znote_visitors_details = await prisma.znote_visitors_details.findMany()
    * ```
    */
  get znote_visitors_details(): Prisma.znote_visitors_detailsDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Player: 'Player',
    House: 'House',
    account_ban_history: 'account_ban_history',
    account_bans: 'account_bans',
    account_storage: 'account_storage',
    account_viplist: 'account_viplist',
    guild_invites: 'guild_invites',
    guild_membership: 'guild_membership',
    guild_ranks: 'guild_ranks',
    guild_wars: 'guild_wars',
    guilds: 'guilds',
    guildwar_kills: 'guildwar_kills',
    ip_bans: 'ip_bans',
    market_history: 'market_history',
    market_offers: 'market_offers',
    pets: 'pets',
    player_depotitems: 'player_depotitems',
    player_inboxitems: 'player_inboxitems',
    player_namelocks: 'player_namelocks',
    player_storage: 'player_storage',
    player_storeinboxitems: 'player_storeinboxitems',
    players_online: 'players_online',
    server_config: 'server_config',
    shop_history: 'shop_history',
    towns: 'towns',
    znote: 'znote',
    znote_accounts: 'znote_accounts',
    znote_auction_player: 'znote_auction_player',
    znote_changelog: 'znote_changelog',
    znote_deleted_characters: 'znote_deleted_characters',
    znote_forum: 'znote_forum',
    znote_forum_posts: 'znote_forum_posts',
    znote_forum_threads: 'znote_forum_threads',
    znote_global_storage: 'znote_global_storage',
    znote_guild_wars: 'znote_guild_wars',
    znote_images: 'znote_images',
    znote_news: 'znote_news',
    znote_paygol: 'znote_paygol',
    znote_paypal: 'znote_paypal',
    znote_player_reports: 'znote_player_reports',
    znote_players: 'znote_players',
    znote_shop: 'znote_shop',
    znote_shop_logs: 'znote_shop_logs',
    znote_shop_orders: 'znote_shop_orders',
    znote_tickets: 'znote_tickets',
    znote_tickets_replies: 'znote_tickets_replies',
    znote_visitors: 'znote_visitors',
    znote_visitors_details: 'znote_visitors_details'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'account' | 'player' | 'house' | 'account_ban_history' | 'account_bans' | 'account_storage' | 'account_viplist' | 'guild_invites' | 'guild_membership' | 'guild_ranks' | 'guild_wars' | 'guilds' | 'guildwar_kills' | 'ip_bans' | 'market_history' | 'market_offers' | 'pets' | 'player_depotitems' | 'player_inboxitems' | 'player_namelocks' | 'player_storage' | 'player_storeinboxitems' | 'players_online' | 'server_config' | 'shop_history' | 'towns' | 'znote' | 'znote_accounts' | 'znote_auction_player' | 'znote_changelog' | 'znote_deleted_characters' | 'znote_forum' | 'znote_forum_posts' | 'znote_forum_threads' | 'znote_global_storage' | 'znote_guild_wars' | 'znote_images' | 'znote_news' | 'znote_paygol' | 'znote_paypal' | 'znote_player_reports' | 'znote_players' | 'znote_shop' | 'znote_shop_logs' | 'znote_shop_orders' | 'znote_tickets' | 'znote_tickets_replies' | 'znote_visitors' | 'znote_visitors_details'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Account: {
        payload: AccountPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Player: {
        payload: PlayerPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PlayerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlayerPayload>
          }
          findFirst: {
            args: Prisma.PlayerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlayerPayload>
          }
          findMany: {
            args: Prisma.PlayerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlayerPayload>[]
          }
          create: {
            args: Prisma.PlayerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlayerPayload>
          }
          createMany: {
            args: Prisma.PlayerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PlayerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlayerPayload>
          }
          update: {
            args: Prisma.PlayerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlayerPayload>
          }
          deleteMany: {
            args: Prisma.PlayerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PlayerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlayerPayload>
          }
          aggregate: {
            args: Prisma.PlayerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlayer>
          }
          groupBy: {
            args: Prisma.PlayerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCountArgs<ExtArgs>,
            result: $Utils.Optional<PlayerCountAggregateOutputType> | number
          }
        }
      }
      House: {
        payload: HousePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.HouseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HousePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HouseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HousePayload>
          }
          findFirst: {
            args: Prisma.HouseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HousePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HouseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HousePayload>
          }
          findMany: {
            args: Prisma.HouseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HousePayload>[]
          }
          create: {
            args: Prisma.HouseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HousePayload>
          }
          createMany: {
            args: Prisma.HouseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HouseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HousePayload>
          }
          update: {
            args: Prisma.HouseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HousePayload>
          }
          deleteMany: {
            args: Prisma.HouseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HouseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HouseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<HousePayload>
          }
          aggregate: {
            args: Prisma.HouseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHouse>
          }
          groupBy: {
            args: Prisma.HouseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HouseGroupByOutputType>[]
          }
          count: {
            args: Prisma.HouseCountArgs<ExtArgs>,
            result: $Utils.Optional<HouseCountAggregateOutputType> | number
          }
        }
      }
      account_ban_history: {
        payload: account_ban_historyPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.account_ban_historyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_ban_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.account_ban_historyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_ban_historyPayload>
          }
          findFirst: {
            args: Prisma.account_ban_historyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_ban_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.account_ban_historyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_ban_historyPayload>
          }
          findMany: {
            args: Prisma.account_ban_historyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_ban_historyPayload>[]
          }
          create: {
            args: Prisma.account_ban_historyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_ban_historyPayload>
          }
          createMany: {
            args: Prisma.account_ban_historyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.account_ban_historyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_ban_historyPayload>
          }
          update: {
            args: Prisma.account_ban_historyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_ban_historyPayload>
          }
          deleteMany: {
            args: Prisma.account_ban_historyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.account_ban_historyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.account_ban_historyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_ban_historyPayload>
          }
          aggregate: {
            args: Prisma.Account_ban_historyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount_ban_history>
          }
          groupBy: {
            args: Prisma.Account_ban_historyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Account_ban_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.account_ban_historyCountArgs<ExtArgs>,
            result: $Utils.Optional<Account_ban_historyCountAggregateOutputType> | number
          }
        }
      }
      account_bans: {
        payload: account_bansPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.account_bansFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_bansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.account_bansFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_bansPayload>
          }
          findFirst: {
            args: Prisma.account_bansFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_bansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.account_bansFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_bansPayload>
          }
          findMany: {
            args: Prisma.account_bansFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_bansPayload>[]
          }
          create: {
            args: Prisma.account_bansCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_bansPayload>
          }
          createMany: {
            args: Prisma.account_bansCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.account_bansDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_bansPayload>
          }
          update: {
            args: Prisma.account_bansUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_bansPayload>
          }
          deleteMany: {
            args: Prisma.account_bansDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.account_bansUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.account_bansUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_bansPayload>
          }
          aggregate: {
            args: Prisma.Account_bansAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount_bans>
          }
          groupBy: {
            args: Prisma.Account_bansGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Account_bansGroupByOutputType>[]
          }
          count: {
            args: Prisma.account_bansCountArgs<ExtArgs>,
            result: $Utils.Optional<Account_bansCountAggregateOutputType> | number
          }
        }
      }
      account_storage: {
        payload: account_storagePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.account_storageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_storagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.account_storageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_storagePayload>
          }
          findFirst: {
            args: Prisma.account_storageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_storagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.account_storageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_storagePayload>
          }
          findMany: {
            args: Prisma.account_storageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_storagePayload>[]
          }
          create: {
            args: Prisma.account_storageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_storagePayload>
          }
          createMany: {
            args: Prisma.account_storageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.account_storageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_storagePayload>
          }
          update: {
            args: Prisma.account_storageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_storagePayload>
          }
          deleteMany: {
            args: Prisma.account_storageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.account_storageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.account_storageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_storagePayload>
          }
          aggregate: {
            args: Prisma.Account_storageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount_storage>
          }
          groupBy: {
            args: Prisma.Account_storageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Account_storageGroupByOutputType>[]
          }
          count: {
            args: Prisma.account_storageCountArgs<ExtArgs>,
            result: $Utils.Optional<Account_storageCountAggregateOutputType> | number
          }
        }
      }
      account_viplist: {
        payload: account_viplistPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.account_viplistFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_viplistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.account_viplistFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_viplistPayload>
          }
          findFirst: {
            args: Prisma.account_viplistFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_viplistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.account_viplistFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_viplistPayload>
          }
          findMany: {
            args: Prisma.account_viplistFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_viplistPayload>[]
          }
          create: {
            args: Prisma.account_viplistCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_viplistPayload>
          }
          createMany: {
            args: Prisma.account_viplistCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.account_viplistDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_viplistPayload>
          }
          update: {
            args: Prisma.account_viplistUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_viplistPayload>
          }
          deleteMany: {
            args: Prisma.account_viplistDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.account_viplistUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.account_viplistUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<account_viplistPayload>
          }
          aggregate: {
            args: Prisma.Account_viplistAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount_viplist>
          }
          groupBy: {
            args: Prisma.Account_viplistGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Account_viplistGroupByOutputType>[]
          }
          count: {
            args: Prisma.account_viplistCountArgs<ExtArgs>,
            result: $Utils.Optional<Account_viplistCountAggregateOutputType> | number
          }
        }
      }
      guild_invites: {
        payload: guild_invitesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.guild_invitesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_invitesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guild_invitesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_invitesPayload>
          }
          findFirst: {
            args: Prisma.guild_invitesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_invitesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guild_invitesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_invitesPayload>
          }
          findMany: {
            args: Prisma.guild_invitesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_invitesPayload>[]
          }
          create: {
            args: Prisma.guild_invitesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_invitesPayload>
          }
          createMany: {
            args: Prisma.guild_invitesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.guild_invitesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_invitesPayload>
          }
          update: {
            args: Prisma.guild_invitesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_invitesPayload>
          }
          deleteMany: {
            args: Prisma.guild_invitesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.guild_invitesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.guild_invitesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_invitesPayload>
          }
          aggregate: {
            args: Prisma.Guild_invitesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGuild_invites>
          }
          groupBy: {
            args: Prisma.Guild_invitesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Guild_invitesGroupByOutputType>[]
          }
          count: {
            args: Prisma.guild_invitesCountArgs<ExtArgs>,
            result: $Utils.Optional<Guild_invitesCountAggregateOutputType> | number
          }
        }
      }
      guild_membership: {
        payload: guild_membershipPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.guild_membershipFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_membershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guild_membershipFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_membershipPayload>
          }
          findFirst: {
            args: Prisma.guild_membershipFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_membershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guild_membershipFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_membershipPayload>
          }
          findMany: {
            args: Prisma.guild_membershipFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_membershipPayload>[]
          }
          create: {
            args: Prisma.guild_membershipCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_membershipPayload>
          }
          createMany: {
            args: Prisma.guild_membershipCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.guild_membershipDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_membershipPayload>
          }
          update: {
            args: Prisma.guild_membershipUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_membershipPayload>
          }
          deleteMany: {
            args: Prisma.guild_membershipDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.guild_membershipUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.guild_membershipUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_membershipPayload>
          }
          aggregate: {
            args: Prisma.Guild_membershipAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGuild_membership>
          }
          groupBy: {
            args: Prisma.Guild_membershipGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Guild_membershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.guild_membershipCountArgs<ExtArgs>,
            result: $Utils.Optional<Guild_membershipCountAggregateOutputType> | number
          }
        }
      }
      guild_ranks: {
        payload: guild_ranksPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.guild_ranksFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_ranksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guild_ranksFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_ranksPayload>
          }
          findFirst: {
            args: Prisma.guild_ranksFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_ranksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guild_ranksFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_ranksPayload>
          }
          findMany: {
            args: Prisma.guild_ranksFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_ranksPayload>[]
          }
          create: {
            args: Prisma.guild_ranksCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_ranksPayload>
          }
          createMany: {
            args: Prisma.guild_ranksCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.guild_ranksDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_ranksPayload>
          }
          update: {
            args: Prisma.guild_ranksUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_ranksPayload>
          }
          deleteMany: {
            args: Prisma.guild_ranksDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.guild_ranksUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.guild_ranksUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_ranksPayload>
          }
          aggregate: {
            args: Prisma.Guild_ranksAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGuild_ranks>
          }
          groupBy: {
            args: Prisma.Guild_ranksGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Guild_ranksGroupByOutputType>[]
          }
          count: {
            args: Prisma.guild_ranksCountArgs<ExtArgs>,
            result: $Utils.Optional<Guild_ranksCountAggregateOutputType> | number
          }
        }
      }
      guild_wars: {
        payload: guild_warsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.guild_warsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_warsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guild_warsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_warsPayload>
          }
          findFirst: {
            args: Prisma.guild_warsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_warsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guild_warsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_warsPayload>
          }
          findMany: {
            args: Prisma.guild_warsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_warsPayload>[]
          }
          create: {
            args: Prisma.guild_warsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_warsPayload>
          }
          createMany: {
            args: Prisma.guild_warsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.guild_warsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_warsPayload>
          }
          update: {
            args: Prisma.guild_warsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_warsPayload>
          }
          deleteMany: {
            args: Prisma.guild_warsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.guild_warsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.guild_warsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guild_warsPayload>
          }
          aggregate: {
            args: Prisma.Guild_warsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGuild_wars>
          }
          groupBy: {
            args: Prisma.Guild_warsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Guild_warsGroupByOutputType>[]
          }
          count: {
            args: Prisma.guild_warsCountArgs<ExtArgs>,
            result: $Utils.Optional<Guild_warsCountAggregateOutputType> | number
          }
        }
      }
      guilds: {
        payload: guildsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.guildsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guildsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildsPayload>
          }
          findFirst: {
            args: Prisma.guildsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guildsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildsPayload>
          }
          findMany: {
            args: Prisma.guildsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildsPayload>[]
          }
          create: {
            args: Prisma.guildsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildsPayload>
          }
          createMany: {
            args: Prisma.guildsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.guildsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildsPayload>
          }
          update: {
            args: Prisma.guildsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildsPayload>
          }
          deleteMany: {
            args: Prisma.guildsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.guildsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.guildsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildsPayload>
          }
          aggregate: {
            args: Prisma.GuildsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGuilds>
          }
          groupBy: {
            args: Prisma.GuildsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GuildsGroupByOutputType>[]
          }
          count: {
            args: Prisma.guildsCountArgs<ExtArgs>,
            result: $Utils.Optional<GuildsCountAggregateOutputType> | number
          }
        }
      }
      guildwar_kills: {
        payload: guildwar_killsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.guildwar_killsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildwar_killsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guildwar_killsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildwar_killsPayload>
          }
          findFirst: {
            args: Prisma.guildwar_killsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildwar_killsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guildwar_killsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildwar_killsPayload>
          }
          findMany: {
            args: Prisma.guildwar_killsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildwar_killsPayload>[]
          }
          create: {
            args: Prisma.guildwar_killsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildwar_killsPayload>
          }
          createMany: {
            args: Prisma.guildwar_killsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.guildwar_killsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildwar_killsPayload>
          }
          update: {
            args: Prisma.guildwar_killsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildwar_killsPayload>
          }
          deleteMany: {
            args: Prisma.guildwar_killsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.guildwar_killsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.guildwar_killsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<guildwar_killsPayload>
          }
          aggregate: {
            args: Prisma.Guildwar_killsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGuildwar_kills>
          }
          groupBy: {
            args: Prisma.Guildwar_killsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Guildwar_killsGroupByOutputType>[]
          }
          count: {
            args: Prisma.guildwar_killsCountArgs<ExtArgs>,
            result: $Utils.Optional<Guildwar_killsCountAggregateOutputType> | number
          }
        }
      }
      ip_bans: {
        payload: ip_bansPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ip_bansFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ip_bansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ip_bansFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ip_bansPayload>
          }
          findFirst: {
            args: Prisma.ip_bansFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ip_bansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ip_bansFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ip_bansPayload>
          }
          findMany: {
            args: Prisma.ip_bansFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ip_bansPayload>[]
          }
          create: {
            args: Prisma.ip_bansCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ip_bansPayload>
          }
          createMany: {
            args: Prisma.ip_bansCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ip_bansDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ip_bansPayload>
          }
          update: {
            args: Prisma.ip_bansUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ip_bansPayload>
          }
          deleteMany: {
            args: Prisma.ip_bansDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ip_bansUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ip_bansUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ip_bansPayload>
          }
          aggregate: {
            args: Prisma.Ip_bansAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIp_bans>
          }
          groupBy: {
            args: Prisma.Ip_bansGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Ip_bansGroupByOutputType>[]
          }
          count: {
            args: Prisma.ip_bansCountArgs<ExtArgs>,
            result: $Utils.Optional<Ip_bansCountAggregateOutputType> | number
          }
        }
      }
      market_history: {
        payload: market_historyPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.market_historyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.market_historyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_historyPayload>
          }
          findFirst: {
            args: Prisma.market_historyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.market_historyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_historyPayload>
          }
          findMany: {
            args: Prisma.market_historyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_historyPayload>[]
          }
          create: {
            args: Prisma.market_historyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_historyPayload>
          }
          createMany: {
            args: Prisma.market_historyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.market_historyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_historyPayload>
          }
          update: {
            args: Prisma.market_historyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_historyPayload>
          }
          deleteMany: {
            args: Prisma.market_historyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.market_historyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.market_historyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_historyPayload>
          }
          aggregate: {
            args: Prisma.Market_historyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMarket_history>
          }
          groupBy: {
            args: Prisma.Market_historyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Market_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.market_historyCountArgs<ExtArgs>,
            result: $Utils.Optional<Market_historyCountAggregateOutputType> | number
          }
        }
      }
      market_offers: {
        payload: market_offersPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.market_offersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_offersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.market_offersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_offersPayload>
          }
          findFirst: {
            args: Prisma.market_offersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_offersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.market_offersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_offersPayload>
          }
          findMany: {
            args: Prisma.market_offersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_offersPayload>[]
          }
          create: {
            args: Prisma.market_offersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_offersPayload>
          }
          createMany: {
            args: Prisma.market_offersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.market_offersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_offersPayload>
          }
          update: {
            args: Prisma.market_offersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_offersPayload>
          }
          deleteMany: {
            args: Prisma.market_offersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.market_offersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.market_offersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<market_offersPayload>
          }
          aggregate: {
            args: Prisma.Market_offersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMarket_offers>
          }
          groupBy: {
            args: Prisma.Market_offersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Market_offersGroupByOutputType>[]
          }
          count: {
            args: Prisma.market_offersCountArgs<ExtArgs>,
            result: $Utils.Optional<Market_offersCountAggregateOutputType> | number
          }
        }
      }
      pets: {
        payload: petsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.petsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<petsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.petsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<petsPayload>
          }
          findFirst: {
            args: Prisma.petsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<petsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.petsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<petsPayload>
          }
          findMany: {
            args: Prisma.petsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<petsPayload>[]
          }
          create: {
            args: Prisma.petsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<petsPayload>
          }
          createMany: {
            args: Prisma.petsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.petsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<petsPayload>
          }
          update: {
            args: Prisma.petsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<petsPayload>
          }
          deleteMany: {
            args: Prisma.petsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.petsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.petsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<petsPayload>
          }
          aggregate: {
            args: Prisma.PetsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePets>
          }
          groupBy: {
            args: Prisma.PetsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.petsCountArgs<ExtArgs>,
            result: $Utils.Optional<PetsCountAggregateOutputType> | number
          }
        }
      }
      player_depotitems: {
        payload: player_depotitemsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.player_depotitemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_depotitemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.player_depotitemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_depotitemsPayload>
          }
          findFirst: {
            args: Prisma.player_depotitemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_depotitemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.player_depotitemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_depotitemsPayload>
          }
          findMany: {
            args: Prisma.player_depotitemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_depotitemsPayload>[]
          }
          create: {
            args: Prisma.player_depotitemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_depotitemsPayload>
          }
          createMany: {
            args: Prisma.player_depotitemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.player_depotitemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_depotitemsPayload>
          }
          update: {
            args: Prisma.player_depotitemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_depotitemsPayload>
          }
          deleteMany: {
            args: Prisma.player_depotitemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.player_depotitemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.player_depotitemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_depotitemsPayload>
          }
          aggregate: {
            args: Prisma.Player_depotitemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlayer_depotitems>
          }
          groupBy: {
            args: Prisma.Player_depotitemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Player_depotitemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.player_depotitemsCountArgs<ExtArgs>,
            result: $Utils.Optional<Player_depotitemsCountAggregateOutputType> | number
          }
        }
      }
      player_inboxitems: {
        payload: player_inboxitemsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.player_inboxitemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_inboxitemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.player_inboxitemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_inboxitemsPayload>
          }
          findFirst: {
            args: Prisma.player_inboxitemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_inboxitemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.player_inboxitemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_inboxitemsPayload>
          }
          findMany: {
            args: Prisma.player_inboxitemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_inboxitemsPayload>[]
          }
          create: {
            args: Prisma.player_inboxitemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_inboxitemsPayload>
          }
          createMany: {
            args: Prisma.player_inboxitemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.player_inboxitemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_inboxitemsPayload>
          }
          update: {
            args: Prisma.player_inboxitemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_inboxitemsPayload>
          }
          deleteMany: {
            args: Prisma.player_inboxitemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.player_inboxitemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.player_inboxitemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_inboxitemsPayload>
          }
          aggregate: {
            args: Prisma.Player_inboxitemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlayer_inboxitems>
          }
          groupBy: {
            args: Prisma.Player_inboxitemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Player_inboxitemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.player_inboxitemsCountArgs<ExtArgs>,
            result: $Utils.Optional<Player_inboxitemsCountAggregateOutputType> | number
          }
        }
      }
      player_namelocks: {
        payload: player_namelocksPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.player_namelocksFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_namelocksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.player_namelocksFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_namelocksPayload>
          }
          findFirst: {
            args: Prisma.player_namelocksFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_namelocksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.player_namelocksFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_namelocksPayload>
          }
          findMany: {
            args: Prisma.player_namelocksFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_namelocksPayload>[]
          }
          create: {
            args: Prisma.player_namelocksCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_namelocksPayload>
          }
          createMany: {
            args: Prisma.player_namelocksCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.player_namelocksDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_namelocksPayload>
          }
          update: {
            args: Prisma.player_namelocksUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_namelocksPayload>
          }
          deleteMany: {
            args: Prisma.player_namelocksDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.player_namelocksUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.player_namelocksUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_namelocksPayload>
          }
          aggregate: {
            args: Prisma.Player_namelocksAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlayer_namelocks>
          }
          groupBy: {
            args: Prisma.Player_namelocksGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Player_namelocksGroupByOutputType>[]
          }
          count: {
            args: Prisma.player_namelocksCountArgs<ExtArgs>,
            result: $Utils.Optional<Player_namelocksCountAggregateOutputType> | number
          }
        }
      }
      player_storage: {
        payload: player_storagePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.player_storageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.player_storageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storagePayload>
          }
          findFirst: {
            args: Prisma.player_storageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.player_storageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storagePayload>
          }
          findMany: {
            args: Prisma.player_storageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storagePayload>[]
          }
          create: {
            args: Prisma.player_storageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storagePayload>
          }
          createMany: {
            args: Prisma.player_storageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.player_storageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storagePayload>
          }
          update: {
            args: Prisma.player_storageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storagePayload>
          }
          deleteMany: {
            args: Prisma.player_storageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.player_storageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.player_storageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storagePayload>
          }
          aggregate: {
            args: Prisma.Player_storageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlayer_storage>
          }
          groupBy: {
            args: Prisma.Player_storageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Player_storageGroupByOutputType>[]
          }
          count: {
            args: Prisma.player_storageCountArgs<ExtArgs>,
            result: $Utils.Optional<Player_storageCountAggregateOutputType> | number
          }
        }
      }
      player_storeinboxitems: {
        payload: player_storeinboxitemsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.player_storeinboxitemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storeinboxitemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.player_storeinboxitemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storeinboxitemsPayload>
          }
          findFirst: {
            args: Prisma.player_storeinboxitemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storeinboxitemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.player_storeinboxitemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storeinboxitemsPayload>
          }
          findMany: {
            args: Prisma.player_storeinboxitemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storeinboxitemsPayload>[]
          }
          create: {
            args: Prisma.player_storeinboxitemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storeinboxitemsPayload>
          }
          createMany: {
            args: Prisma.player_storeinboxitemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.player_storeinboxitemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storeinboxitemsPayload>
          }
          update: {
            args: Prisma.player_storeinboxitemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storeinboxitemsPayload>
          }
          deleteMany: {
            args: Prisma.player_storeinboxitemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.player_storeinboxitemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.player_storeinboxitemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<player_storeinboxitemsPayload>
          }
          aggregate: {
            args: Prisma.Player_storeinboxitemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlayer_storeinboxitems>
          }
          groupBy: {
            args: Prisma.Player_storeinboxitemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Player_storeinboxitemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.player_storeinboxitemsCountArgs<ExtArgs>,
            result: $Utils.Optional<Player_storeinboxitemsCountAggregateOutputType> | number
          }
        }
      }
      players_online: {
        payload: players_onlinePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.players_onlineFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<players_onlinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.players_onlineFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<players_onlinePayload>
          }
          findFirst: {
            args: Prisma.players_onlineFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<players_onlinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.players_onlineFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<players_onlinePayload>
          }
          findMany: {
            args: Prisma.players_onlineFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<players_onlinePayload>[]
          }
          create: {
            args: Prisma.players_onlineCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<players_onlinePayload>
          }
          createMany: {
            args: Prisma.players_onlineCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.players_onlineDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<players_onlinePayload>
          }
          update: {
            args: Prisma.players_onlineUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<players_onlinePayload>
          }
          deleteMany: {
            args: Prisma.players_onlineDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.players_onlineUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.players_onlineUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<players_onlinePayload>
          }
          aggregate: {
            args: Prisma.Players_onlineAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlayers_online>
          }
          groupBy: {
            args: Prisma.Players_onlineGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Players_onlineGroupByOutputType>[]
          }
          count: {
            args: Prisma.players_onlineCountArgs<ExtArgs>,
            result: $Utils.Optional<Players_onlineCountAggregateOutputType> | number
          }
        }
      }
      server_config: {
        payload: server_configPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.server_configFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<server_configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.server_configFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<server_configPayload>
          }
          findFirst: {
            args: Prisma.server_configFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<server_configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.server_configFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<server_configPayload>
          }
          findMany: {
            args: Prisma.server_configFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<server_configPayload>[]
          }
          create: {
            args: Prisma.server_configCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<server_configPayload>
          }
          createMany: {
            args: Prisma.server_configCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.server_configDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<server_configPayload>
          }
          update: {
            args: Prisma.server_configUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<server_configPayload>
          }
          deleteMany: {
            args: Prisma.server_configDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.server_configUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.server_configUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<server_configPayload>
          }
          aggregate: {
            args: Prisma.Server_configAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateServer_config>
          }
          groupBy: {
            args: Prisma.Server_configGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Server_configGroupByOutputType>[]
          }
          count: {
            args: Prisma.server_configCountArgs<ExtArgs>,
            result: $Utils.Optional<Server_configCountAggregateOutputType> | number
          }
        }
      }
      shop_history: {
        payload: shop_historyPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.shop_historyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<shop_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.shop_historyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<shop_historyPayload>
          }
          findFirst: {
            args: Prisma.shop_historyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<shop_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.shop_historyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<shop_historyPayload>
          }
          findMany: {
            args: Prisma.shop_historyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<shop_historyPayload>[]
          }
          create: {
            args: Prisma.shop_historyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<shop_historyPayload>
          }
          createMany: {
            args: Prisma.shop_historyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.shop_historyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<shop_historyPayload>
          }
          update: {
            args: Prisma.shop_historyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<shop_historyPayload>
          }
          deleteMany: {
            args: Prisma.shop_historyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.shop_historyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.shop_historyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<shop_historyPayload>
          }
          aggregate: {
            args: Prisma.Shop_historyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateShop_history>
          }
          groupBy: {
            args: Prisma.Shop_historyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Shop_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.shop_historyCountArgs<ExtArgs>,
            result: $Utils.Optional<Shop_historyCountAggregateOutputType> | number
          }
        }
      }
      towns: {
        payload: townsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.townsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<townsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.townsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<townsPayload>
          }
          findFirst: {
            args: Prisma.townsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<townsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.townsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<townsPayload>
          }
          findMany: {
            args: Prisma.townsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<townsPayload>[]
          }
          create: {
            args: Prisma.townsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<townsPayload>
          }
          createMany: {
            args: Prisma.townsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.townsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<townsPayload>
          }
          update: {
            args: Prisma.townsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<townsPayload>
          }
          deleteMany: {
            args: Prisma.townsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.townsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.townsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<townsPayload>
          }
          aggregate: {
            args: Prisma.TownsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTowns>
          }
          groupBy: {
            args: Prisma.TownsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TownsGroupByOutputType>[]
          }
          count: {
            args: Prisma.townsCountArgs<ExtArgs>,
            result: $Utils.Optional<TownsCountAggregateOutputType> | number
          }
        }
      }
      znote: {
        payload: znotePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znoteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znoteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znotePayload>
          }
          findFirst: {
            args: Prisma.znoteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znoteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znotePayload>
          }
          findMany: {
            args: Prisma.znoteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znotePayload>[]
          }
          create: {
            args: Prisma.znoteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znotePayload>
          }
          createMany: {
            args: Prisma.znoteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znoteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znotePayload>
          }
          update: {
            args: Prisma.znoteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znotePayload>
          }
          deleteMany: {
            args: Prisma.znoteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znoteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znoteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znotePayload>
          }
          aggregate: {
            args: Prisma.ZnoteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote>
          }
          groupBy: {
            args: Prisma.ZnoteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ZnoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.znoteCountArgs<ExtArgs>,
            result: $Utils.Optional<ZnoteCountAggregateOutputType> | number
          }
        }
      }
      znote_accounts: {
        payload: znote_accountsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_accountsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_accountsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_accountsPayload>
          }
          findFirst: {
            args: Prisma.znote_accountsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_accountsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_accountsPayload>
          }
          findMany: {
            args: Prisma.znote_accountsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_accountsPayload>[]
          }
          create: {
            args: Prisma.znote_accountsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_accountsPayload>
          }
          createMany: {
            args: Prisma.znote_accountsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_accountsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_accountsPayload>
          }
          update: {
            args: Prisma.znote_accountsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_accountsPayload>
          }
          deleteMany: {
            args: Prisma.znote_accountsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_accountsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_accountsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_accountsPayload>
          }
          aggregate: {
            args: Prisma.Znote_accountsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_accounts>
          }
          groupBy: {
            args: Prisma.Znote_accountsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_accountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_accountsCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_accountsCountAggregateOutputType> | number
          }
        }
      }
      znote_auction_player: {
        payload: znote_auction_playerPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_auction_playerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_auction_playerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_auction_playerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_auction_playerPayload>
          }
          findFirst: {
            args: Prisma.znote_auction_playerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_auction_playerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_auction_playerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_auction_playerPayload>
          }
          findMany: {
            args: Prisma.znote_auction_playerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_auction_playerPayload>[]
          }
          create: {
            args: Prisma.znote_auction_playerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_auction_playerPayload>
          }
          createMany: {
            args: Prisma.znote_auction_playerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_auction_playerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_auction_playerPayload>
          }
          update: {
            args: Prisma.znote_auction_playerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_auction_playerPayload>
          }
          deleteMany: {
            args: Prisma.znote_auction_playerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_auction_playerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_auction_playerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_auction_playerPayload>
          }
          aggregate: {
            args: Prisma.Znote_auction_playerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_auction_player>
          }
          groupBy: {
            args: Prisma.Znote_auction_playerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_auction_playerGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_auction_playerCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_auction_playerCountAggregateOutputType> | number
          }
        }
      }
      znote_changelog: {
        payload: znote_changelogPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_changelogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_changelogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_changelogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_changelogPayload>
          }
          findFirst: {
            args: Prisma.znote_changelogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_changelogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_changelogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_changelogPayload>
          }
          findMany: {
            args: Prisma.znote_changelogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_changelogPayload>[]
          }
          create: {
            args: Prisma.znote_changelogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_changelogPayload>
          }
          createMany: {
            args: Prisma.znote_changelogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_changelogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_changelogPayload>
          }
          update: {
            args: Prisma.znote_changelogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_changelogPayload>
          }
          deleteMany: {
            args: Prisma.znote_changelogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_changelogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_changelogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_changelogPayload>
          }
          aggregate: {
            args: Prisma.Znote_changelogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_changelog>
          }
          groupBy: {
            args: Prisma.Znote_changelogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_changelogGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_changelogCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_changelogCountAggregateOutputType> | number
          }
        }
      }
      znote_deleted_characters: {
        payload: znote_deleted_charactersPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_deleted_charactersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_deleted_charactersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_deleted_charactersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_deleted_charactersPayload>
          }
          findFirst: {
            args: Prisma.znote_deleted_charactersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_deleted_charactersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_deleted_charactersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_deleted_charactersPayload>
          }
          findMany: {
            args: Prisma.znote_deleted_charactersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_deleted_charactersPayload>[]
          }
          create: {
            args: Prisma.znote_deleted_charactersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_deleted_charactersPayload>
          }
          createMany: {
            args: Prisma.znote_deleted_charactersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_deleted_charactersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_deleted_charactersPayload>
          }
          update: {
            args: Prisma.znote_deleted_charactersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_deleted_charactersPayload>
          }
          deleteMany: {
            args: Prisma.znote_deleted_charactersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_deleted_charactersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_deleted_charactersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_deleted_charactersPayload>
          }
          aggregate: {
            args: Prisma.Znote_deleted_charactersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_deleted_characters>
          }
          groupBy: {
            args: Prisma.Znote_deleted_charactersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_deleted_charactersGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_deleted_charactersCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_deleted_charactersCountAggregateOutputType> | number
          }
        }
      }
      znote_forum: {
        payload: znote_forumPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_forumFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_forumFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forumPayload>
          }
          findFirst: {
            args: Prisma.znote_forumFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_forumFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forumPayload>
          }
          findMany: {
            args: Prisma.znote_forumFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forumPayload>[]
          }
          create: {
            args: Prisma.znote_forumCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forumPayload>
          }
          createMany: {
            args: Prisma.znote_forumCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_forumDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forumPayload>
          }
          update: {
            args: Prisma.znote_forumUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forumPayload>
          }
          deleteMany: {
            args: Prisma.znote_forumDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_forumUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_forumUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forumPayload>
          }
          aggregate: {
            args: Prisma.Znote_forumAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_forum>
          }
          groupBy: {
            args: Prisma.Znote_forumGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_forumGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_forumCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_forumCountAggregateOutputType> | number
          }
        }
      }
      znote_forum_posts: {
        payload: znote_forum_postsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_forum_postsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_postsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_forum_postsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_postsPayload>
          }
          findFirst: {
            args: Prisma.znote_forum_postsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_postsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_forum_postsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_postsPayload>
          }
          findMany: {
            args: Prisma.znote_forum_postsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_postsPayload>[]
          }
          create: {
            args: Prisma.znote_forum_postsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_postsPayload>
          }
          createMany: {
            args: Prisma.znote_forum_postsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_forum_postsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_postsPayload>
          }
          update: {
            args: Prisma.znote_forum_postsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_postsPayload>
          }
          deleteMany: {
            args: Prisma.znote_forum_postsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_forum_postsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_forum_postsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_postsPayload>
          }
          aggregate: {
            args: Prisma.Znote_forum_postsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_forum_posts>
          }
          groupBy: {
            args: Prisma.Znote_forum_postsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_forum_postsGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_forum_postsCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_forum_postsCountAggregateOutputType> | number
          }
        }
      }
      znote_forum_threads: {
        payload: znote_forum_threadsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_forum_threadsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_threadsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_forum_threadsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_threadsPayload>
          }
          findFirst: {
            args: Prisma.znote_forum_threadsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_threadsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_forum_threadsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_threadsPayload>
          }
          findMany: {
            args: Prisma.znote_forum_threadsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_threadsPayload>[]
          }
          create: {
            args: Prisma.znote_forum_threadsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_threadsPayload>
          }
          createMany: {
            args: Prisma.znote_forum_threadsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_forum_threadsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_threadsPayload>
          }
          update: {
            args: Prisma.znote_forum_threadsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_threadsPayload>
          }
          deleteMany: {
            args: Prisma.znote_forum_threadsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_forum_threadsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_forum_threadsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_forum_threadsPayload>
          }
          aggregate: {
            args: Prisma.Znote_forum_threadsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_forum_threads>
          }
          groupBy: {
            args: Prisma.Znote_forum_threadsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_forum_threadsGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_forum_threadsCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_forum_threadsCountAggregateOutputType> | number
          }
        }
      }
      znote_global_storage: {
        payload: znote_global_storagePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_global_storageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_global_storagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_global_storageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_global_storagePayload>
          }
          findFirst: {
            args: Prisma.znote_global_storageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_global_storagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_global_storageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_global_storagePayload>
          }
          findMany: {
            args: Prisma.znote_global_storageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_global_storagePayload>[]
          }
          create: {
            args: Prisma.znote_global_storageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_global_storagePayload>
          }
          createMany: {
            args: Prisma.znote_global_storageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_global_storageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_global_storagePayload>
          }
          update: {
            args: Prisma.znote_global_storageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_global_storagePayload>
          }
          deleteMany: {
            args: Prisma.znote_global_storageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_global_storageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_global_storageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_global_storagePayload>
          }
          aggregate: {
            args: Prisma.Znote_global_storageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_global_storage>
          }
          groupBy: {
            args: Prisma.Znote_global_storageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_global_storageGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_global_storageCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_global_storageCountAggregateOutputType> | number
          }
        }
      }
      znote_guild_wars: {
        payload: znote_guild_warsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_guild_warsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_guild_warsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_guild_warsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_guild_warsPayload>
          }
          findFirst: {
            args: Prisma.znote_guild_warsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_guild_warsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_guild_warsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_guild_warsPayload>
          }
          findMany: {
            args: Prisma.znote_guild_warsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_guild_warsPayload>[]
          }
          create: {
            args: Prisma.znote_guild_warsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_guild_warsPayload>
          }
          createMany: {
            args: Prisma.znote_guild_warsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_guild_warsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_guild_warsPayload>
          }
          update: {
            args: Prisma.znote_guild_warsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_guild_warsPayload>
          }
          deleteMany: {
            args: Prisma.znote_guild_warsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_guild_warsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_guild_warsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_guild_warsPayload>
          }
          aggregate: {
            args: Prisma.Znote_guild_warsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_guild_wars>
          }
          groupBy: {
            args: Prisma.Znote_guild_warsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_guild_warsGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_guild_warsCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_guild_warsCountAggregateOutputType> | number
          }
        }
      }
      znote_images: {
        payload: znote_imagesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_imagesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_imagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_imagesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_imagesPayload>
          }
          findFirst: {
            args: Prisma.znote_imagesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_imagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_imagesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_imagesPayload>
          }
          findMany: {
            args: Prisma.znote_imagesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_imagesPayload>[]
          }
          create: {
            args: Prisma.znote_imagesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_imagesPayload>
          }
          createMany: {
            args: Prisma.znote_imagesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_imagesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_imagesPayload>
          }
          update: {
            args: Prisma.znote_imagesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_imagesPayload>
          }
          deleteMany: {
            args: Prisma.znote_imagesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_imagesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_imagesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_imagesPayload>
          }
          aggregate: {
            args: Prisma.Znote_imagesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_images>
          }
          groupBy: {
            args: Prisma.Znote_imagesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_imagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_imagesCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_imagesCountAggregateOutputType> | number
          }
        }
      }
      znote_news: {
        payload: znote_newsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_newsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_newsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_newsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_newsPayload>
          }
          findFirst: {
            args: Prisma.znote_newsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_newsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_newsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_newsPayload>
          }
          findMany: {
            args: Prisma.znote_newsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_newsPayload>[]
          }
          create: {
            args: Prisma.znote_newsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_newsPayload>
          }
          createMany: {
            args: Prisma.znote_newsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_newsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_newsPayload>
          }
          update: {
            args: Prisma.znote_newsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_newsPayload>
          }
          deleteMany: {
            args: Prisma.znote_newsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_newsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_newsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_newsPayload>
          }
          aggregate: {
            args: Prisma.Znote_newsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_news>
          }
          groupBy: {
            args: Prisma.Znote_newsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_newsGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_newsCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_newsCountAggregateOutputType> | number
          }
        }
      }
      znote_paygol: {
        payload: znote_paygolPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_paygolFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paygolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_paygolFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paygolPayload>
          }
          findFirst: {
            args: Prisma.znote_paygolFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paygolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_paygolFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paygolPayload>
          }
          findMany: {
            args: Prisma.znote_paygolFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paygolPayload>[]
          }
          create: {
            args: Prisma.znote_paygolCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paygolPayload>
          }
          createMany: {
            args: Prisma.znote_paygolCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_paygolDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paygolPayload>
          }
          update: {
            args: Prisma.znote_paygolUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paygolPayload>
          }
          deleteMany: {
            args: Prisma.znote_paygolDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_paygolUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_paygolUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paygolPayload>
          }
          aggregate: {
            args: Prisma.Znote_paygolAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_paygol>
          }
          groupBy: {
            args: Prisma.Znote_paygolGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_paygolGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_paygolCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_paygolCountAggregateOutputType> | number
          }
        }
      }
      znote_paypal: {
        payload: znote_paypalPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_paypalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paypalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_paypalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paypalPayload>
          }
          findFirst: {
            args: Prisma.znote_paypalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paypalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_paypalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paypalPayload>
          }
          findMany: {
            args: Prisma.znote_paypalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paypalPayload>[]
          }
          create: {
            args: Prisma.znote_paypalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paypalPayload>
          }
          createMany: {
            args: Prisma.znote_paypalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_paypalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paypalPayload>
          }
          update: {
            args: Prisma.znote_paypalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paypalPayload>
          }
          deleteMany: {
            args: Prisma.znote_paypalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_paypalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_paypalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_paypalPayload>
          }
          aggregate: {
            args: Prisma.Znote_paypalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_paypal>
          }
          groupBy: {
            args: Prisma.Znote_paypalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_paypalGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_paypalCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_paypalCountAggregateOutputType> | number
          }
        }
      }
      znote_player_reports: {
        payload: znote_player_reportsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_player_reportsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_player_reportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_player_reportsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_player_reportsPayload>
          }
          findFirst: {
            args: Prisma.znote_player_reportsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_player_reportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_player_reportsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_player_reportsPayload>
          }
          findMany: {
            args: Prisma.znote_player_reportsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_player_reportsPayload>[]
          }
          create: {
            args: Prisma.znote_player_reportsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_player_reportsPayload>
          }
          createMany: {
            args: Prisma.znote_player_reportsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_player_reportsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_player_reportsPayload>
          }
          update: {
            args: Prisma.znote_player_reportsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_player_reportsPayload>
          }
          deleteMany: {
            args: Prisma.znote_player_reportsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_player_reportsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_player_reportsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_player_reportsPayload>
          }
          aggregate: {
            args: Prisma.Znote_player_reportsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_player_reports>
          }
          groupBy: {
            args: Prisma.Znote_player_reportsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_player_reportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_player_reportsCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_player_reportsCountAggregateOutputType> | number
          }
        }
      }
      znote_players: {
        payload: znote_playersPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_playersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_playersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_playersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_playersPayload>
          }
          findFirst: {
            args: Prisma.znote_playersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_playersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_playersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_playersPayload>
          }
          findMany: {
            args: Prisma.znote_playersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_playersPayload>[]
          }
          create: {
            args: Prisma.znote_playersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_playersPayload>
          }
          createMany: {
            args: Prisma.znote_playersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_playersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_playersPayload>
          }
          update: {
            args: Prisma.znote_playersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_playersPayload>
          }
          deleteMany: {
            args: Prisma.znote_playersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_playersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_playersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_playersPayload>
          }
          aggregate: {
            args: Prisma.Znote_playersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_players>
          }
          groupBy: {
            args: Prisma.Znote_playersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_playersGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_playersCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_playersCountAggregateOutputType> | number
          }
        }
      }
      znote_shop: {
        payload: znote_shopPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_shopFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_shopFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shopPayload>
          }
          findFirst: {
            args: Prisma.znote_shopFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_shopFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shopPayload>
          }
          findMany: {
            args: Prisma.znote_shopFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shopPayload>[]
          }
          create: {
            args: Prisma.znote_shopCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shopPayload>
          }
          createMany: {
            args: Prisma.znote_shopCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_shopDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shopPayload>
          }
          update: {
            args: Prisma.znote_shopUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shopPayload>
          }
          deleteMany: {
            args: Prisma.znote_shopDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_shopUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_shopUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shopPayload>
          }
          aggregate: {
            args: Prisma.Znote_shopAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_shop>
          }
          groupBy: {
            args: Prisma.Znote_shopGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_shopGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_shopCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_shopCountAggregateOutputType> | number
          }
        }
      }
      znote_shop_logs: {
        payload: znote_shop_logsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_shop_logsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_shop_logsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_logsPayload>
          }
          findFirst: {
            args: Prisma.znote_shop_logsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_shop_logsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_logsPayload>
          }
          findMany: {
            args: Prisma.znote_shop_logsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_logsPayload>[]
          }
          create: {
            args: Prisma.znote_shop_logsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_logsPayload>
          }
          createMany: {
            args: Prisma.znote_shop_logsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_shop_logsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_logsPayload>
          }
          update: {
            args: Prisma.znote_shop_logsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_logsPayload>
          }
          deleteMany: {
            args: Prisma.znote_shop_logsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_shop_logsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_shop_logsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_logsPayload>
          }
          aggregate: {
            args: Prisma.Znote_shop_logsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_shop_logs>
          }
          groupBy: {
            args: Prisma.Znote_shop_logsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_shop_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_shop_logsCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_shop_logsCountAggregateOutputType> | number
          }
        }
      }
      znote_shop_orders: {
        payload: znote_shop_ordersPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_shop_ordersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_ordersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_shop_ordersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_ordersPayload>
          }
          findFirst: {
            args: Prisma.znote_shop_ordersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_ordersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_shop_ordersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_ordersPayload>
          }
          findMany: {
            args: Prisma.znote_shop_ordersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_ordersPayload>[]
          }
          create: {
            args: Prisma.znote_shop_ordersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_ordersPayload>
          }
          createMany: {
            args: Prisma.znote_shop_ordersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_shop_ordersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_ordersPayload>
          }
          update: {
            args: Prisma.znote_shop_ordersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_ordersPayload>
          }
          deleteMany: {
            args: Prisma.znote_shop_ordersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_shop_ordersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_shop_ordersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_shop_ordersPayload>
          }
          aggregate: {
            args: Prisma.Znote_shop_ordersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_shop_orders>
          }
          groupBy: {
            args: Prisma.Znote_shop_ordersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_shop_ordersGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_shop_ordersCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_shop_ordersCountAggregateOutputType> | number
          }
        }
      }
      znote_tickets: {
        payload: znote_ticketsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_ticketsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_ticketsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_ticketsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_ticketsPayload>
          }
          findFirst: {
            args: Prisma.znote_ticketsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_ticketsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_ticketsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_ticketsPayload>
          }
          findMany: {
            args: Prisma.znote_ticketsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_ticketsPayload>[]
          }
          create: {
            args: Prisma.znote_ticketsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_ticketsPayload>
          }
          createMany: {
            args: Prisma.znote_ticketsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_ticketsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_ticketsPayload>
          }
          update: {
            args: Prisma.znote_ticketsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_ticketsPayload>
          }
          deleteMany: {
            args: Prisma.znote_ticketsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_ticketsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_ticketsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_ticketsPayload>
          }
          aggregate: {
            args: Prisma.Znote_ticketsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_tickets>
          }
          groupBy: {
            args: Prisma.Znote_ticketsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_ticketsGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_ticketsCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_ticketsCountAggregateOutputType> | number
          }
        }
      }
      znote_tickets_replies: {
        payload: znote_tickets_repliesPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_tickets_repliesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_tickets_repliesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_tickets_repliesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_tickets_repliesPayload>
          }
          findFirst: {
            args: Prisma.znote_tickets_repliesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_tickets_repliesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_tickets_repliesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_tickets_repliesPayload>
          }
          findMany: {
            args: Prisma.znote_tickets_repliesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_tickets_repliesPayload>[]
          }
          create: {
            args: Prisma.znote_tickets_repliesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_tickets_repliesPayload>
          }
          createMany: {
            args: Prisma.znote_tickets_repliesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_tickets_repliesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_tickets_repliesPayload>
          }
          update: {
            args: Prisma.znote_tickets_repliesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_tickets_repliesPayload>
          }
          deleteMany: {
            args: Prisma.znote_tickets_repliesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_tickets_repliesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_tickets_repliesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_tickets_repliesPayload>
          }
          aggregate: {
            args: Prisma.Znote_tickets_repliesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_tickets_replies>
          }
          groupBy: {
            args: Prisma.Znote_tickets_repliesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_tickets_repliesGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_tickets_repliesCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_tickets_repliesCountAggregateOutputType> | number
          }
        }
      }
      znote_visitors: {
        payload: znote_visitorsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_visitorsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_visitorsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitorsPayload>
          }
          findFirst: {
            args: Prisma.znote_visitorsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_visitorsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitorsPayload>
          }
          findMany: {
            args: Prisma.znote_visitorsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitorsPayload>[]
          }
          create: {
            args: Prisma.znote_visitorsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitorsPayload>
          }
          createMany: {
            args: Prisma.znote_visitorsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_visitorsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitorsPayload>
          }
          update: {
            args: Prisma.znote_visitorsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitorsPayload>
          }
          deleteMany: {
            args: Prisma.znote_visitorsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_visitorsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_visitorsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitorsPayload>
          }
          aggregate: {
            args: Prisma.Znote_visitorsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_visitors>
          }
          groupBy: {
            args: Prisma.Znote_visitorsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_visitorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_visitorsCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_visitorsCountAggregateOutputType> | number
          }
        }
      }
      znote_visitors_details: {
        payload: znote_visitors_detailsPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.znote_visitors_detailsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitors_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.znote_visitors_detailsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitors_detailsPayload>
          }
          findFirst: {
            args: Prisma.znote_visitors_detailsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitors_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.znote_visitors_detailsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitors_detailsPayload>
          }
          findMany: {
            args: Prisma.znote_visitors_detailsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitors_detailsPayload>[]
          }
          create: {
            args: Prisma.znote_visitors_detailsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitors_detailsPayload>
          }
          createMany: {
            args: Prisma.znote_visitors_detailsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.znote_visitors_detailsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitors_detailsPayload>
          }
          update: {
            args: Prisma.znote_visitors_detailsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitors_detailsPayload>
          }
          deleteMany: {
            args: Prisma.znote_visitors_detailsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.znote_visitors_detailsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.znote_visitors_detailsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<znote_visitors_detailsPayload>
          }
          aggregate: {
            args: Prisma.Znote_visitors_detailsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZnote_visitors_details>
          }
          groupBy: {
            args: Prisma.Znote_visitors_detailsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Znote_visitors_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.znote_visitors_detailsCountArgs<ExtArgs>,
            result: $Utils.Optional<Znote_visitors_detailsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountCountOutputType
   */


  export type AccountCountOutputType = {
    account_ban_history: number
    account_storage: number
    account_viplist: number
    players: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    account_ban_history?: boolean | AccountCountOutputTypeCountAccount_ban_historyArgs
    account_storage?: boolean | AccountCountOutputTypeCountAccount_storageArgs
    account_viplist?: boolean | AccountCountOutputTypeCountAccount_viplistArgs
    players?: boolean | AccountCountOutputTypeCountPlayersArgs
  }

  // Custom InputTypes

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAccount_ban_historyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: account_ban_historyWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAccount_storageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: account_storageWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAccount_viplistArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: account_viplistWhereInput
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }



  /**
   * Count Type PlayerCountOutputType
   */


  export type PlayerCountOutputType = {
    account_ban_history: number
    account_bans: number
    account_viplist: number
    guild_invites: number
    ip_bans: number
    market_history: number
    market_offers: number
    player_depotitems: number
    player_inboxitems: number
    player_namelocks_player_namelocks_namelocked_byToplayers: number
    player_storage: number
    player_storeinboxitems: number
  }

  export type PlayerCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    account_ban_history?: boolean | PlayerCountOutputTypeCountAccount_ban_historyArgs
    account_bans?: boolean | PlayerCountOutputTypeCountAccount_bansArgs
    account_viplist?: boolean | PlayerCountOutputTypeCountAccount_viplistArgs
    guild_invites?: boolean | PlayerCountOutputTypeCountGuild_invitesArgs
    ip_bans?: boolean | PlayerCountOutputTypeCountIp_bansArgs
    market_history?: boolean | PlayerCountOutputTypeCountMarket_historyArgs
    market_offers?: boolean | PlayerCountOutputTypeCountMarket_offersArgs
    player_depotitems?: boolean | PlayerCountOutputTypeCountPlayer_depotitemsArgs
    player_inboxitems?: boolean | PlayerCountOutputTypeCountPlayer_inboxitemsArgs
    player_namelocks_player_namelocks_namelocked_byToplayers?: boolean | PlayerCountOutputTypeCountPlayer_namelocks_player_namelocks_namelocked_byToplayersArgs
    player_storage?: boolean | PlayerCountOutputTypeCountPlayer_storageArgs
    player_storeinboxitems?: boolean | PlayerCountOutputTypeCountPlayer_storeinboxitemsArgs
  }

  // Custom InputTypes

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCountOutputType
     */
    select?: PlayerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountAccount_ban_historyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: account_ban_historyWhereInput
  }


  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountAccount_bansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: account_bansWhereInput
  }


  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountAccount_viplistArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: account_viplistWhereInput
  }


  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountGuild_invitesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: guild_invitesWhereInput
  }


  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountIp_bansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ip_bansWhereInput
  }


  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountMarket_historyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: market_historyWhereInput
  }


  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountMarket_offersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: market_offersWhereInput
  }


  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountPlayer_depotitemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: player_depotitemsWhereInput
  }


  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountPlayer_inboxitemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: player_inboxitemsWhereInput
  }


  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountPlayer_namelocks_player_namelocks_namelocked_byToplayersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: player_namelocksWhereInput
  }


  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountPlayer_storageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: player_storageWhereInput
  }


  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountPlayer_storeinboxitemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: player_storeinboxitemsWhereInput
  }



  /**
   * Count Type Guild_ranksCountOutputType
   */


  export type Guild_ranksCountOutputType = {
    guild_membership: number
  }

  export type Guild_ranksCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    guild_membership?: boolean | Guild_ranksCountOutputTypeCountGuild_membershipArgs
  }

  // Custom InputTypes

  /**
   * Guild_ranksCountOutputType without action
   */
  export type Guild_ranksCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild_ranksCountOutputType
     */
    select?: Guild_ranksCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Guild_ranksCountOutputType without action
   */
  export type Guild_ranksCountOutputTypeCountGuild_membershipArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: guild_membershipWhereInput
  }



  /**
   * Count Type Guild_warsCountOutputType
   */


  export type Guild_warsCountOutputType = {
    guildwar_kills: number
  }

  export type Guild_warsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    guildwar_kills?: boolean | Guild_warsCountOutputTypeCountGuildwar_killsArgs
  }

  // Custom InputTypes

  /**
   * Guild_warsCountOutputType without action
   */
  export type Guild_warsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guild_warsCountOutputType
     */
    select?: Guild_warsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Guild_warsCountOutputType without action
   */
  export type Guild_warsCountOutputTypeCountGuildwar_killsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: guildwar_killsWhereInput
  }



  /**
   * Count Type GuildsCountOutputType
   */


  export type GuildsCountOutputType = {
    guild_invites: number
    guild_membership: number
    guild_ranks: number
  }

  export type GuildsCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    guild_invites?: boolean | GuildsCountOutputTypeCountGuild_invitesArgs
    guild_membership?: boolean | GuildsCountOutputTypeCountGuild_membershipArgs
    guild_ranks?: boolean | GuildsCountOutputTypeCountGuild_ranksArgs
  }

  // Custom InputTypes

  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuildsCountOutputType
     */
    select?: GuildsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountGuild_invitesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: guild_invitesWhereInput
  }


  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountGuild_membershipArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: guild_membershipWhereInput
  }


  /**
   * GuildsCountOutputType without action
   */
  export type GuildsCountOutputTypeCountGuild_ranksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: guild_ranksWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    id: number | null
    type: number | null
    premium_ends_at: number | null
    creation: number | null
    premium_points: number | null
    premdays: number | null
  }

  export type AccountSumAggregateOutputType = {
    id: number | null
    type: number | null
    premium_ends_at: number | null
    creation: number | null
    premium_points: number | null
    premdays: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: number | null
    name: string | null
    password: string | null
    secret: string | null
    type: number | null
    premium_ends_at: number | null
    email: string | null
    creation: number | null
    premium_points: number | null
    premdays: number | null
    wallet: string | null
    alpha_key: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: number | null
    name: string | null
    password: string | null
    secret: string | null
    type: number | null
    premium_ends_at: number | null
    email: string | null
    creation: number | null
    premium_points: number | null
    premdays: number | null
    wallet: string | null
    alpha_key: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    name: number
    password: number
    secret: number
    type: number
    premium_ends_at: number
    email: number
    creation: number
    premium_points: number
    premdays: number
    wallet: number
    alpha_key: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    id?: true
    type?: true
    premium_ends_at?: true
    creation?: true
    premium_points?: true
    premdays?: true
  }

  export type AccountSumAggregateInputType = {
    id?: true
    type?: true
    premium_ends_at?: true
    creation?: true
    premium_points?: true
    premdays?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    name?: true
    password?: true
    secret?: true
    type?: true
    premium_ends_at?: true
    email?: true
    creation?: true
    premium_points?: true
    premdays?: true
    wallet?: true
    alpha_key?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    name?: true
    password?: true
    secret?: true
    type?: true
    premium_ends_at?: true
    email?: true
    creation?: true
    premium_points?: true
    premdays?: true
    wallet?: true
    alpha_key?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    name?: true
    password?: true
    secret?: true
    type?: true
    premium_ends_at?: true
    email?: true
    creation?: true
    premium_points?: true
    premdays?: true
    wallet?: true
    alpha_key?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: Enumerable<AccountOrderByWithAggregationInput>
    by: AccountScalarFieldEnum[]
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: number
    name: string
    password: string
    secret: string | null
    type: number
    premium_ends_at: number
    email: string
    creation: number
    premium_points: number
    premdays: number
    wallet: string | null
    alpha_key: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    password?: boolean
    secret?: boolean
    type?: boolean
    premium_ends_at?: boolean
    email?: boolean
    creation?: boolean
    premium_points?: boolean
    premdays?: boolean
    wallet?: boolean
    alpha_key?: boolean
    account_ban_history?: boolean | Account$account_ban_historyArgs<ExtArgs>
    account_bans?: boolean | account_bansArgs<ExtArgs>
    account_storage?: boolean | Account$account_storageArgs<ExtArgs>
    account_viplist?: boolean | Account$account_viplistArgs<ExtArgs>
    players?: boolean | Account$playersArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    name?: boolean
    password?: boolean
    secret?: boolean
    type?: boolean
    premium_ends_at?: boolean
    email?: boolean
    creation?: boolean
    premium_points?: boolean
    premdays?: boolean
    wallet?: boolean
    alpha_key?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    account_ban_history?: boolean | Account$account_ban_historyArgs<ExtArgs>
    account_bans?: boolean | account_bansArgs<ExtArgs>
    account_storage?: boolean | Account$account_storageArgs<ExtArgs>
    account_viplist?: boolean | Account$account_viplistArgs<ExtArgs>
    players?: boolean | Account$playersArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeArgs<ExtArgs>
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountArgs> = $Types.GetResult<AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Account'> extends True ? Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Account'> extends True ? Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    account_ban_history<T extends Account$account_ban_historyArgs<ExtArgs> = {}>(args?: Subset<T, Account$account_ban_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<account_ban_historyPayload<ExtArgs>, T, 'findMany', never>| Null>;

    account_bans<T extends account_bansArgs<ExtArgs> = {}>(args?: Subset<T, account_bansArgs<ExtArgs>>): Prisma__account_bansClient<$Types.GetResult<account_bansPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    account_storage<T extends Account$account_storageArgs<ExtArgs> = {}>(args?: Subset<T, Account$account_storageArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<account_storagePayload<ExtArgs>, T, 'findMany', never>| Null>;

    account_viplist<T extends Account$account_viplistArgs<ExtArgs> = {}>(args?: Subset<T, Account$account_viplistArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<account_viplistPayload<ExtArgs>, T, 'findMany', never>| Null>;

    players<T extends Account$playersArgs<ExtArgs> = {}>(args?: Subset<T, Account$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Account base type for findUnique actions
   */
  export type AccountFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUnique
   */
  export interface AccountFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AccountFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account base type for findFirst actions
   */
  export type AccountFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * Account findFirst
   */
  export interface AccountFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AccountFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: Enumerable<AccountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: Enumerable<AccountCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account.account_ban_history
   */
  export type Account$account_ban_historyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_ban_history
     */
    select?: account_ban_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_ban_historyInclude<ExtArgs> | null
    where?: account_ban_historyWhereInput
    orderBy?: Enumerable<account_ban_historyOrderByWithRelationInput>
    cursor?: account_ban_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Account_ban_historyScalarFieldEnum>
  }


  /**
   * Account.account_storage
   */
  export type Account$account_storageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_storage
     */
    select?: account_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_storageInclude<ExtArgs> | null
    where?: account_storageWhereInput
    orderBy?: Enumerable<account_storageOrderByWithRelationInput>
    cursor?: account_storageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Account_storageScalarFieldEnum>
  }


  /**
   * Account.account_viplist
   */
  export type Account$account_viplistArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_viplist
     */
    select?: account_viplistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_viplistInclude<ExtArgs> | null
    where?: account_viplistWhereInput
    orderBy?: Enumerable<account_viplistOrderByWithRelationInput>
    cursor?: account_viplistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Account_viplistScalarFieldEnum>
  }


  /**
   * Account.players
   */
  export type Account$playersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: Enumerable<PlayerOrderByWithRelationInput>
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PlayerScalarFieldEnum>
  }


  /**
   * Account without action
   */
  export type AccountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
  }



  /**
   * Model Player
   */


  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    id: number | null
    group_id: number | null
    account_id: number | null
    level: number | null
    vocation: number | null
    health: number | null
    healthmax: number | null
    experience: number | null
    lookbody: number | null
    lookfeet: number | null
    lookhead: number | null
    looklegs: number | null
    looktype: number | null
    lookaddons: number | null
    direction: number | null
    maglevel: number | null
    mana: number | null
    manamax: number | null
    manaspent: number | null
    soul: number | null
    town_id: number | null
    posx: number | null
    posy: number | null
    posz: number | null
    cap: number | null
    sex: number | null
    lastlogin: number | null
    lastip: number | null
    skulltime: number | null
    lastlogout: number | null
    blessings: number | null
    onlinetime: number | null
    deletion: number | null
    balance: number | null
    offlinetraining_time: number | null
    offlinetraining_skill: number | null
    stamina: number | null
    skill_fist: number | null
    skill_fist_tries: number | null
    skill_club: number | null
    skill_club_tries: number | null
    skill_sword: number | null
    skill_sword_tries: number | null
    skill_axe: number | null
    skill_axe_tries: number | null
    skill_dist: number | null
    skill_dist_tries: number | null
    skill_shielding: number | null
    skill_shielding_tries: number | null
    skill_fishing: number | null
    skill_fishing_tries: number | null
    stat_str: number | null
    stat_int: number | null
    stat_dex: number | null
    stat_vit: number | null
    stat_spr: number | null
    stat_wis: number | null
  }

  export type PlayerSumAggregateOutputType = {
    id: number | null
    group_id: number | null
    account_id: number | null
    level: number | null
    vocation: number | null
    health: number | null
    healthmax: number | null
    experience: bigint | null
    lookbody: number | null
    lookfeet: number | null
    lookhead: number | null
    looklegs: number | null
    looktype: number | null
    lookaddons: number | null
    direction: number | null
    maglevel: number | null
    mana: number | null
    manamax: number | null
    manaspent: bigint | null
    soul: number | null
    town_id: number | null
    posx: number | null
    posy: number | null
    posz: number | null
    cap: number | null
    sex: number | null
    lastlogin: bigint | null
    lastip: number | null
    skulltime: bigint | null
    lastlogout: bigint | null
    blessings: number | null
    onlinetime: bigint | null
    deletion: bigint | null
    balance: bigint | null
    offlinetraining_time: number | null
    offlinetraining_skill: number | null
    stamina: number | null
    skill_fist: number | null
    skill_fist_tries: bigint | null
    skill_club: number | null
    skill_club_tries: bigint | null
    skill_sword: number | null
    skill_sword_tries: bigint | null
    skill_axe: number | null
    skill_axe_tries: bigint | null
    skill_dist: number | null
    skill_dist_tries: bigint | null
    skill_shielding: number | null
    skill_shielding_tries: bigint | null
    skill_fishing: number | null
    skill_fishing_tries: bigint | null
    stat_str: number | null
    stat_int: number | null
    stat_dex: number | null
    stat_vit: number | null
    stat_spr: number | null
    stat_wis: number | null
  }

  export type PlayerMinAggregateOutputType = {
    id: number | null
    name: string | null
    group_id: number | null
    account_id: number | null
    level: number | null
    vocation: number | null
    health: number | null
    healthmax: number | null
    experience: bigint | null
    lookbody: number | null
    lookfeet: number | null
    lookhead: number | null
    looklegs: number | null
    looktype: number | null
    lookaddons: number | null
    direction: number | null
    maglevel: number | null
    mana: number | null
    manamax: number | null
    manaspent: bigint | null
    soul: number | null
    town_id: number | null
    posx: number | null
    posy: number | null
    posz: number | null
    conditions: Buffer | null
    cap: number | null
    sex: number | null
    lastlogin: bigint | null
    lastip: number | null
    save: boolean | null
    skull: boolean | null
    skulltime: bigint | null
    lastlogout: bigint | null
    blessings: number | null
    onlinetime: bigint | null
    deletion: bigint | null
    balance: bigint | null
    offlinetraining_time: number | null
    offlinetraining_skill: number | null
    stamina: number | null
    skill_fist: number | null
    skill_fist_tries: bigint | null
    skill_club: number | null
    skill_club_tries: bigint | null
    skill_sword: number | null
    skill_sword_tries: bigint | null
    skill_axe: number | null
    skill_axe_tries: bigint | null
    skill_dist: number | null
    skill_dist_tries: bigint | null
    skill_shielding: number | null
    skill_shielding_tries: bigint | null
    skill_fishing: number | null
    skill_fishing_tries: bigint | null
    stat_str: number | null
    stat_int: number | null
    stat_dex: number | null
    stat_vit: number | null
    stat_spr: number | null
    stat_wis: number | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    group_id: number | null
    account_id: number | null
    level: number | null
    vocation: number | null
    health: number | null
    healthmax: number | null
    experience: bigint | null
    lookbody: number | null
    lookfeet: number | null
    lookhead: number | null
    looklegs: number | null
    looktype: number | null
    lookaddons: number | null
    direction: number | null
    maglevel: number | null
    mana: number | null
    manamax: number | null
    manaspent: bigint | null
    soul: number | null
    town_id: number | null
    posx: number | null
    posy: number | null
    posz: number | null
    conditions: Buffer | null
    cap: number | null
    sex: number | null
    lastlogin: bigint | null
    lastip: number | null
    save: boolean | null
    skull: boolean | null
    skulltime: bigint | null
    lastlogout: bigint | null
    blessings: number | null
    onlinetime: bigint | null
    deletion: bigint | null
    balance: bigint | null
    offlinetraining_time: number | null
    offlinetraining_skill: number | null
    stamina: number | null
    skill_fist: number | null
    skill_fist_tries: bigint | null
    skill_club: number | null
    skill_club_tries: bigint | null
    skill_sword: number | null
    skill_sword_tries: bigint | null
    skill_axe: number | null
    skill_axe_tries: bigint | null
    skill_dist: number | null
    skill_dist_tries: bigint | null
    skill_shielding: number | null
    skill_shielding_tries: bigint | null
    skill_fishing: number | null
    skill_fishing_tries: bigint | null
    stat_str: number | null
    stat_int: number | null
    stat_dex: number | null
    stat_vit: number | null
    stat_spr: number | null
    stat_wis: number | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    name: number
    group_id: number
    account_id: number
    level: number
    vocation: number
    health: number
    healthmax: number
    experience: number
    lookbody: number
    lookfeet: number
    lookhead: number
    looklegs: number
    looktype: number
    lookaddons: number
    direction: number
    maglevel: number
    mana: number
    manamax: number
    manaspent: number
    soul: number
    town_id: number
    posx: number
    posy: number
    posz: number
    conditions: number
    cap: number
    sex: number
    lastlogin: number
    lastip: number
    save: number
    skull: number
    skulltime: number
    lastlogout: number
    blessings: number
    onlinetime: number
    deletion: number
    balance: number
    offlinetraining_time: number
    offlinetraining_skill: number
    stamina: number
    skill_fist: number
    skill_fist_tries: number
    skill_club: number
    skill_club_tries: number
    skill_sword: number
    skill_sword_tries: number
    skill_axe: number
    skill_axe_tries: number
    skill_dist: number
    skill_dist_tries: number
    skill_shielding: number
    skill_shielding_tries: number
    skill_fishing: number
    skill_fishing_tries: number
    stat_str: number
    stat_int: number
    stat_dex: number
    stat_vit: number
    stat_spr: number
    stat_wis: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    id?: true
    group_id?: true
    account_id?: true
    level?: true
    vocation?: true
    health?: true
    healthmax?: true
    experience?: true
    lookbody?: true
    lookfeet?: true
    lookhead?: true
    looklegs?: true
    looktype?: true
    lookaddons?: true
    direction?: true
    maglevel?: true
    mana?: true
    manamax?: true
    manaspent?: true
    soul?: true
    town_id?: true
    posx?: true
    posy?: true
    posz?: true
    cap?: true
    sex?: true
    lastlogin?: true
    lastip?: true
    skulltime?: true
    lastlogout?: true
    blessings?: true
    onlinetime?: true
    deletion?: true
    balance?: true
    offlinetraining_time?: true
    offlinetraining_skill?: true
    stamina?: true
    skill_fist?: true
    skill_fist_tries?: true
    skill_club?: true
    skill_club_tries?: true
    skill_sword?: true
    skill_sword_tries?: true
    skill_axe?: true
    skill_axe_tries?: true
    skill_dist?: true
    skill_dist_tries?: true
    skill_shielding?: true
    skill_shielding_tries?: true
    skill_fishing?: true
    skill_fishing_tries?: true
    stat_str?: true
    stat_int?: true
    stat_dex?: true
    stat_vit?: true
    stat_spr?: true
    stat_wis?: true
  }

  export type PlayerSumAggregateInputType = {
    id?: true
    group_id?: true
    account_id?: true
    level?: true
    vocation?: true
    health?: true
    healthmax?: true
    experience?: true
    lookbody?: true
    lookfeet?: true
    lookhead?: true
    looklegs?: true
    looktype?: true
    lookaddons?: true
    direction?: true
    maglevel?: true
    mana?: true
    manamax?: true
    manaspent?: true
    soul?: true
    town_id?: true
    posx?: true
    posy?: true
    posz?: true
    cap?: true
    sex?: true
    lastlogin?: true
    lastip?: true
    skulltime?: true
    lastlogout?: true
    blessings?: true
    onlinetime?: true
    deletion?: true
    balance?: true
    offlinetraining_time?: true
    offlinetraining_skill?: true
    stamina?: true
    skill_fist?: true
    skill_fist_tries?: true
    skill_club?: true
    skill_club_tries?: true
    skill_sword?: true
    skill_sword_tries?: true
    skill_axe?: true
    skill_axe_tries?: true
    skill_dist?: true
    skill_dist_tries?: true
    skill_shielding?: true
    skill_shielding_tries?: true
    skill_fishing?: true
    skill_fishing_tries?: true
    stat_str?: true
    stat_int?: true
    stat_dex?: true
    stat_vit?: true
    stat_spr?: true
    stat_wis?: true
  }

  export type PlayerMinAggregateInputType = {
    id?: true
    name?: true
    group_id?: true
    account_id?: true
    level?: true
    vocation?: true
    health?: true
    healthmax?: true
    experience?: true
    lookbody?: true
    lookfeet?: true
    lookhead?: true
    looklegs?: true
    looktype?: true
    lookaddons?: true
    direction?: true
    maglevel?: true
    mana?: true
    manamax?: true
    manaspent?: true
    soul?: true
    town_id?: true
    posx?: true
    posy?: true
    posz?: true
    conditions?: true
    cap?: true
    sex?: true
    lastlogin?: true
    lastip?: true
    save?: true
    skull?: true
    skulltime?: true
    lastlogout?: true
    blessings?: true
    onlinetime?: true
    deletion?: true
    balance?: true
    offlinetraining_time?: true
    offlinetraining_skill?: true
    stamina?: true
    skill_fist?: true
    skill_fist_tries?: true
    skill_club?: true
    skill_club_tries?: true
    skill_sword?: true
    skill_sword_tries?: true
    skill_axe?: true
    skill_axe_tries?: true
    skill_dist?: true
    skill_dist_tries?: true
    skill_shielding?: true
    skill_shielding_tries?: true
    skill_fishing?: true
    skill_fishing_tries?: true
    stat_str?: true
    stat_int?: true
    stat_dex?: true
    stat_vit?: true
    stat_spr?: true
    stat_wis?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    name?: true
    group_id?: true
    account_id?: true
    level?: true
    vocation?: true
    health?: true
    healthmax?: true
    experience?: true
    lookbody?: true
    lookfeet?: true
    lookhead?: true
    looklegs?: true
    looktype?: true
    lookaddons?: true
    direction?: true
    maglevel?: true
    mana?: true
    manamax?: true
    manaspent?: true
    soul?: true
    town_id?: true
    posx?: true
    posy?: true
    posz?: true
    conditions?: true
    cap?: true
    sex?: true
    lastlogin?: true
    lastip?: true
    save?: true
    skull?: true
    skulltime?: true
    lastlogout?: true
    blessings?: true
    onlinetime?: true
    deletion?: true
    balance?: true
    offlinetraining_time?: true
    offlinetraining_skill?: true
    stamina?: true
    skill_fist?: true
    skill_fist_tries?: true
    skill_club?: true
    skill_club_tries?: true
    skill_sword?: true
    skill_sword_tries?: true
    skill_axe?: true
    skill_axe_tries?: true
    skill_dist?: true
    skill_dist_tries?: true
    skill_shielding?: true
    skill_shielding_tries?: true
    skill_fishing?: true
    skill_fishing_tries?: true
    stat_str?: true
    stat_int?: true
    stat_dex?: true
    stat_vit?: true
    stat_spr?: true
    stat_wis?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    name?: true
    group_id?: true
    account_id?: true
    level?: true
    vocation?: true
    health?: true
    healthmax?: true
    experience?: true
    lookbody?: true
    lookfeet?: true
    lookhead?: true
    looklegs?: true
    looktype?: true
    lookaddons?: true
    direction?: true
    maglevel?: true
    mana?: true
    manamax?: true
    manaspent?: true
    soul?: true
    town_id?: true
    posx?: true
    posy?: true
    posz?: true
    conditions?: true
    cap?: true
    sex?: true
    lastlogin?: true
    lastip?: true
    save?: true
    skull?: true
    skulltime?: true
    lastlogout?: true
    blessings?: true
    onlinetime?: true
    deletion?: true
    balance?: true
    offlinetraining_time?: true
    offlinetraining_skill?: true
    stamina?: true
    skill_fist?: true
    skill_fist_tries?: true
    skill_club?: true
    skill_club_tries?: true
    skill_sword?: true
    skill_sword_tries?: true
    skill_axe?: true
    skill_axe_tries?: true
    skill_dist?: true
    skill_dist_tries?: true
    skill_shielding?: true
    skill_shielding_tries?: true
    skill_fishing?: true
    skill_fishing_tries?: true
    stat_str?: true
    stat_int?: true
    stat_dex?: true
    stat_vit?: true
    stat_spr?: true
    stat_wis?: true
    _all?: true
  }

  export type PlayerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Player to aggregate.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: Enumerable<PlayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
    orderBy?: Enumerable<PlayerOrderByWithAggregationInput>
    by: PlayerScalarFieldEnum[]
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }


  export type PlayerGroupByOutputType = {
    id: number
    name: string
    group_id: number
    account_id: number
    level: number
    vocation: number
    health: number
    healthmax: number
    experience: bigint
    lookbody: number
    lookfeet: number
    lookhead: number
    looklegs: number
    looktype: number
    lookaddons: number
    direction: number
    maglevel: number
    mana: number
    manamax: number
    manaspent: bigint
    soul: number
    town_id: number
    posx: number
    posy: number
    posz: number
    conditions: Buffer
    cap: number
    sex: number
    lastlogin: bigint
    lastip: number
    save: boolean
    skull: boolean
    skulltime: bigint
    lastlogout: bigint
    blessings: number
    onlinetime: bigint
    deletion: bigint
    balance: bigint
    offlinetraining_time: number
    offlinetraining_skill: number
    stamina: number
    skill_fist: number
    skill_fist_tries: bigint
    skill_club: number
    skill_club_tries: bigint
    skill_sword: number
    skill_sword_tries: bigint
    skill_axe: number
    skill_axe_tries: bigint
    skill_dist: number
    skill_dist_tries: bigint
    skill_shielding: number
    skill_shielding_tries: bigint
    skill_fishing: number
    skill_fishing_tries: bigint
    stat_str: number
    stat_int: number
    stat_dex: number
    stat_vit: number
    stat_spr: number
    stat_wis: number
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    group_id?: boolean
    account_id?: boolean
    level?: boolean
    vocation?: boolean
    health?: boolean
    healthmax?: boolean
    experience?: boolean
    lookbody?: boolean
    lookfeet?: boolean
    lookhead?: boolean
    looklegs?: boolean
    looktype?: boolean
    lookaddons?: boolean
    direction?: boolean
    maglevel?: boolean
    mana?: boolean
    manamax?: boolean
    manaspent?: boolean
    soul?: boolean
    town_id?: boolean
    posx?: boolean
    posy?: boolean
    posz?: boolean
    conditions?: boolean
    cap?: boolean
    sex?: boolean
    lastlogin?: boolean
    lastip?: boolean
    save?: boolean
    skull?: boolean
    skulltime?: boolean
    lastlogout?: boolean
    blessings?: boolean
    onlinetime?: boolean
    deletion?: boolean
    balance?: boolean
    offlinetraining_time?: boolean
    offlinetraining_skill?: boolean
    stamina?: boolean
    skill_fist?: boolean
    skill_fist_tries?: boolean
    skill_club?: boolean
    skill_club_tries?: boolean
    skill_sword?: boolean
    skill_sword_tries?: boolean
    skill_axe?: boolean
    skill_axe_tries?: boolean
    skill_dist?: boolean
    skill_dist_tries?: boolean
    skill_shielding?: boolean
    skill_shielding_tries?: boolean
    skill_fishing?: boolean
    skill_fishing_tries?: boolean
    stat_str?: boolean
    stat_int?: boolean
    stat_dex?: boolean
    stat_vit?: boolean
    stat_spr?: boolean
    stat_wis?: boolean
    account_ban_history?: boolean | Player$account_ban_historyArgs<ExtArgs>
    account_bans?: boolean | Player$account_bansArgs<ExtArgs>
    account_viplist?: boolean | Player$account_viplistArgs<ExtArgs>
    guild_invites?: boolean | Player$guild_invitesArgs<ExtArgs>
    guild_membership?: boolean | guild_membershipArgs<ExtArgs>
    guilds?: boolean | guildsArgs<ExtArgs>
    ip_bans?: boolean | Player$ip_bansArgs<ExtArgs>
    market_history?: boolean | Player$market_historyArgs<ExtArgs>
    market_offers?: boolean | Player$market_offersArgs<ExtArgs>
    player_depotitems?: boolean | Player$player_depotitemsArgs<ExtArgs>
    player_inboxitems?: boolean | Player$player_inboxitemsArgs<ExtArgs>
    player_namelocks_player_namelocks_player_idToplayers?: boolean | player_namelocksArgs<ExtArgs>
    player_namelocks_player_namelocks_namelocked_byToplayers?: boolean | Player$player_namelocks_player_namelocks_namelocked_byToplayersArgs<ExtArgs>
    player_storage?: boolean | Player$player_storageArgs<ExtArgs>
    player_storeinboxitems?: boolean | Player$player_storeinboxitemsArgs<ExtArgs>
    accounts?: boolean | AccountArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectScalar = {
    id?: boolean
    name?: boolean
    group_id?: boolean
    account_id?: boolean
    level?: boolean
    vocation?: boolean
    health?: boolean
    healthmax?: boolean
    experience?: boolean
    lookbody?: boolean
    lookfeet?: boolean
    lookhead?: boolean
    looklegs?: boolean
    looktype?: boolean
    lookaddons?: boolean
    direction?: boolean
    maglevel?: boolean
    mana?: boolean
    manamax?: boolean
    manaspent?: boolean
    soul?: boolean
    town_id?: boolean
    posx?: boolean
    posy?: boolean
    posz?: boolean
    conditions?: boolean
    cap?: boolean
    sex?: boolean
    lastlogin?: boolean
    lastip?: boolean
    save?: boolean
    skull?: boolean
    skulltime?: boolean
    lastlogout?: boolean
    blessings?: boolean
    onlinetime?: boolean
    deletion?: boolean
    balance?: boolean
    offlinetraining_time?: boolean
    offlinetraining_skill?: boolean
    stamina?: boolean
    skill_fist?: boolean
    skill_fist_tries?: boolean
    skill_club?: boolean
    skill_club_tries?: boolean
    skill_sword?: boolean
    skill_sword_tries?: boolean
    skill_axe?: boolean
    skill_axe_tries?: boolean
    skill_dist?: boolean
    skill_dist_tries?: boolean
    skill_shielding?: boolean
    skill_shielding_tries?: boolean
    skill_fishing?: boolean
    skill_fishing_tries?: boolean
    stat_str?: boolean
    stat_int?: boolean
    stat_dex?: boolean
    stat_vit?: boolean
    stat_spr?: boolean
    stat_wis?: boolean
  }

  export type PlayerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    account_ban_history?: boolean | Player$account_ban_historyArgs<ExtArgs>
    account_bans?: boolean | Player$account_bansArgs<ExtArgs>
    account_viplist?: boolean | Player$account_viplistArgs<ExtArgs>
    guild_invites?: boolean | Player$guild_invitesArgs<ExtArgs>
    guild_membership?: boolean | guild_membershipArgs<ExtArgs>
    guilds?: boolean | guildsArgs<ExtArgs>
    ip_bans?: boolean | Player$ip_bansArgs<ExtArgs>
    market_history?: boolean | Player$market_historyArgs<ExtArgs>
    market_offers?: boolean | Player$market_offersArgs<ExtArgs>
    player_depotitems?: boolean | Player$player_depotitemsArgs<ExtArgs>
    player_inboxitems?: boolean | Player$player_inboxitemsArgs<ExtArgs>
    player_namelocks_player_namelocks_player_idToplayers?: boolean | player_namelocksArgs<ExtArgs>
    player_namelocks_player_namelocks_namelocked_byToplayers?: boolean | Player$player_namelocks_player_namelocks_namelocked_byToplayersArgs<ExtArgs>
    player_storage?: boolean | Player$player_storageArgs<ExtArgs>
    player_storeinboxitems?: boolean | Player$player_storeinboxitemsArgs<ExtArgs>
    accounts?: boolean | AccountArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeArgs<ExtArgs>
  }


  type PlayerGetPayload<S extends boolean | null | undefined | PlayerArgs> = $Types.GetResult<PlayerPayload, S>

  type PlayerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PlayerFindManyArgs, 'select' | 'include'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface PlayerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Player'], meta: { name: 'Player' } }
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlayerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PlayerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Player'> extends True ? Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Player that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PlayerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlayerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlayerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PlayerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Player'> extends True ? Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Player that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlayerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlayerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
    **/
    create<T extends PlayerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerCreateArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Players.
     *     @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     *     @example
     *     // Create many Players
     *     const player = await prisma.player.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlayerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
    **/
    delete<T extends PlayerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerDeleteArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlayerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerUpdateArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlayerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlayerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlayerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
    **/
    upsert<T extends PlayerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PlayerUpsertArgs<ExtArgs>>
    ): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlayerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    account_ban_history<T extends Player$account_ban_historyArgs<ExtArgs> = {}>(args?: Subset<T, Player$account_ban_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<account_ban_historyPayload<ExtArgs>, T, 'findMany', never>| Null>;

    account_bans<T extends Player$account_bansArgs<ExtArgs> = {}>(args?: Subset<T, Player$account_bansArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<account_bansPayload<ExtArgs>, T, 'findMany', never>| Null>;

    account_viplist<T extends Player$account_viplistArgs<ExtArgs> = {}>(args?: Subset<T, Player$account_viplistArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<account_viplistPayload<ExtArgs>, T, 'findMany', never>| Null>;

    guild_invites<T extends Player$guild_invitesArgs<ExtArgs> = {}>(args?: Subset<T, Player$guild_invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<guild_invitesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    guild_membership<T extends guild_membershipArgs<ExtArgs> = {}>(args?: Subset<T, guild_membershipArgs<ExtArgs>>): Prisma__guild_membershipClient<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    guilds<T extends guildsArgs<ExtArgs> = {}>(args?: Subset<T, guildsArgs<ExtArgs>>): Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    ip_bans<T extends Player$ip_bansArgs<ExtArgs> = {}>(args?: Subset<T, Player$ip_bansArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ip_bansPayload<ExtArgs>, T, 'findMany', never>| Null>;

    market_history<T extends Player$market_historyArgs<ExtArgs> = {}>(args?: Subset<T, Player$market_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<market_historyPayload<ExtArgs>, T, 'findMany', never>| Null>;

    market_offers<T extends Player$market_offersArgs<ExtArgs> = {}>(args?: Subset<T, Player$market_offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<market_offersPayload<ExtArgs>, T, 'findMany', never>| Null>;

    player_depotitems<T extends Player$player_depotitemsArgs<ExtArgs> = {}>(args?: Subset<T, Player$player_depotitemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<player_depotitemsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    player_inboxitems<T extends Player$player_inboxitemsArgs<ExtArgs> = {}>(args?: Subset<T, Player$player_inboxitemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<player_inboxitemsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    player_namelocks_player_namelocks_player_idToplayers<T extends player_namelocksArgs<ExtArgs> = {}>(args?: Subset<T, player_namelocksArgs<ExtArgs>>): Prisma__player_namelocksClient<$Types.GetResult<player_namelocksPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    player_namelocks_player_namelocks_namelocked_byToplayers<T extends Player$player_namelocks_player_namelocks_namelocked_byToplayersArgs<ExtArgs> = {}>(args?: Subset<T, Player$player_namelocks_player_namelocks_namelocked_byToplayersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<player_namelocksPayload<ExtArgs>, T, 'findMany', never>| Null>;

    player_storage<T extends Player$player_storageArgs<ExtArgs> = {}>(args?: Subset<T, Player$player_storageArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<player_storagePayload<ExtArgs>, T, 'findMany', never>| Null>;

    player_storeinboxitems<T extends Player$player_storeinboxitemsArgs<ExtArgs> = {}>(args?: Subset<T, Player$player_storeinboxitemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<player_storeinboxitemsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    accounts<T extends AccountArgs<ExtArgs> = {}>(args?: Subset<T, AccountArgs<ExtArgs>>): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Player base type for findUnique actions
   */
  export type PlayerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findUnique
   */
  export interface PlayerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PlayerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Player findUniqueOrThrow
   */
  export type PlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }


  /**
   * Player base type for findFirst actions
   */
  export type PlayerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: Enumerable<PlayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: Enumerable<PlayerScalarFieldEnum>
  }

  /**
   * Player findFirst
   */
  export interface PlayerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PlayerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Player findFirstOrThrow
   */
  export type PlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: Enumerable<PlayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: Enumerable<PlayerScalarFieldEnum>
  }


  /**
   * Player findMany
   */
  export type PlayerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Players to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: Enumerable<PlayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    distinct?: Enumerable<PlayerScalarFieldEnum>
  }


  /**
   * Player create
   */
  export type PlayerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Player.
     */
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }


  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Players.
     */
    data: Enumerable<PlayerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Player update
   */
  export type PlayerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Player.
     */
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     */
    where: PlayerWhereUniqueInput
  }


  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
  }


  /**
   * Player upsert
   */
  export type PlayerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Player to update in case it exists.
     */
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     */
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }


  /**
   * Player delete
   */
  export type PlayerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter which Player to delete.
     */
    where: PlayerWhereUniqueInput
  }


  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Players to delete
     */
    where?: PlayerWhereInput
  }


  /**
   * Player.account_ban_history
   */
  export type Player$account_ban_historyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_ban_history
     */
    select?: account_ban_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_ban_historyInclude<ExtArgs> | null
    where?: account_ban_historyWhereInput
    orderBy?: Enumerable<account_ban_historyOrderByWithRelationInput>
    cursor?: account_ban_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Account_ban_historyScalarFieldEnum>
  }


  /**
   * Player.account_bans
   */
  export type Player$account_bansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_bans
     */
    select?: account_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_bansInclude<ExtArgs> | null
    where?: account_bansWhereInput
    orderBy?: Enumerable<account_bansOrderByWithRelationInput>
    cursor?: account_bansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Account_bansScalarFieldEnum>
  }


  /**
   * Player.account_viplist
   */
  export type Player$account_viplistArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_viplist
     */
    select?: account_viplistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_viplistInclude<ExtArgs> | null
    where?: account_viplistWhereInput
    orderBy?: Enumerable<account_viplistOrderByWithRelationInput>
    cursor?: account_viplistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Account_viplistScalarFieldEnum>
  }


  /**
   * Player.guild_invites
   */
  export type Player$guild_invitesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_invites
     */
    select?: guild_invitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_invitesInclude<ExtArgs> | null
    where?: guild_invitesWhereInput
    orderBy?: Enumerable<guild_invitesOrderByWithRelationInput>
    cursor?: guild_invitesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Guild_invitesScalarFieldEnum>
  }


  /**
   * Player.ip_bans
   */
  export type Player$ip_bansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ip_bans
     */
    select?: ip_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ip_bansInclude<ExtArgs> | null
    where?: ip_bansWhereInput
    orderBy?: Enumerable<ip_bansOrderByWithRelationInput>
    cursor?: ip_bansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Ip_bansScalarFieldEnum>
  }


  /**
   * Player.market_history
   */
  export type Player$market_historyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_history
     */
    select?: market_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_historyInclude<ExtArgs> | null
    where?: market_historyWhereInput
    orderBy?: Enumerable<market_historyOrderByWithRelationInput>
    cursor?: market_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Market_historyScalarFieldEnum>
  }


  /**
   * Player.market_offers
   */
  export type Player$market_offersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_offers
     */
    select?: market_offersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_offersInclude<ExtArgs> | null
    where?: market_offersWhereInput
    orderBy?: Enumerable<market_offersOrderByWithRelationInput>
    cursor?: market_offersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Market_offersScalarFieldEnum>
  }


  /**
   * Player.player_depotitems
   */
  export type Player$player_depotitemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_depotitems
     */
    select?: player_depotitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_depotitemsInclude<ExtArgs> | null
    where?: player_depotitemsWhereInput
    orderBy?: Enumerable<player_depotitemsOrderByWithRelationInput>
    cursor?: player_depotitemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Player_depotitemsScalarFieldEnum>
  }


  /**
   * Player.player_inboxitems
   */
  export type Player$player_inboxitemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_inboxitems
     */
    select?: player_inboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_inboxitemsInclude<ExtArgs> | null
    where?: player_inboxitemsWhereInput
    orderBy?: Enumerable<player_inboxitemsOrderByWithRelationInput>
    cursor?: player_inboxitemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Player_inboxitemsScalarFieldEnum>
  }


  /**
   * Player.player_namelocks_player_namelocks_namelocked_byToplayers
   */
  export type Player$player_namelocks_player_namelocks_namelocked_byToplayersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_namelocks
     */
    select?: player_namelocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_namelocksInclude<ExtArgs> | null
    where?: player_namelocksWhereInput
    orderBy?: Enumerable<player_namelocksOrderByWithRelationInput>
    cursor?: player_namelocksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Player_namelocksScalarFieldEnum>
  }


  /**
   * Player.player_storage
   */
  export type Player$player_storageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storage
     */
    select?: player_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storageInclude<ExtArgs> | null
    where?: player_storageWhereInput
    orderBy?: Enumerable<player_storageOrderByWithRelationInput>
    cursor?: player_storageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Player_storageScalarFieldEnum>
  }


  /**
   * Player.player_storeinboxitems
   */
  export type Player$player_storeinboxitemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storeinboxitems
     */
    select?: player_storeinboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storeinboxitemsInclude<ExtArgs> | null
    where?: player_storeinboxitemsWhereInput
    orderBy?: Enumerable<player_storeinboxitemsOrderByWithRelationInput>
    cursor?: player_storeinboxitemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Player_storeinboxitemsScalarFieldEnum>
  }


  /**
   * Player without action
   */
  export type PlayerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PlayerInclude<ExtArgs> | null
  }



  /**
   * Model House
   */


  export type AggregateHouse = {
    _count: HouseCountAggregateOutputType | null
    _avg: HouseAvgAggregateOutputType | null
    _sum: HouseSumAggregateOutputType | null
    _min: HouseMinAggregateOutputType | null
    _max: HouseMaxAggregateOutputType | null
  }

  export type HouseAvgAggregateOutputType = {
    id: number | null
    owner: number | null
    paid: number | null
    warnings: number | null
    rent: number | null
    town_id: number | null
    bid: number | null
    bid_end: number | null
    last_bid: number | null
    highest_bidder: number | null
    size: number | null
    beds: number | null
  }

  export type HouseSumAggregateOutputType = {
    id: number | null
    owner: number | null
    paid: number | null
    warnings: number | null
    rent: number | null
    town_id: number | null
    bid: number | null
    bid_end: number | null
    last_bid: number | null
    highest_bidder: number | null
    size: number | null
    beds: number | null
  }

  export type HouseMinAggregateOutputType = {
    id: number | null
    owner: number | null
    paid: number | null
    warnings: number | null
    name: string | null
    rent: number | null
    town_id: number | null
    bid: number | null
    bid_end: number | null
    last_bid: number | null
    highest_bidder: number | null
    size: number | null
    beds: number | null
    land_zone: string | null
    land_plot: string | null
    bioma: string | null
    land_size: string | null
    plant: string | null
    harvest: string | null
    mining: string | null
    livestock: string | null
    fishing_boat: string | null
    enable: boolean | null
  }

  export type HouseMaxAggregateOutputType = {
    id: number | null
    owner: number | null
    paid: number | null
    warnings: number | null
    name: string | null
    rent: number | null
    town_id: number | null
    bid: number | null
    bid_end: number | null
    last_bid: number | null
    highest_bidder: number | null
    size: number | null
    beds: number | null
    land_zone: string | null
    land_plot: string | null
    bioma: string | null
    land_size: string | null
    plant: string | null
    harvest: string | null
    mining: string | null
    livestock: string | null
    fishing_boat: string | null
    enable: boolean | null
  }

  export type HouseCountAggregateOutputType = {
    id: number
    owner: number
    paid: number
    warnings: number
    name: number
    rent: number
    town_id: number
    bid: number
    bid_end: number
    last_bid: number
    highest_bidder: number
    size: number
    beds: number
    land_zone: number
    land_plot: number
    bioma: number
    land_size: number
    plant: number
    harvest: number
    mining: number
    livestock: number
    fishing_boat: number
    json_data: number
    enable: number
    _all: number
  }


  export type HouseAvgAggregateInputType = {
    id?: true
    owner?: true
    paid?: true
    warnings?: true
    rent?: true
    town_id?: true
    bid?: true
    bid_end?: true
    last_bid?: true
    highest_bidder?: true
    size?: true
    beds?: true
  }

  export type HouseSumAggregateInputType = {
    id?: true
    owner?: true
    paid?: true
    warnings?: true
    rent?: true
    town_id?: true
    bid?: true
    bid_end?: true
    last_bid?: true
    highest_bidder?: true
    size?: true
    beds?: true
  }

  export type HouseMinAggregateInputType = {
    id?: true
    owner?: true
    paid?: true
    warnings?: true
    name?: true
    rent?: true
    town_id?: true
    bid?: true
    bid_end?: true
    last_bid?: true
    highest_bidder?: true
    size?: true
    beds?: true
    land_zone?: true
    land_plot?: true
    bioma?: true
    land_size?: true
    plant?: true
    harvest?: true
    mining?: true
    livestock?: true
    fishing_boat?: true
    enable?: true
  }

  export type HouseMaxAggregateInputType = {
    id?: true
    owner?: true
    paid?: true
    warnings?: true
    name?: true
    rent?: true
    town_id?: true
    bid?: true
    bid_end?: true
    last_bid?: true
    highest_bidder?: true
    size?: true
    beds?: true
    land_zone?: true
    land_plot?: true
    bioma?: true
    land_size?: true
    plant?: true
    harvest?: true
    mining?: true
    livestock?: true
    fishing_boat?: true
    enable?: true
  }

  export type HouseCountAggregateInputType = {
    id?: true
    owner?: true
    paid?: true
    warnings?: true
    name?: true
    rent?: true
    town_id?: true
    bid?: true
    bid_end?: true
    last_bid?: true
    highest_bidder?: true
    size?: true
    beds?: true
    land_zone?: true
    land_plot?: true
    bioma?: true
    land_size?: true
    plant?: true
    harvest?: true
    mining?: true
    livestock?: true
    fishing_boat?: true
    json_data?: true
    enable?: true
    _all?: true
  }

  export type HouseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which House to aggregate.
     */
    where?: HouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Houses to fetch.
     */
    orderBy?: Enumerable<HouseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Houses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Houses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Houses
    **/
    _count?: true | HouseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HouseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HouseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HouseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HouseMaxAggregateInputType
  }

  export type GetHouseAggregateType<T extends HouseAggregateArgs> = {
        [P in keyof T & keyof AggregateHouse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHouse[P]>
      : GetScalarType<T[P], AggregateHouse[P]>
  }




  export type HouseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: HouseWhereInput
    orderBy?: Enumerable<HouseOrderByWithAggregationInput>
    by: HouseScalarFieldEnum[]
    having?: HouseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HouseCountAggregateInputType | true
    _avg?: HouseAvgAggregateInputType
    _sum?: HouseSumAggregateInputType
    _min?: HouseMinAggregateInputType
    _max?: HouseMaxAggregateInputType
  }


  export type HouseGroupByOutputType = {
    id: number
    owner: number
    paid: number
    warnings: number
    name: string
    rent: number
    town_id: number
    bid: number
    bid_end: number
    last_bid: number
    highest_bidder: number
    size: number
    beds: number
    land_zone: string
    land_plot: string
    bioma: string
    land_size: string
    plant: string
    harvest: string
    mining: string
    livestock: string
    fishing_boat: string
    json_data: JsonValue | null
    enable: boolean
    _count: HouseCountAggregateOutputType | null
    _avg: HouseAvgAggregateOutputType | null
    _sum: HouseSumAggregateOutputType | null
    _min: HouseMinAggregateOutputType | null
    _max: HouseMaxAggregateOutputType | null
  }

  type GetHouseGroupByPayload<T extends HouseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HouseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HouseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HouseGroupByOutputType[P]>
            : GetScalarType<T[P], HouseGroupByOutputType[P]>
        }
      >
    >


  export type HouseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    owner?: boolean
    paid?: boolean
    warnings?: boolean
    name?: boolean
    rent?: boolean
    town_id?: boolean
    bid?: boolean
    bid_end?: boolean
    last_bid?: boolean
    highest_bidder?: boolean
    size?: boolean
    beds?: boolean
    land_zone?: boolean
    land_plot?: boolean
    bioma?: boolean
    land_size?: boolean
    plant?: boolean
    harvest?: boolean
    mining?: boolean
    livestock?: boolean
    fishing_boat?: boolean
    json_data?: boolean
    enable?: boolean
  }, ExtArgs["result"]["house"]>

  export type HouseSelectScalar = {
    id?: boolean
    owner?: boolean
    paid?: boolean
    warnings?: boolean
    name?: boolean
    rent?: boolean
    town_id?: boolean
    bid?: boolean
    bid_end?: boolean
    last_bid?: boolean
    highest_bidder?: boolean
    size?: boolean
    beds?: boolean
    land_zone?: boolean
    land_plot?: boolean
    bioma?: boolean
    land_size?: boolean
    plant?: boolean
    harvest?: boolean
    mining?: boolean
    livestock?: boolean
    fishing_boat?: boolean
    json_data?: boolean
    enable?: boolean
  }


  type HouseGetPayload<S extends boolean | null | undefined | HouseArgs> = $Types.GetResult<HousePayload, S>

  type HouseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<HouseFindManyArgs, 'select' | 'include'> & {
      select?: HouseCountAggregateInputType | true
    }

  export interface HouseDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['House'], meta: { name: 'House' } }
    /**
     * Find zero or one House that matches the filter.
     * @param {HouseFindUniqueArgs} args - Arguments to find a House
     * @example
     * // Get one House
     * const house = await prisma.house.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HouseFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HouseFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'House'> extends True ? Prisma__HouseClient<$Types.GetResult<HousePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__HouseClient<$Types.GetResult<HousePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one House that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HouseFindUniqueOrThrowArgs} args - Arguments to find a House
     * @example
     * // Get one House
     * const house = await prisma.house.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HouseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HouseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HouseClient<$Types.GetResult<HousePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first House that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseFindFirstArgs} args - Arguments to find a House
     * @example
     * // Get one House
     * const house = await prisma.house.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HouseFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HouseFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'House'> extends True ? Prisma__HouseClient<$Types.GetResult<HousePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__HouseClient<$Types.GetResult<HousePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first House that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseFindFirstOrThrowArgs} args - Arguments to find a House
     * @example
     * // Get one House
     * const house = await prisma.house.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HouseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HouseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HouseClient<$Types.GetResult<HousePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Houses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Houses
     * const houses = await prisma.house.findMany()
     * 
     * // Get first 10 Houses
     * const houses = await prisma.house.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const houseWithIdOnly = await prisma.house.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HouseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HouseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<HousePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a House.
     * @param {HouseCreateArgs} args - Arguments to create a House.
     * @example
     * // Create one House
     * const House = await prisma.house.create({
     *   data: {
     *     // ... data to create a House
     *   }
     * })
     * 
    **/
    create<T extends HouseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HouseCreateArgs<ExtArgs>>
    ): Prisma__HouseClient<$Types.GetResult<HousePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Houses.
     *     @param {HouseCreateManyArgs} args - Arguments to create many Houses.
     *     @example
     *     // Create many Houses
     *     const house = await prisma.house.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HouseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HouseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a House.
     * @param {HouseDeleteArgs} args - Arguments to delete one House.
     * @example
     * // Delete one House
     * const House = await prisma.house.delete({
     *   where: {
     *     // ... filter to delete one House
     *   }
     * })
     * 
    **/
    delete<T extends HouseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HouseDeleteArgs<ExtArgs>>
    ): Prisma__HouseClient<$Types.GetResult<HousePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one House.
     * @param {HouseUpdateArgs} args - Arguments to update one House.
     * @example
     * // Update one House
     * const house = await prisma.house.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HouseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HouseUpdateArgs<ExtArgs>>
    ): Prisma__HouseClient<$Types.GetResult<HousePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Houses.
     * @param {HouseDeleteManyArgs} args - Arguments to filter Houses to delete.
     * @example
     * // Delete a few Houses
     * const { count } = await prisma.house.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HouseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HouseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Houses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Houses
     * const house = await prisma.house.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HouseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HouseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one House.
     * @param {HouseUpsertArgs} args - Arguments to update or create a House.
     * @example
     * // Update or create a House
     * const house = await prisma.house.upsert({
     *   create: {
     *     // ... data to create a House
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the House we want to update
     *   }
     * })
    **/
    upsert<T extends HouseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HouseUpsertArgs<ExtArgs>>
    ): Prisma__HouseClient<$Types.GetResult<HousePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Houses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseCountArgs} args - Arguments to filter Houses to count.
     * @example
     * // Count the number of Houses
     * const count = await prisma.house.count({
     *   where: {
     *     // ... the filter for the Houses we want to count
     *   }
     * })
    **/
    count<T extends HouseCountArgs>(
      args?: Subset<T, HouseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HouseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a House.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HouseAggregateArgs>(args: Subset<T, HouseAggregateArgs>): Prisma.PrismaPromise<GetHouseAggregateType<T>>

    /**
     * Group by House.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HouseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HouseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HouseGroupByArgs['orderBy'] }
        : { orderBy?: HouseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HouseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHouseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for House.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HouseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * House base type for findUnique actions
   */
  export type HouseFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the House
     */
    select?: HouseSelect<ExtArgs> | null
    /**
     * Filter, which House to fetch.
     */
    where: HouseWhereUniqueInput
  }

  /**
   * House findUnique
   */
  export interface HouseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends HouseFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * House findUniqueOrThrow
   */
  export type HouseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the House
     */
    select?: HouseSelect<ExtArgs> | null
    /**
     * Filter, which House to fetch.
     */
    where: HouseWhereUniqueInput
  }


  /**
   * House base type for findFirst actions
   */
  export type HouseFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the House
     */
    select?: HouseSelect<ExtArgs> | null
    /**
     * Filter, which House to fetch.
     */
    where?: HouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Houses to fetch.
     */
    orderBy?: Enumerable<HouseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Houses.
     */
    cursor?: HouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Houses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Houses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Houses.
     */
    distinct?: Enumerable<HouseScalarFieldEnum>
  }

  /**
   * House findFirst
   */
  export interface HouseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends HouseFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * House findFirstOrThrow
   */
  export type HouseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the House
     */
    select?: HouseSelect<ExtArgs> | null
    /**
     * Filter, which House to fetch.
     */
    where?: HouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Houses to fetch.
     */
    orderBy?: Enumerable<HouseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Houses.
     */
    cursor?: HouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Houses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Houses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Houses.
     */
    distinct?: Enumerable<HouseScalarFieldEnum>
  }


  /**
   * House findMany
   */
  export type HouseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the House
     */
    select?: HouseSelect<ExtArgs> | null
    /**
     * Filter, which Houses to fetch.
     */
    where?: HouseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Houses to fetch.
     */
    orderBy?: Enumerable<HouseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Houses.
     */
    cursor?: HouseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Houses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Houses.
     */
    skip?: number
    distinct?: Enumerable<HouseScalarFieldEnum>
  }


  /**
   * House create
   */
  export type HouseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the House
     */
    select?: HouseSelect<ExtArgs> | null
    /**
     * The data needed to create a House.
     */
    data: XOR<HouseCreateInput, HouseUncheckedCreateInput>
  }


  /**
   * House createMany
   */
  export type HouseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Houses.
     */
    data: Enumerable<HouseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * House update
   */
  export type HouseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the House
     */
    select?: HouseSelect<ExtArgs> | null
    /**
     * The data needed to update a House.
     */
    data: XOR<HouseUpdateInput, HouseUncheckedUpdateInput>
    /**
     * Choose, which House to update.
     */
    where: HouseWhereUniqueInput
  }


  /**
   * House updateMany
   */
  export type HouseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Houses.
     */
    data: XOR<HouseUpdateManyMutationInput, HouseUncheckedUpdateManyInput>
    /**
     * Filter which Houses to update
     */
    where?: HouseWhereInput
  }


  /**
   * House upsert
   */
  export type HouseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the House
     */
    select?: HouseSelect<ExtArgs> | null
    /**
     * The filter to search for the House to update in case it exists.
     */
    where: HouseWhereUniqueInput
    /**
     * In case the House found by the `where` argument doesn't exist, create a new House with this data.
     */
    create: XOR<HouseCreateInput, HouseUncheckedCreateInput>
    /**
     * In case the House was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HouseUpdateInput, HouseUncheckedUpdateInput>
  }


  /**
   * House delete
   */
  export type HouseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the House
     */
    select?: HouseSelect<ExtArgs> | null
    /**
     * Filter which House to delete.
     */
    where: HouseWhereUniqueInput
  }


  /**
   * House deleteMany
   */
  export type HouseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Houses to delete
     */
    where?: HouseWhereInput
  }


  /**
   * House without action
   */
  export type HouseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the House
     */
    select?: HouseSelect<ExtArgs> | null
  }



  /**
   * Model account_ban_history
   */


  export type AggregateAccount_ban_history = {
    _count: Account_ban_historyCountAggregateOutputType | null
    _avg: Account_ban_historyAvgAggregateOutputType | null
    _sum: Account_ban_historySumAggregateOutputType | null
    _min: Account_ban_historyMinAggregateOutputType | null
    _max: Account_ban_historyMaxAggregateOutputType | null
  }

  export type Account_ban_historyAvgAggregateOutputType = {
    id: number | null
    account_id: number | null
    banned_at: number | null
    expired_at: number | null
    banned_by: number | null
  }

  export type Account_ban_historySumAggregateOutputType = {
    id: number | null
    account_id: number | null
    banned_at: bigint | null
    expired_at: bigint | null
    banned_by: number | null
  }

  export type Account_ban_historyMinAggregateOutputType = {
    id: number | null
    account_id: number | null
    reason: string | null
    banned_at: bigint | null
    expired_at: bigint | null
    banned_by: number | null
  }

  export type Account_ban_historyMaxAggregateOutputType = {
    id: number | null
    account_id: number | null
    reason: string | null
    banned_at: bigint | null
    expired_at: bigint | null
    banned_by: number | null
  }

  export type Account_ban_historyCountAggregateOutputType = {
    id: number
    account_id: number
    reason: number
    banned_at: number
    expired_at: number
    banned_by: number
    _all: number
  }


  export type Account_ban_historyAvgAggregateInputType = {
    id?: true
    account_id?: true
    banned_at?: true
    expired_at?: true
    banned_by?: true
  }

  export type Account_ban_historySumAggregateInputType = {
    id?: true
    account_id?: true
    banned_at?: true
    expired_at?: true
    banned_by?: true
  }

  export type Account_ban_historyMinAggregateInputType = {
    id?: true
    account_id?: true
    reason?: true
    banned_at?: true
    expired_at?: true
    banned_by?: true
  }

  export type Account_ban_historyMaxAggregateInputType = {
    id?: true
    account_id?: true
    reason?: true
    banned_at?: true
    expired_at?: true
    banned_by?: true
  }

  export type Account_ban_historyCountAggregateInputType = {
    id?: true
    account_id?: true
    reason?: true
    banned_at?: true
    expired_at?: true
    banned_by?: true
    _all?: true
  }

  export type Account_ban_historyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which account_ban_history to aggregate.
     */
    where?: account_ban_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_ban_histories to fetch.
     */
    orderBy?: Enumerable<account_ban_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: account_ban_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_ban_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_ban_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned account_ban_histories
    **/
    _count?: true | Account_ban_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Account_ban_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Account_ban_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Account_ban_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Account_ban_historyMaxAggregateInputType
  }

  export type GetAccount_ban_historyAggregateType<T extends Account_ban_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount_ban_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount_ban_history[P]>
      : GetScalarType<T[P], AggregateAccount_ban_history[P]>
  }




  export type Account_ban_historyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: account_ban_historyWhereInput
    orderBy?: Enumerable<account_ban_historyOrderByWithAggregationInput>
    by: Account_ban_historyScalarFieldEnum[]
    having?: account_ban_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Account_ban_historyCountAggregateInputType | true
    _avg?: Account_ban_historyAvgAggregateInputType
    _sum?: Account_ban_historySumAggregateInputType
    _min?: Account_ban_historyMinAggregateInputType
    _max?: Account_ban_historyMaxAggregateInputType
  }


  export type Account_ban_historyGroupByOutputType = {
    id: number
    account_id: number
    reason: string
    banned_at: bigint
    expired_at: bigint
    banned_by: number
    _count: Account_ban_historyCountAggregateOutputType | null
    _avg: Account_ban_historyAvgAggregateOutputType | null
    _sum: Account_ban_historySumAggregateOutputType | null
    _min: Account_ban_historyMinAggregateOutputType | null
    _max: Account_ban_historyMaxAggregateOutputType | null
  }

  type GetAccount_ban_historyGroupByPayload<T extends Account_ban_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Account_ban_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Account_ban_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Account_ban_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Account_ban_historyGroupByOutputType[P]>
        }
      >
    >


  export type account_ban_historySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    reason?: boolean
    banned_at?: boolean
    expired_at?: boolean
    banned_by?: boolean
    accounts?: boolean | AccountArgs<ExtArgs>
    players?: boolean | PlayerArgs<ExtArgs>
  }, ExtArgs["result"]["account_ban_history"]>

  export type account_ban_historySelectScalar = {
    id?: boolean
    account_id?: boolean
    reason?: boolean
    banned_at?: boolean
    expired_at?: boolean
    banned_by?: boolean
  }

  export type account_ban_historyInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    accounts?: boolean | AccountArgs<ExtArgs>
    players?: boolean | PlayerArgs<ExtArgs>
  }


  type account_ban_historyGetPayload<S extends boolean | null | undefined | account_ban_historyArgs> = $Types.GetResult<account_ban_historyPayload, S>

  type account_ban_historyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<account_ban_historyFindManyArgs, 'select' | 'include'> & {
      select?: Account_ban_historyCountAggregateInputType | true
    }

  export interface account_ban_historyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['account_ban_history'], meta: { name: 'account_ban_history' } }
    /**
     * Find zero or one Account_ban_history that matches the filter.
     * @param {account_ban_historyFindUniqueArgs} args - Arguments to find a Account_ban_history
     * @example
     * // Get one Account_ban_history
     * const account_ban_history = await prisma.account_ban_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends account_ban_historyFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, account_ban_historyFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'account_ban_history'> extends True ? Prisma__account_ban_historyClient<$Types.GetResult<account_ban_historyPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__account_ban_historyClient<$Types.GetResult<account_ban_historyPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Account_ban_history that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {account_ban_historyFindUniqueOrThrowArgs} args - Arguments to find a Account_ban_history
     * @example
     * // Get one Account_ban_history
     * const account_ban_history = await prisma.account_ban_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends account_ban_historyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, account_ban_historyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__account_ban_historyClient<$Types.GetResult<account_ban_historyPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Account_ban_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_ban_historyFindFirstArgs} args - Arguments to find a Account_ban_history
     * @example
     * // Get one Account_ban_history
     * const account_ban_history = await prisma.account_ban_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends account_ban_historyFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, account_ban_historyFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'account_ban_history'> extends True ? Prisma__account_ban_historyClient<$Types.GetResult<account_ban_historyPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__account_ban_historyClient<$Types.GetResult<account_ban_historyPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Account_ban_history that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_ban_historyFindFirstOrThrowArgs} args - Arguments to find a Account_ban_history
     * @example
     * // Get one Account_ban_history
     * const account_ban_history = await prisma.account_ban_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends account_ban_historyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, account_ban_historyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__account_ban_historyClient<$Types.GetResult<account_ban_historyPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Account_ban_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_ban_historyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Account_ban_histories
     * const account_ban_histories = await prisma.account_ban_history.findMany()
     * 
     * // Get first 10 Account_ban_histories
     * const account_ban_histories = await prisma.account_ban_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const account_ban_historyWithIdOnly = await prisma.account_ban_history.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends account_ban_historyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, account_ban_historyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<account_ban_historyPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Account_ban_history.
     * @param {account_ban_historyCreateArgs} args - Arguments to create a Account_ban_history.
     * @example
     * // Create one Account_ban_history
     * const Account_ban_history = await prisma.account_ban_history.create({
     *   data: {
     *     // ... data to create a Account_ban_history
     *   }
     * })
     * 
    **/
    create<T extends account_ban_historyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, account_ban_historyCreateArgs<ExtArgs>>
    ): Prisma__account_ban_historyClient<$Types.GetResult<account_ban_historyPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Account_ban_histories.
     *     @param {account_ban_historyCreateManyArgs} args - Arguments to create many Account_ban_histories.
     *     @example
     *     // Create many Account_ban_histories
     *     const account_ban_history = await prisma.account_ban_history.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends account_ban_historyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, account_ban_historyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account_ban_history.
     * @param {account_ban_historyDeleteArgs} args - Arguments to delete one Account_ban_history.
     * @example
     * // Delete one Account_ban_history
     * const Account_ban_history = await prisma.account_ban_history.delete({
     *   where: {
     *     // ... filter to delete one Account_ban_history
     *   }
     * })
     * 
    **/
    delete<T extends account_ban_historyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, account_ban_historyDeleteArgs<ExtArgs>>
    ): Prisma__account_ban_historyClient<$Types.GetResult<account_ban_historyPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Account_ban_history.
     * @param {account_ban_historyUpdateArgs} args - Arguments to update one Account_ban_history.
     * @example
     * // Update one Account_ban_history
     * const account_ban_history = await prisma.account_ban_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends account_ban_historyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, account_ban_historyUpdateArgs<ExtArgs>>
    ): Prisma__account_ban_historyClient<$Types.GetResult<account_ban_historyPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Account_ban_histories.
     * @param {account_ban_historyDeleteManyArgs} args - Arguments to filter Account_ban_histories to delete.
     * @example
     * // Delete a few Account_ban_histories
     * const { count } = await prisma.account_ban_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends account_ban_historyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, account_ban_historyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Account_ban_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_ban_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Account_ban_histories
     * const account_ban_history = await prisma.account_ban_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends account_ban_historyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, account_ban_historyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account_ban_history.
     * @param {account_ban_historyUpsertArgs} args - Arguments to update or create a Account_ban_history.
     * @example
     * // Update or create a Account_ban_history
     * const account_ban_history = await prisma.account_ban_history.upsert({
     *   create: {
     *     // ... data to create a Account_ban_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account_ban_history we want to update
     *   }
     * })
    **/
    upsert<T extends account_ban_historyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, account_ban_historyUpsertArgs<ExtArgs>>
    ): Prisma__account_ban_historyClient<$Types.GetResult<account_ban_historyPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Account_ban_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_ban_historyCountArgs} args - Arguments to filter Account_ban_histories to count.
     * @example
     * // Count the number of Account_ban_histories
     * const count = await prisma.account_ban_history.count({
     *   where: {
     *     // ... the filter for the Account_ban_histories we want to count
     *   }
     * })
    **/
    count<T extends account_ban_historyCountArgs>(
      args?: Subset<T, account_ban_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Account_ban_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account_ban_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Account_ban_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Account_ban_historyAggregateArgs>(args: Subset<T, Account_ban_historyAggregateArgs>): Prisma.PrismaPromise<GetAccount_ban_historyAggregateType<T>>

    /**
     * Group by Account_ban_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Account_ban_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Account_ban_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Account_ban_historyGroupByArgs['orderBy'] }
        : { orderBy?: Account_ban_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Account_ban_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccount_ban_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for account_ban_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__account_ban_historyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    accounts<T extends AccountArgs<ExtArgs> = {}>(args?: Subset<T, AccountArgs<ExtArgs>>): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    players<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * account_ban_history base type for findUnique actions
   */
  export type account_ban_historyFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_ban_history
     */
    select?: account_ban_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_ban_historyInclude<ExtArgs> | null
    /**
     * Filter, which account_ban_history to fetch.
     */
    where: account_ban_historyWhereUniqueInput
  }

  /**
   * account_ban_history findUnique
   */
  export interface account_ban_historyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends account_ban_historyFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * account_ban_history findUniqueOrThrow
   */
  export type account_ban_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_ban_history
     */
    select?: account_ban_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_ban_historyInclude<ExtArgs> | null
    /**
     * Filter, which account_ban_history to fetch.
     */
    where: account_ban_historyWhereUniqueInput
  }


  /**
   * account_ban_history base type for findFirst actions
   */
  export type account_ban_historyFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_ban_history
     */
    select?: account_ban_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_ban_historyInclude<ExtArgs> | null
    /**
     * Filter, which account_ban_history to fetch.
     */
    where?: account_ban_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_ban_histories to fetch.
     */
    orderBy?: Enumerable<account_ban_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for account_ban_histories.
     */
    cursor?: account_ban_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_ban_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_ban_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of account_ban_histories.
     */
    distinct?: Enumerable<Account_ban_historyScalarFieldEnum>
  }

  /**
   * account_ban_history findFirst
   */
  export interface account_ban_historyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends account_ban_historyFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * account_ban_history findFirstOrThrow
   */
  export type account_ban_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_ban_history
     */
    select?: account_ban_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_ban_historyInclude<ExtArgs> | null
    /**
     * Filter, which account_ban_history to fetch.
     */
    where?: account_ban_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_ban_histories to fetch.
     */
    orderBy?: Enumerable<account_ban_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for account_ban_histories.
     */
    cursor?: account_ban_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_ban_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_ban_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of account_ban_histories.
     */
    distinct?: Enumerable<Account_ban_historyScalarFieldEnum>
  }


  /**
   * account_ban_history findMany
   */
  export type account_ban_historyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_ban_history
     */
    select?: account_ban_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_ban_historyInclude<ExtArgs> | null
    /**
     * Filter, which account_ban_histories to fetch.
     */
    where?: account_ban_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_ban_histories to fetch.
     */
    orderBy?: Enumerable<account_ban_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing account_ban_histories.
     */
    cursor?: account_ban_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_ban_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_ban_histories.
     */
    skip?: number
    distinct?: Enumerable<Account_ban_historyScalarFieldEnum>
  }


  /**
   * account_ban_history create
   */
  export type account_ban_historyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_ban_history
     */
    select?: account_ban_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_ban_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a account_ban_history.
     */
    data: XOR<account_ban_historyCreateInput, account_ban_historyUncheckedCreateInput>
  }


  /**
   * account_ban_history createMany
   */
  export type account_ban_historyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many account_ban_histories.
     */
    data: Enumerable<account_ban_historyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * account_ban_history update
   */
  export type account_ban_historyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_ban_history
     */
    select?: account_ban_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_ban_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a account_ban_history.
     */
    data: XOR<account_ban_historyUpdateInput, account_ban_historyUncheckedUpdateInput>
    /**
     * Choose, which account_ban_history to update.
     */
    where: account_ban_historyWhereUniqueInput
  }


  /**
   * account_ban_history updateMany
   */
  export type account_ban_historyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update account_ban_histories.
     */
    data: XOR<account_ban_historyUpdateManyMutationInput, account_ban_historyUncheckedUpdateManyInput>
    /**
     * Filter which account_ban_histories to update
     */
    where?: account_ban_historyWhereInput
  }


  /**
   * account_ban_history upsert
   */
  export type account_ban_historyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_ban_history
     */
    select?: account_ban_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_ban_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the account_ban_history to update in case it exists.
     */
    where: account_ban_historyWhereUniqueInput
    /**
     * In case the account_ban_history found by the `where` argument doesn't exist, create a new account_ban_history with this data.
     */
    create: XOR<account_ban_historyCreateInput, account_ban_historyUncheckedCreateInput>
    /**
     * In case the account_ban_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<account_ban_historyUpdateInput, account_ban_historyUncheckedUpdateInput>
  }


  /**
   * account_ban_history delete
   */
  export type account_ban_historyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_ban_history
     */
    select?: account_ban_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_ban_historyInclude<ExtArgs> | null
    /**
     * Filter which account_ban_history to delete.
     */
    where: account_ban_historyWhereUniqueInput
  }


  /**
   * account_ban_history deleteMany
   */
  export type account_ban_historyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which account_ban_histories to delete
     */
    where?: account_ban_historyWhereInput
  }


  /**
   * account_ban_history without action
   */
  export type account_ban_historyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_ban_history
     */
    select?: account_ban_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_ban_historyInclude<ExtArgs> | null
  }



  /**
   * Model account_bans
   */


  export type AggregateAccount_bans = {
    _count: Account_bansCountAggregateOutputType | null
    _avg: Account_bansAvgAggregateOutputType | null
    _sum: Account_bansSumAggregateOutputType | null
    _min: Account_bansMinAggregateOutputType | null
    _max: Account_bansMaxAggregateOutputType | null
  }

  export type Account_bansAvgAggregateOutputType = {
    account_id: number | null
    banned_at: number | null
    expires_at: number | null
    banned_by: number | null
  }

  export type Account_bansSumAggregateOutputType = {
    account_id: number | null
    banned_at: bigint | null
    expires_at: bigint | null
    banned_by: number | null
  }

  export type Account_bansMinAggregateOutputType = {
    account_id: number | null
    reason: string | null
    banned_at: bigint | null
    expires_at: bigint | null
    banned_by: number | null
  }

  export type Account_bansMaxAggregateOutputType = {
    account_id: number | null
    reason: string | null
    banned_at: bigint | null
    expires_at: bigint | null
    banned_by: number | null
  }

  export type Account_bansCountAggregateOutputType = {
    account_id: number
    reason: number
    banned_at: number
    expires_at: number
    banned_by: number
    _all: number
  }


  export type Account_bansAvgAggregateInputType = {
    account_id?: true
    banned_at?: true
    expires_at?: true
    banned_by?: true
  }

  export type Account_bansSumAggregateInputType = {
    account_id?: true
    banned_at?: true
    expires_at?: true
    banned_by?: true
  }

  export type Account_bansMinAggregateInputType = {
    account_id?: true
    reason?: true
    banned_at?: true
    expires_at?: true
    banned_by?: true
  }

  export type Account_bansMaxAggregateInputType = {
    account_id?: true
    reason?: true
    banned_at?: true
    expires_at?: true
    banned_by?: true
  }

  export type Account_bansCountAggregateInputType = {
    account_id?: true
    reason?: true
    banned_at?: true
    expires_at?: true
    banned_by?: true
    _all?: true
  }

  export type Account_bansAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which account_bans to aggregate.
     */
    where?: account_bansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_bans to fetch.
     */
    orderBy?: Enumerable<account_bansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: account_bansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_bans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned account_bans
    **/
    _count?: true | Account_bansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Account_bansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Account_bansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Account_bansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Account_bansMaxAggregateInputType
  }

  export type GetAccount_bansAggregateType<T extends Account_bansAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount_bans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount_bans[P]>
      : GetScalarType<T[P], AggregateAccount_bans[P]>
  }




  export type Account_bansGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: account_bansWhereInput
    orderBy?: Enumerable<account_bansOrderByWithAggregationInput>
    by: Account_bansScalarFieldEnum[]
    having?: account_bansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Account_bansCountAggregateInputType | true
    _avg?: Account_bansAvgAggregateInputType
    _sum?: Account_bansSumAggregateInputType
    _min?: Account_bansMinAggregateInputType
    _max?: Account_bansMaxAggregateInputType
  }


  export type Account_bansGroupByOutputType = {
    account_id: number
    reason: string
    banned_at: bigint
    expires_at: bigint
    banned_by: number
    _count: Account_bansCountAggregateOutputType | null
    _avg: Account_bansAvgAggregateOutputType | null
    _sum: Account_bansSumAggregateOutputType | null
    _min: Account_bansMinAggregateOutputType | null
    _max: Account_bansMaxAggregateOutputType | null
  }

  type GetAccount_bansGroupByPayload<T extends Account_bansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Account_bansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Account_bansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Account_bansGroupByOutputType[P]>
            : GetScalarType<T[P], Account_bansGroupByOutputType[P]>
        }
      >
    >


  export type account_bansSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    account_id?: boolean
    reason?: boolean
    banned_at?: boolean
    expires_at?: boolean
    banned_by?: boolean
    accounts?: boolean | AccountArgs<ExtArgs>
    players?: boolean | PlayerArgs<ExtArgs>
  }, ExtArgs["result"]["account_bans"]>

  export type account_bansSelectScalar = {
    account_id?: boolean
    reason?: boolean
    banned_at?: boolean
    expires_at?: boolean
    banned_by?: boolean
  }

  export type account_bansInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    accounts?: boolean | AccountArgs<ExtArgs>
    players?: boolean | PlayerArgs<ExtArgs>
  }


  type account_bansGetPayload<S extends boolean | null | undefined | account_bansArgs> = $Types.GetResult<account_bansPayload, S>

  type account_bansCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<account_bansFindManyArgs, 'select' | 'include'> & {
      select?: Account_bansCountAggregateInputType | true
    }

  export interface account_bansDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['account_bans'], meta: { name: 'account_bans' } }
    /**
     * Find zero or one Account_bans that matches the filter.
     * @param {account_bansFindUniqueArgs} args - Arguments to find a Account_bans
     * @example
     * // Get one Account_bans
     * const account_bans = await prisma.account_bans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends account_bansFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, account_bansFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'account_bans'> extends True ? Prisma__account_bansClient<$Types.GetResult<account_bansPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__account_bansClient<$Types.GetResult<account_bansPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Account_bans that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {account_bansFindUniqueOrThrowArgs} args - Arguments to find a Account_bans
     * @example
     * // Get one Account_bans
     * const account_bans = await prisma.account_bans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends account_bansFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, account_bansFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__account_bansClient<$Types.GetResult<account_bansPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Account_bans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_bansFindFirstArgs} args - Arguments to find a Account_bans
     * @example
     * // Get one Account_bans
     * const account_bans = await prisma.account_bans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends account_bansFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, account_bansFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'account_bans'> extends True ? Prisma__account_bansClient<$Types.GetResult<account_bansPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__account_bansClient<$Types.GetResult<account_bansPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Account_bans that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_bansFindFirstOrThrowArgs} args - Arguments to find a Account_bans
     * @example
     * // Get one Account_bans
     * const account_bans = await prisma.account_bans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends account_bansFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, account_bansFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__account_bansClient<$Types.GetResult<account_bansPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Account_bans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_bansFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Account_bans
     * const account_bans = await prisma.account_bans.findMany()
     * 
     * // Get first 10 Account_bans
     * const account_bans = await prisma.account_bans.findMany({ take: 10 })
     * 
     * // Only select the `account_id`
     * const account_bansWithAccount_idOnly = await prisma.account_bans.findMany({ select: { account_id: true } })
     * 
    **/
    findMany<T extends account_bansFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, account_bansFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<account_bansPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Account_bans.
     * @param {account_bansCreateArgs} args - Arguments to create a Account_bans.
     * @example
     * // Create one Account_bans
     * const Account_bans = await prisma.account_bans.create({
     *   data: {
     *     // ... data to create a Account_bans
     *   }
     * })
     * 
    **/
    create<T extends account_bansCreateArgs<ExtArgs>>(
      args: SelectSubset<T, account_bansCreateArgs<ExtArgs>>
    ): Prisma__account_bansClient<$Types.GetResult<account_bansPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Account_bans.
     *     @param {account_bansCreateManyArgs} args - Arguments to create many Account_bans.
     *     @example
     *     // Create many Account_bans
     *     const account_bans = await prisma.account_bans.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends account_bansCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, account_bansCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account_bans.
     * @param {account_bansDeleteArgs} args - Arguments to delete one Account_bans.
     * @example
     * // Delete one Account_bans
     * const Account_bans = await prisma.account_bans.delete({
     *   where: {
     *     // ... filter to delete one Account_bans
     *   }
     * })
     * 
    **/
    delete<T extends account_bansDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, account_bansDeleteArgs<ExtArgs>>
    ): Prisma__account_bansClient<$Types.GetResult<account_bansPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Account_bans.
     * @param {account_bansUpdateArgs} args - Arguments to update one Account_bans.
     * @example
     * // Update one Account_bans
     * const account_bans = await prisma.account_bans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends account_bansUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, account_bansUpdateArgs<ExtArgs>>
    ): Prisma__account_bansClient<$Types.GetResult<account_bansPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Account_bans.
     * @param {account_bansDeleteManyArgs} args - Arguments to filter Account_bans to delete.
     * @example
     * // Delete a few Account_bans
     * const { count } = await prisma.account_bans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends account_bansDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, account_bansDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Account_bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_bansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Account_bans
     * const account_bans = await prisma.account_bans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends account_bansUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, account_bansUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account_bans.
     * @param {account_bansUpsertArgs} args - Arguments to update or create a Account_bans.
     * @example
     * // Update or create a Account_bans
     * const account_bans = await prisma.account_bans.upsert({
     *   create: {
     *     // ... data to create a Account_bans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account_bans we want to update
     *   }
     * })
    **/
    upsert<T extends account_bansUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, account_bansUpsertArgs<ExtArgs>>
    ): Prisma__account_bansClient<$Types.GetResult<account_bansPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Account_bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_bansCountArgs} args - Arguments to filter Account_bans to count.
     * @example
     * // Count the number of Account_bans
     * const count = await prisma.account_bans.count({
     *   where: {
     *     // ... the filter for the Account_bans we want to count
     *   }
     * })
    **/
    count<T extends account_bansCountArgs>(
      args?: Subset<T, account_bansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Account_bansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account_bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Account_bansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Account_bansAggregateArgs>(args: Subset<T, Account_bansAggregateArgs>): Prisma.PrismaPromise<GetAccount_bansAggregateType<T>>

    /**
     * Group by Account_bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Account_bansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Account_bansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Account_bansGroupByArgs['orderBy'] }
        : { orderBy?: Account_bansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Account_bansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccount_bansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for account_bans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__account_bansClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    accounts<T extends AccountArgs<ExtArgs> = {}>(args?: Subset<T, AccountArgs<ExtArgs>>): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    players<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * account_bans base type for findUnique actions
   */
  export type account_bansFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_bans
     */
    select?: account_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_bansInclude<ExtArgs> | null
    /**
     * Filter, which account_bans to fetch.
     */
    where: account_bansWhereUniqueInput
  }

  /**
   * account_bans findUnique
   */
  export interface account_bansFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends account_bansFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * account_bans findUniqueOrThrow
   */
  export type account_bansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_bans
     */
    select?: account_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_bansInclude<ExtArgs> | null
    /**
     * Filter, which account_bans to fetch.
     */
    where: account_bansWhereUniqueInput
  }


  /**
   * account_bans base type for findFirst actions
   */
  export type account_bansFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_bans
     */
    select?: account_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_bansInclude<ExtArgs> | null
    /**
     * Filter, which account_bans to fetch.
     */
    where?: account_bansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_bans to fetch.
     */
    orderBy?: Enumerable<account_bansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for account_bans.
     */
    cursor?: account_bansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_bans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of account_bans.
     */
    distinct?: Enumerable<Account_bansScalarFieldEnum>
  }

  /**
   * account_bans findFirst
   */
  export interface account_bansFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends account_bansFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * account_bans findFirstOrThrow
   */
  export type account_bansFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_bans
     */
    select?: account_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_bansInclude<ExtArgs> | null
    /**
     * Filter, which account_bans to fetch.
     */
    where?: account_bansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_bans to fetch.
     */
    orderBy?: Enumerable<account_bansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for account_bans.
     */
    cursor?: account_bansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_bans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of account_bans.
     */
    distinct?: Enumerable<Account_bansScalarFieldEnum>
  }


  /**
   * account_bans findMany
   */
  export type account_bansFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_bans
     */
    select?: account_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_bansInclude<ExtArgs> | null
    /**
     * Filter, which account_bans to fetch.
     */
    where?: account_bansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_bans to fetch.
     */
    orderBy?: Enumerable<account_bansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing account_bans.
     */
    cursor?: account_bansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_bans.
     */
    skip?: number
    distinct?: Enumerable<Account_bansScalarFieldEnum>
  }


  /**
   * account_bans create
   */
  export type account_bansCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_bans
     */
    select?: account_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_bansInclude<ExtArgs> | null
    /**
     * The data needed to create a account_bans.
     */
    data: XOR<account_bansCreateInput, account_bansUncheckedCreateInput>
  }


  /**
   * account_bans createMany
   */
  export type account_bansCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many account_bans.
     */
    data: Enumerable<account_bansCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * account_bans update
   */
  export type account_bansUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_bans
     */
    select?: account_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_bansInclude<ExtArgs> | null
    /**
     * The data needed to update a account_bans.
     */
    data: XOR<account_bansUpdateInput, account_bansUncheckedUpdateInput>
    /**
     * Choose, which account_bans to update.
     */
    where: account_bansWhereUniqueInput
  }


  /**
   * account_bans updateMany
   */
  export type account_bansUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update account_bans.
     */
    data: XOR<account_bansUpdateManyMutationInput, account_bansUncheckedUpdateManyInput>
    /**
     * Filter which account_bans to update
     */
    where?: account_bansWhereInput
  }


  /**
   * account_bans upsert
   */
  export type account_bansUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_bans
     */
    select?: account_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_bansInclude<ExtArgs> | null
    /**
     * The filter to search for the account_bans to update in case it exists.
     */
    where: account_bansWhereUniqueInput
    /**
     * In case the account_bans found by the `where` argument doesn't exist, create a new account_bans with this data.
     */
    create: XOR<account_bansCreateInput, account_bansUncheckedCreateInput>
    /**
     * In case the account_bans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<account_bansUpdateInput, account_bansUncheckedUpdateInput>
  }


  /**
   * account_bans delete
   */
  export type account_bansDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_bans
     */
    select?: account_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_bansInclude<ExtArgs> | null
    /**
     * Filter which account_bans to delete.
     */
    where: account_bansWhereUniqueInput
  }


  /**
   * account_bans deleteMany
   */
  export type account_bansDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which account_bans to delete
     */
    where?: account_bansWhereInput
  }


  /**
   * account_bans without action
   */
  export type account_bansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_bans
     */
    select?: account_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_bansInclude<ExtArgs> | null
  }



  /**
   * Model account_storage
   */


  export type AggregateAccount_storage = {
    _count: Account_storageCountAggregateOutputType | null
    _avg: Account_storageAvgAggregateOutputType | null
    _sum: Account_storageSumAggregateOutputType | null
    _min: Account_storageMinAggregateOutputType | null
    _max: Account_storageMaxAggregateOutputType | null
  }

  export type Account_storageAvgAggregateOutputType = {
    account_id: number | null
    key: number | null
    value: number | null
  }

  export type Account_storageSumAggregateOutputType = {
    account_id: number | null
    key: number | null
    value: number | null
  }

  export type Account_storageMinAggregateOutputType = {
    account_id: number | null
    key: number | null
    value: number | null
  }

  export type Account_storageMaxAggregateOutputType = {
    account_id: number | null
    key: number | null
    value: number | null
  }

  export type Account_storageCountAggregateOutputType = {
    account_id: number
    key: number
    value: number
    _all: number
  }


  export type Account_storageAvgAggregateInputType = {
    account_id?: true
    key?: true
    value?: true
  }

  export type Account_storageSumAggregateInputType = {
    account_id?: true
    key?: true
    value?: true
  }

  export type Account_storageMinAggregateInputType = {
    account_id?: true
    key?: true
    value?: true
  }

  export type Account_storageMaxAggregateInputType = {
    account_id?: true
    key?: true
    value?: true
  }

  export type Account_storageCountAggregateInputType = {
    account_id?: true
    key?: true
    value?: true
    _all?: true
  }

  export type Account_storageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which account_storage to aggregate.
     */
    where?: account_storageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_storages to fetch.
     */
    orderBy?: Enumerable<account_storageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: account_storageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned account_storages
    **/
    _count?: true | Account_storageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Account_storageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Account_storageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Account_storageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Account_storageMaxAggregateInputType
  }

  export type GetAccount_storageAggregateType<T extends Account_storageAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount_storage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount_storage[P]>
      : GetScalarType<T[P], AggregateAccount_storage[P]>
  }




  export type Account_storageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: account_storageWhereInput
    orderBy?: Enumerable<account_storageOrderByWithAggregationInput>
    by: Account_storageScalarFieldEnum[]
    having?: account_storageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Account_storageCountAggregateInputType | true
    _avg?: Account_storageAvgAggregateInputType
    _sum?: Account_storageSumAggregateInputType
    _min?: Account_storageMinAggregateInputType
    _max?: Account_storageMaxAggregateInputType
  }


  export type Account_storageGroupByOutputType = {
    account_id: number
    key: number
    value: number
    _count: Account_storageCountAggregateOutputType | null
    _avg: Account_storageAvgAggregateOutputType | null
    _sum: Account_storageSumAggregateOutputType | null
    _min: Account_storageMinAggregateOutputType | null
    _max: Account_storageMaxAggregateOutputType | null
  }

  type GetAccount_storageGroupByPayload<T extends Account_storageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Account_storageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Account_storageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Account_storageGroupByOutputType[P]>
            : GetScalarType<T[P], Account_storageGroupByOutputType[P]>
        }
      >
    >


  export type account_storageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    account_id?: boolean
    key?: boolean
    value?: boolean
    accounts?: boolean | AccountArgs<ExtArgs>
  }, ExtArgs["result"]["account_storage"]>

  export type account_storageSelectScalar = {
    account_id?: boolean
    key?: boolean
    value?: boolean
  }

  export type account_storageInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    accounts?: boolean | AccountArgs<ExtArgs>
  }


  type account_storageGetPayload<S extends boolean | null | undefined | account_storageArgs> = $Types.GetResult<account_storagePayload, S>

  type account_storageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<account_storageFindManyArgs, 'select' | 'include'> & {
      select?: Account_storageCountAggregateInputType | true
    }

  export interface account_storageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['account_storage'], meta: { name: 'account_storage' } }
    /**
     * Find zero or one Account_storage that matches the filter.
     * @param {account_storageFindUniqueArgs} args - Arguments to find a Account_storage
     * @example
     * // Get one Account_storage
     * const account_storage = await prisma.account_storage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends account_storageFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, account_storageFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'account_storage'> extends True ? Prisma__account_storageClient<$Types.GetResult<account_storagePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__account_storageClient<$Types.GetResult<account_storagePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Account_storage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {account_storageFindUniqueOrThrowArgs} args - Arguments to find a Account_storage
     * @example
     * // Get one Account_storage
     * const account_storage = await prisma.account_storage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends account_storageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, account_storageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__account_storageClient<$Types.GetResult<account_storagePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Account_storage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_storageFindFirstArgs} args - Arguments to find a Account_storage
     * @example
     * // Get one Account_storage
     * const account_storage = await prisma.account_storage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends account_storageFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, account_storageFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'account_storage'> extends True ? Prisma__account_storageClient<$Types.GetResult<account_storagePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__account_storageClient<$Types.GetResult<account_storagePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Account_storage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_storageFindFirstOrThrowArgs} args - Arguments to find a Account_storage
     * @example
     * // Get one Account_storage
     * const account_storage = await prisma.account_storage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends account_storageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, account_storageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__account_storageClient<$Types.GetResult<account_storagePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Account_storages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_storageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Account_storages
     * const account_storages = await prisma.account_storage.findMany()
     * 
     * // Get first 10 Account_storages
     * const account_storages = await prisma.account_storage.findMany({ take: 10 })
     * 
     * // Only select the `account_id`
     * const account_storageWithAccount_idOnly = await prisma.account_storage.findMany({ select: { account_id: true } })
     * 
    **/
    findMany<T extends account_storageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, account_storageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<account_storagePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Account_storage.
     * @param {account_storageCreateArgs} args - Arguments to create a Account_storage.
     * @example
     * // Create one Account_storage
     * const Account_storage = await prisma.account_storage.create({
     *   data: {
     *     // ... data to create a Account_storage
     *   }
     * })
     * 
    **/
    create<T extends account_storageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, account_storageCreateArgs<ExtArgs>>
    ): Prisma__account_storageClient<$Types.GetResult<account_storagePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Account_storages.
     *     @param {account_storageCreateManyArgs} args - Arguments to create many Account_storages.
     *     @example
     *     // Create many Account_storages
     *     const account_storage = await prisma.account_storage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends account_storageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, account_storageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account_storage.
     * @param {account_storageDeleteArgs} args - Arguments to delete one Account_storage.
     * @example
     * // Delete one Account_storage
     * const Account_storage = await prisma.account_storage.delete({
     *   where: {
     *     // ... filter to delete one Account_storage
     *   }
     * })
     * 
    **/
    delete<T extends account_storageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, account_storageDeleteArgs<ExtArgs>>
    ): Prisma__account_storageClient<$Types.GetResult<account_storagePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Account_storage.
     * @param {account_storageUpdateArgs} args - Arguments to update one Account_storage.
     * @example
     * // Update one Account_storage
     * const account_storage = await prisma.account_storage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends account_storageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, account_storageUpdateArgs<ExtArgs>>
    ): Prisma__account_storageClient<$Types.GetResult<account_storagePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Account_storages.
     * @param {account_storageDeleteManyArgs} args - Arguments to filter Account_storages to delete.
     * @example
     * // Delete a few Account_storages
     * const { count } = await prisma.account_storage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends account_storageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, account_storageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Account_storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_storageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Account_storages
     * const account_storage = await prisma.account_storage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends account_storageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, account_storageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account_storage.
     * @param {account_storageUpsertArgs} args - Arguments to update or create a Account_storage.
     * @example
     * // Update or create a Account_storage
     * const account_storage = await prisma.account_storage.upsert({
     *   create: {
     *     // ... data to create a Account_storage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account_storage we want to update
     *   }
     * })
    **/
    upsert<T extends account_storageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, account_storageUpsertArgs<ExtArgs>>
    ): Prisma__account_storageClient<$Types.GetResult<account_storagePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Account_storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_storageCountArgs} args - Arguments to filter Account_storages to count.
     * @example
     * // Count the number of Account_storages
     * const count = await prisma.account_storage.count({
     *   where: {
     *     // ... the filter for the Account_storages we want to count
     *   }
     * })
    **/
    count<T extends account_storageCountArgs>(
      args?: Subset<T, account_storageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Account_storageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account_storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Account_storageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Account_storageAggregateArgs>(args: Subset<T, Account_storageAggregateArgs>): Prisma.PrismaPromise<GetAccount_storageAggregateType<T>>

    /**
     * Group by Account_storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Account_storageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Account_storageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Account_storageGroupByArgs['orderBy'] }
        : { orderBy?: Account_storageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Account_storageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccount_storageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for account_storage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__account_storageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    accounts<T extends AccountArgs<ExtArgs> = {}>(args?: Subset<T, AccountArgs<ExtArgs>>): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * account_storage base type for findUnique actions
   */
  export type account_storageFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_storage
     */
    select?: account_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_storageInclude<ExtArgs> | null
    /**
     * Filter, which account_storage to fetch.
     */
    where: account_storageWhereUniqueInput
  }

  /**
   * account_storage findUnique
   */
  export interface account_storageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends account_storageFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * account_storage findUniqueOrThrow
   */
  export type account_storageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_storage
     */
    select?: account_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_storageInclude<ExtArgs> | null
    /**
     * Filter, which account_storage to fetch.
     */
    where: account_storageWhereUniqueInput
  }


  /**
   * account_storage base type for findFirst actions
   */
  export type account_storageFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_storage
     */
    select?: account_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_storageInclude<ExtArgs> | null
    /**
     * Filter, which account_storage to fetch.
     */
    where?: account_storageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_storages to fetch.
     */
    orderBy?: Enumerable<account_storageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for account_storages.
     */
    cursor?: account_storageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of account_storages.
     */
    distinct?: Enumerable<Account_storageScalarFieldEnum>
  }

  /**
   * account_storage findFirst
   */
  export interface account_storageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends account_storageFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * account_storage findFirstOrThrow
   */
  export type account_storageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_storage
     */
    select?: account_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_storageInclude<ExtArgs> | null
    /**
     * Filter, which account_storage to fetch.
     */
    where?: account_storageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_storages to fetch.
     */
    orderBy?: Enumerable<account_storageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for account_storages.
     */
    cursor?: account_storageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of account_storages.
     */
    distinct?: Enumerable<Account_storageScalarFieldEnum>
  }


  /**
   * account_storage findMany
   */
  export type account_storageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_storage
     */
    select?: account_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_storageInclude<ExtArgs> | null
    /**
     * Filter, which account_storages to fetch.
     */
    where?: account_storageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_storages to fetch.
     */
    orderBy?: Enumerable<account_storageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing account_storages.
     */
    cursor?: account_storageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_storages.
     */
    skip?: number
    distinct?: Enumerable<Account_storageScalarFieldEnum>
  }


  /**
   * account_storage create
   */
  export type account_storageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_storage
     */
    select?: account_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_storageInclude<ExtArgs> | null
    /**
     * The data needed to create a account_storage.
     */
    data: XOR<account_storageCreateInput, account_storageUncheckedCreateInput>
  }


  /**
   * account_storage createMany
   */
  export type account_storageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many account_storages.
     */
    data: Enumerable<account_storageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * account_storage update
   */
  export type account_storageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_storage
     */
    select?: account_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_storageInclude<ExtArgs> | null
    /**
     * The data needed to update a account_storage.
     */
    data: XOR<account_storageUpdateInput, account_storageUncheckedUpdateInput>
    /**
     * Choose, which account_storage to update.
     */
    where: account_storageWhereUniqueInput
  }


  /**
   * account_storage updateMany
   */
  export type account_storageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update account_storages.
     */
    data: XOR<account_storageUpdateManyMutationInput, account_storageUncheckedUpdateManyInput>
    /**
     * Filter which account_storages to update
     */
    where?: account_storageWhereInput
  }


  /**
   * account_storage upsert
   */
  export type account_storageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_storage
     */
    select?: account_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_storageInclude<ExtArgs> | null
    /**
     * The filter to search for the account_storage to update in case it exists.
     */
    where: account_storageWhereUniqueInput
    /**
     * In case the account_storage found by the `where` argument doesn't exist, create a new account_storage with this data.
     */
    create: XOR<account_storageCreateInput, account_storageUncheckedCreateInput>
    /**
     * In case the account_storage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<account_storageUpdateInput, account_storageUncheckedUpdateInput>
  }


  /**
   * account_storage delete
   */
  export type account_storageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_storage
     */
    select?: account_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_storageInclude<ExtArgs> | null
    /**
     * Filter which account_storage to delete.
     */
    where: account_storageWhereUniqueInput
  }


  /**
   * account_storage deleteMany
   */
  export type account_storageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which account_storages to delete
     */
    where?: account_storageWhereInput
  }


  /**
   * account_storage without action
   */
  export type account_storageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_storage
     */
    select?: account_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_storageInclude<ExtArgs> | null
  }



  /**
   * Model account_viplist
   */


  export type AggregateAccount_viplist = {
    _count: Account_viplistCountAggregateOutputType | null
    _avg: Account_viplistAvgAggregateOutputType | null
    _sum: Account_viplistSumAggregateOutputType | null
    _min: Account_viplistMinAggregateOutputType | null
    _max: Account_viplistMaxAggregateOutputType | null
  }

  export type Account_viplistAvgAggregateOutputType = {
    account_id: number | null
    player_id: number | null
    icon: number | null
  }

  export type Account_viplistSumAggregateOutputType = {
    account_id: number | null
    player_id: number | null
    icon: number | null
  }

  export type Account_viplistMinAggregateOutputType = {
    account_id: number | null
    player_id: number | null
    description: string | null
    icon: number | null
    notify: boolean | null
  }

  export type Account_viplistMaxAggregateOutputType = {
    account_id: number | null
    player_id: number | null
    description: string | null
    icon: number | null
    notify: boolean | null
  }

  export type Account_viplistCountAggregateOutputType = {
    account_id: number
    player_id: number
    description: number
    icon: number
    notify: number
    _all: number
  }


  export type Account_viplistAvgAggregateInputType = {
    account_id?: true
    player_id?: true
    icon?: true
  }

  export type Account_viplistSumAggregateInputType = {
    account_id?: true
    player_id?: true
    icon?: true
  }

  export type Account_viplistMinAggregateInputType = {
    account_id?: true
    player_id?: true
    description?: true
    icon?: true
    notify?: true
  }

  export type Account_viplistMaxAggregateInputType = {
    account_id?: true
    player_id?: true
    description?: true
    icon?: true
    notify?: true
  }

  export type Account_viplistCountAggregateInputType = {
    account_id?: true
    player_id?: true
    description?: true
    icon?: true
    notify?: true
    _all?: true
  }

  export type Account_viplistAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which account_viplist to aggregate.
     */
    where?: account_viplistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_viplists to fetch.
     */
    orderBy?: Enumerable<account_viplistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: account_viplistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_viplists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_viplists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned account_viplists
    **/
    _count?: true | Account_viplistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Account_viplistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Account_viplistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Account_viplistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Account_viplistMaxAggregateInputType
  }

  export type GetAccount_viplistAggregateType<T extends Account_viplistAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount_viplist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount_viplist[P]>
      : GetScalarType<T[P], AggregateAccount_viplist[P]>
  }




  export type Account_viplistGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: account_viplistWhereInput
    orderBy?: Enumerable<account_viplistOrderByWithAggregationInput>
    by: Account_viplistScalarFieldEnum[]
    having?: account_viplistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Account_viplistCountAggregateInputType | true
    _avg?: Account_viplistAvgAggregateInputType
    _sum?: Account_viplistSumAggregateInputType
    _min?: Account_viplistMinAggregateInputType
    _max?: Account_viplistMaxAggregateInputType
  }


  export type Account_viplistGroupByOutputType = {
    account_id: number
    player_id: number
    description: string
    icon: number
    notify: boolean
    _count: Account_viplistCountAggregateOutputType | null
    _avg: Account_viplistAvgAggregateOutputType | null
    _sum: Account_viplistSumAggregateOutputType | null
    _min: Account_viplistMinAggregateOutputType | null
    _max: Account_viplistMaxAggregateOutputType | null
  }

  type GetAccount_viplistGroupByPayload<T extends Account_viplistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Account_viplistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Account_viplistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Account_viplistGroupByOutputType[P]>
            : GetScalarType<T[P], Account_viplistGroupByOutputType[P]>
        }
      >
    >


  export type account_viplistSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    account_id?: boolean
    player_id?: boolean
    description?: boolean
    icon?: boolean
    notify?: boolean
    accounts?: boolean | AccountArgs<ExtArgs>
    players?: boolean | PlayerArgs<ExtArgs>
  }, ExtArgs["result"]["account_viplist"]>

  export type account_viplistSelectScalar = {
    account_id?: boolean
    player_id?: boolean
    description?: boolean
    icon?: boolean
    notify?: boolean
  }

  export type account_viplistInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    accounts?: boolean | AccountArgs<ExtArgs>
    players?: boolean | PlayerArgs<ExtArgs>
  }


  type account_viplistGetPayload<S extends boolean | null | undefined | account_viplistArgs> = $Types.GetResult<account_viplistPayload, S>

  type account_viplistCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<account_viplistFindManyArgs, 'select' | 'include'> & {
      select?: Account_viplistCountAggregateInputType | true
    }

  export interface account_viplistDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['account_viplist'], meta: { name: 'account_viplist' } }
    /**
     * Find zero or one Account_viplist that matches the filter.
     * @param {account_viplistFindUniqueArgs} args - Arguments to find a Account_viplist
     * @example
     * // Get one Account_viplist
     * const account_viplist = await prisma.account_viplist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends account_viplistFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, account_viplistFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'account_viplist'> extends True ? Prisma__account_viplistClient<$Types.GetResult<account_viplistPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__account_viplistClient<$Types.GetResult<account_viplistPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Account_viplist that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {account_viplistFindUniqueOrThrowArgs} args - Arguments to find a Account_viplist
     * @example
     * // Get one Account_viplist
     * const account_viplist = await prisma.account_viplist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends account_viplistFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, account_viplistFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__account_viplistClient<$Types.GetResult<account_viplistPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Account_viplist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_viplistFindFirstArgs} args - Arguments to find a Account_viplist
     * @example
     * // Get one Account_viplist
     * const account_viplist = await prisma.account_viplist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends account_viplistFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, account_viplistFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'account_viplist'> extends True ? Prisma__account_viplistClient<$Types.GetResult<account_viplistPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__account_viplistClient<$Types.GetResult<account_viplistPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Account_viplist that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_viplistFindFirstOrThrowArgs} args - Arguments to find a Account_viplist
     * @example
     * // Get one Account_viplist
     * const account_viplist = await prisma.account_viplist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends account_viplistFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, account_viplistFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__account_viplistClient<$Types.GetResult<account_viplistPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Account_viplists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_viplistFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Account_viplists
     * const account_viplists = await prisma.account_viplist.findMany()
     * 
     * // Get first 10 Account_viplists
     * const account_viplists = await prisma.account_viplist.findMany({ take: 10 })
     * 
     * // Only select the `account_id`
     * const account_viplistWithAccount_idOnly = await prisma.account_viplist.findMany({ select: { account_id: true } })
     * 
    **/
    findMany<T extends account_viplistFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, account_viplistFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<account_viplistPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Account_viplist.
     * @param {account_viplistCreateArgs} args - Arguments to create a Account_viplist.
     * @example
     * // Create one Account_viplist
     * const Account_viplist = await prisma.account_viplist.create({
     *   data: {
     *     // ... data to create a Account_viplist
     *   }
     * })
     * 
    **/
    create<T extends account_viplistCreateArgs<ExtArgs>>(
      args: SelectSubset<T, account_viplistCreateArgs<ExtArgs>>
    ): Prisma__account_viplistClient<$Types.GetResult<account_viplistPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Account_viplists.
     *     @param {account_viplistCreateManyArgs} args - Arguments to create many Account_viplists.
     *     @example
     *     // Create many Account_viplists
     *     const account_viplist = await prisma.account_viplist.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends account_viplistCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, account_viplistCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account_viplist.
     * @param {account_viplistDeleteArgs} args - Arguments to delete one Account_viplist.
     * @example
     * // Delete one Account_viplist
     * const Account_viplist = await prisma.account_viplist.delete({
     *   where: {
     *     // ... filter to delete one Account_viplist
     *   }
     * })
     * 
    **/
    delete<T extends account_viplistDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, account_viplistDeleteArgs<ExtArgs>>
    ): Prisma__account_viplistClient<$Types.GetResult<account_viplistPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Account_viplist.
     * @param {account_viplistUpdateArgs} args - Arguments to update one Account_viplist.
     * @example
     * // Update one Account_viplist
     * const account_viplist = await prisma.account_viplist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends account_viplistUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, account_viplistUpdateArgs<ExtArgs>>
    ): Prisma__account_viplistClient<$Types.GetResult<account_viplistPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Account_viplists.
     * @param {account_viplistDeleteManyArgs} args - Arguments to filter Account_viplists to delete.
     * @example
     * // Delete a few Account_viplists
     * const { count } = await prisma.account_viplist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends account_viplistDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, account_viplistDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Account_viplists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_viplistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Account_viplists
     * const account_viplist = await prisma.account_viplist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends account_viplistUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, account_viplistUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account_viplist.
     * @param {account_viplistUpsertArgs} args - Arguments to update or create a Account_viplist.
     * @example
     * // Update or create a Account_viplist
     * const account_viplist = await prisma.account_viplist.upsert({
     *   create: {
     *     // ... data to create a Account_viplist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account_viplist we want to update
     *   }
     * })
    **/
    upsert<T extends account_viplistUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, account_viplistUpsertArgs<ExtArgs>>
    ): Prisma__account_viplistClient<$Types.GetResult<account_viplistPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Account_viplists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {account_viplistCountArgs} args - Arguments to filter Account_viplists to count.
     * @example
     * // Count the number of Account_viplists
     * const count = await prisma.account_viplist.count({
     *   where: {
     *     // ... the filter for the Account_viplists we want to count
     *   }
     * })
    **/
    count<T extends account_viplistCountArgs>(
      args?: Subset<T, account_viplistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Account_viplistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account_viplist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Account_viplistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Account_viplistAggregateArgs>(args: Subset<T, Account_viplistAggregateArgs>): Prisma.PrismaPromise<GetAccount_viplistAggregateType<T>>

    /**
     * Group by Account_viplist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Account_viplistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Account_viplistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Account_viplistGroupByArgs['orderBy'] }
        : { orderBy?: Account_viplistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Account_viplistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccount_viplistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for account_viplist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__account_viplistClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    accounts<T extends AccountArgs<ExtArgs> = {}>(args?: Subset<T, AccountArgs<ExtArgs>>): Prisma__AccountClient<$Types.GetResult<AccountPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    players<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * account_viplist base type for findUnique actions
   */
  export type account_viplistFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_viplist
     */
    select?: account_viplistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_viplistInclude<ExtArgs> | null
    /**
     * Filter, which account_viplist to fetch.
     */
    where: account_viplistWhereUniqueInput
  }

  /**
   * account_viplist findUnique
   */
  export interface account_viplistFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends account_viplistFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * account_viplist findUniqueOrThrow
   */
  export type account_viplistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_viplist
     */
    select?: account_viplistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_viplistInclude<ExtArgs> | null
    /**
     * Filter, which account_viplist to fetch.
     */
    where: account_viplistWhereUniqueInput
  }


  /**
   * account_viplist base type for findFirst actions
   */
  export type account_viplistFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_viplist
     */
    select?: account_viplistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_viplistInclude<ExtArgs> | null
    /**
     * Filter, which account_viplist to fetch.
     */
    where?: account_viplistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_viplists to fetch.
     */
    orderBy?: Enumerable<account_viplistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for account_viplists.
     */
    cursor?: account_viplistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_viplists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_viplists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of account_viplists.
     */
    distinct?: Enumerable<Account_viplistScalarFieldEnum>
  }

  /**
   * account_viplist findFirst
   */
  export interface account_viplistFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends account_viplistFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * account_viplist findFirstOrThrow
   */
  export type account_viplistFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_viplist
     */
    select?: account_viplistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_viplistInclude<ExtArgs> | null
    /**
     * Filter, which account_viplist to fetch.
     */
    where?: account_viplistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_viplists to fetch.
     */
    orderBy?: Enumerable<account_viplistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for account_viplists.
     */
    cursor?: account_viplistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_viplists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_viplists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of account_viplists.
     */
    distinct?: Enumerable<Account_viplistScalarFieldEnum>
  }


  /**
   * account_viplist findMany
   */
  export type account_viplistFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_viplist
     */
    select?: account_viplistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_viplistInclude<ExtArgs> | null
    /**
     * Filter, which account_viplists to fetch.
     */
    where?: account_viplistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of account_viplists to fetch.
     */
    orderBy?: Enumerable<account_viplistOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing account_viplists.
     */
    cursor?: account_viplistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` account_viplists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` account_viplists.
     */
    skip?: number
    distinct?: Enumerable<Account_viplistScalarFieldEnum>
  }


  /**
   * account_viplist create
   */
  export type account_viplistCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_viplist
     */
    select?: account_viplistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_viplistInclude<ExtArgs> | null
    /**
     * The data needed to create a account_viplist.
     */
    data: XOR<account_viplistCreateInput, account_viplistUncheckedCreateInput>
  }


  /**
   * account_viplist createMany
   */
  export type account_viplistCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many account_viplists.
     */
    data: Enumerable<account_viplistCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * account_viplist update
   */
  export type account_viplistUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_viplist
     */
    select?: account_viplistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_viplistInclude<ExtArgs> | null
    /**
     * The data needed to update a account_viplist.
     */
    data: XOR<account_viplistUpdateInput, account_viplistUncheckedUpdateInput>
    /**
     * Choose, which account_viplist to update.
     */
    where: account_viplistWhereUniqueInput
  }


  /**
   * account_viplist updateMany
   */
  export type account_viplistUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update account_viplists.
     */
    data: XOR<account_viplistUpdateManyMutationInput, account_viplistUncheckedUpdateManyInput>
    /**
     * Filter which account_viplists to update
     */
    where?: account_viplistWhereInput
  }


  /**
   * account_viplist upsert
   */
  export type account_viplistUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_viplist
     */
    select?: account_viplistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_viplistInclude<ExtArgs> | null
    /**
     * The filter to search for the account_viplist to update in case it exists.
     */
    where: account_viplistWhereUniqueInput
    /**
     * In case the account_viplist found by the `where` argument doesn't exist, create a new account_viplist with this data.
     */
    create: XOR<account_viplistCreateInput, account_viplistUncheckedCreateInput>
    /**
     * In case the account_viplist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<account_viplistUpdateInput, account_viplistUncheckedUpdateInput>
  }


  /**
   * account_viplist delete
   */
  export type account_viplistDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_viplist
     */
    select?: account_viplistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_viplistInclude<ExtArgs> | null
    /**
     * Filter which account_viplist to delete.
     */
    where: account_viplistWhereUniqueInput
  }


  /**
   * account_viplist deleteMany
   */
  export type account_viplistDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which account_viplists to delete
     */
    where?: account_viplistWhereInput
  }


  /**
   * account_viplist without action
   */
  export type account_viplistArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the account_viplist
     */
    select?: account_viplistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: account_viplistInclude<ExtArgs> | null
  }



  /**
   * Model guild_invites
   */


  export type AggregateGuild_invites = {
    _count: Guild_invitesCountAggregateOutputType | null
    _avg: Guild_invitesAvgAggregateOutputType | null
    _sum: Guild_invitesSumAggregateOutputType | null
    _min: Guild_invitesMinAggregateOutputType | null
    _max: Guild_invitesMaxAggregateOutputType | null
  }

  export type Guild_invitesAvgAggregateOutputType = {
    player_id: number | null
    guild_id: number | null
  }

  export type Guild_invitesSumAggregateOutputType = {
    player_id: number | null
    guild_id: number | null
  }

  export type Guild_invitesMinAggregateOutputType = {
    player_id: number | null
    guild_id: number | null
  }

  export type Guild_invitesMaxAggregateOutputType = {
    player_id: number | null
    guild_id: number | null
  }

  export type Guild_invitesCountAggregateOutputType = {
    player_id: number
    guild_id: number
    _all: number
  }


  export type Guild_invitesAvgAggregateInputType = {
    player_id?: true
    guild_id?: true
  }

  export type Guild_invitesSumAggregateInputType = {
    player_id?: true
    guild_id?: true
  }

  export type Guild_invitesMinAggregateInputType = {
    player_id?: true
    guild_id?: true
  }

  export type Guild_invitesMaxAggregateInputType = {
    player_id?: true
    guild_id?: true
  }

  export type Guild_invitesCountAggregateInputType = {
    player_id?: true
    guild_id?: true
    _all?: true
  }

  export type Guild_invitesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which guild_invites to aggregate.
     */
    where?: guild_invitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_invites to fetch.
     */
    orderBy?: Enumerable<guild_invitesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guild_invitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guild_invites
    **/
    _count?: true | Guild_invitesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Guild_invitesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Guild_invitesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Guild_invitesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Guild_invitesMaxAggregateInputType
  }

  export type GetGuild_invitesAggregateType<T extends Guild_invitesAggregateArgs> = {
        [P in keyof T & keyof AggregateGuild_invites]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuild_invites[P]>
      : GetScalarType<T[P], AggregateGuild_invites[P]>
  }




  export type Guild_invitesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: guild_invitesWhereInput
    orderBy?: Enumerable<guild_invitesOrderByWithAggregationInput>
    by: Guild_invitesScalarFieldEnum[]
    having?: guild_invitesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Guild_invitesCountAggregateInputType | true
    _avg?: Guild_invitesAvgAggregateInputType
    _sum?: Guild_invitesSumAggregateInputType
    _min?: Guild_invitesMinAggregateInputType
    _max?: Guild_invitesMaxAggregateInputType
  }


  export type Guild_invitesGroupByOutputType = {
    player_id: number
    guild_id: number
    _count: Guild_invitesCountAggregateOutputType | null
    _avg: Guild_invitesAvgAggregateOutputType | null
    _sum: Guild_invitesSumAggregateOutputType | null
    _min: Guild_invitesMinAggregateOutputType | null
    _max: Guild_invitesMaxAggregateOutputType | null
  }

  type GetGuild_invitesGroupByPayload<T extends Guild_invitesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Guild_invitesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Guild_invitesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Guild_invitesGroupByOutputType[P]>
            : GetScalarType<T[P], Guild_invitesGroupByOutputType[P]>
        }
      >
    >


  export type guild_invitesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    player_id?: boolean
    guild_id?: boolean
    players?: boolean | PlayerArgs<ExtArgs>
    guilds?: boolean | guildsArgs<ExtArgs>
  }, ExtArgs["result"]["guild_invites"]>

  export type guild_invitesSelectScalar = {
    player_id?: boolean
    guild_id?: boolean
  }

  export type guild_invitesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    players?: boolean | PlayerArgs<ExtArgs>
    guilds?: boolean | guildsArgs<ExtArgs>
  }


  type guild_invitesGetPayload<S extends boolean | null | undefined | guild_invitesArgs> = $Types.GetResult<guild_invitesPayload, S>

  type guild_invitesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<guild_invitesFindManyArgs, 'select' | 'include'> & {
      select?: Guild_invitesCountAggregateInputType | true
    }

  export interface guild_invitesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guild_invites'], meta: { name: 'guild_invites' } }
    /**
     * Find zero or one Guild_invites that matches the filter.
     * @param {guild_invitesFindUniqueArgs} args - Arguments to find a Guild_invites
     * @example
     * // Get one Guild_invites
     * const guild_invites = await prisma.guild_invites.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends guild_invitesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, guild_invitesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'guild_invites'> extends True ? Prisma__guild_invitesClient<$Types.GetResult<guild_invitesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__guild_invitesClient<$Types.GetResult<guild_invitesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Guild_invites that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {guild_invitesFindUniqueOrThrowArgs} args - Arguments to find a Guild_invites
     * @example
     * // Get one Guild_invites
     * const guild_invites = await prisma.guild_invites.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends guild_invitesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_invitesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__guild_invitesClient<$Types.GetResult<guild_invitesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Guild_invites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_invitesFindFirstArgs} args - Arguments to find a Guild_invites
     * @example
     * // Get one Guild_invites
     * const guild_invites = await prisma.guild_invites.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends guild_invitesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, guild_invitesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'guild_invites'> extends True ? Prisma__guild_invitesClient<$Types.GetResult<guild_invitesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__guild_invitesClient<$Types.GetResult<guild_invitesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Guild_invites that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_invitesFindFirstOrThrowArgs} args - Arguments to find a Guild_invites
     * @example
     * // Get one Guild_invites
     * const guild_invites = await prisma.guild_invites.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends guild_invitesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_invitesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__guild_invitesClient<$Types.GetResult<guild_invitesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Guild_invites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_invitesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guild_invites
     * const guild_invites = await prisma.guild_invites.findMany()
     * 
     * // Get first 10 Guild_invites
     * const guild_invites = await prisma.guild_invites.findMany({ take: 10 })
     * 
     * // Only select the `player_id`
     * const guild_invitesWithPlayer_idOnly = await prisma.guild_invites.findMany({ select: { player_id: true } })
     * 
    **/
    findMany<T extends guild_invitesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_invitesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<guild_invitesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Guild_invites.
     * @param {guild_invitesCreateArgs} args - Arguments to create a Guild_invites.
     * @example
     * // Create one Guild_invites
     * const Guild_invites = await prisma.guild_invites.create({
     *   data: {
     *     // ... data to create a Guild_invites
     *   }
     * })
     * 
    **/
    create<T extends guild_invitesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, guild_invitesCreateArgs<ExtArgs>>
    ): Prisma__guild_invitesClient<$Types.GetResult<guild_invitesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Guild_invites.
     *     @param {guild_invitesCreateManyArgs} args - Arguments to create many Guild_invites.
     *     @example
     *     // Create many Guild_invites
     *     const guild_invites = await prisma.guild_invites.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends guild_invitesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_invitesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guild_invites.
     * @param {guild_invitesDeleteArgs} args - Arguments to delete one Guild_invites.
     * @example
     * // Delete one Guild_invites
     * const Guild_invites = await prisma.guild_invites.delete({
     *   where: {
     *     // ... filter to delete one Guild_invites
     *   }
     * })
     * 
    **/
    delete<T extends guild_invitesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, guild_invitesDeleteArgs<ExtArgs>>
    ): Prisma__guild_invitesClient<$Types.GetResult<guild_invitesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Guild_invites.
     * @param {guild_invitesUpdateArgs} args - Arguments to update one Guild_invites.
     * @example
     * // Update one Guild_invites
     * const guild_invites = await prisma.guild_invites.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends guild_invitesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, guild_invitesUpdateArgs<ExtArgs>>
    ): Prisma__guild_invitesClient<$Types.GetResult<guild_invitesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Guild_invites.
     * @param {guild_invitesDeleteManyArgs} args - Arguments to filter Guild_invites to delete.
     * @example
     * // Delete a few Guild_invites
     * const { count } = await prisma.guild_invites.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends guild_invitesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_invitesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guild_invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_invitesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guild_invites
     * const guild_invites = await prisma.guild_invites.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends guild_invitesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, guild_invitesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guild_invites.
     * @param {guild_invitesUpsertArgs} args - Arguments to update or create a Guild_invites.
     * @example
     * // Update or create a Guild_invites
     * const guild_invites = await prisma.guild_invites.upsert({
     *   create: {
     *     // ... data to create a Guild_invites
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guild_invites we want to update
     *   }
     * })
    **/
    upsert<T extends guild_invitesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, guild_invitesUpsertArgs<ExtArgs>>
    ): Prisma__guild_invitesClient<$Types.GetResult<guild_invitesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Guild_invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_invitesCountArgs} args - Arguments to filter Guild_invites to count.
     * @example
     * // Count the number of Guild_invites
     * const count = await prisma.guild_invites.count({
     *   where: {
     *     // ... the filter for the Guild_invites we want to count
     *   }
     * })
    **/
    count<T extends guild_invitesCountArgs>(
      args?: Subset<T, guild_invitesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Guild_invitesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guild_invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Guild_invitesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Guild_invitesAggregateArgs>(args: Subset<T, Guild_invitesAggregateArgs>): Prisma.PrismaPromise<GetGuild_invitesAggregateType<T>>

    /**
     * Group by Guild_invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Guild_invitesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Guild_invitesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Guild_invitesGroupByArgs['orderBy'] }
        : { orderBy?: Guild_invitesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Guild_invitesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuild_invitesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for guild_invites.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__guild_invitesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    players<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    guilds<T extends guildsArgs<ExtArgs> = {}>(args?: Subset<T, guildsArgs<ExtArgs>>): Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * guild_invites base type for findUnique actions
   */
  export type guild_invitesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_invites
     */
    select?: guild_invitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_invitesInclude<ExtArgs> | null
    /**
     * Filter, which guild_invites to fetch.
     */
    where: guild_invitesWhereUniqueInput
  }

  /**
   * guild_invites findUnique
   */
  export interface guild_invitesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends guild_invitesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * guild_invites findUniqueOrThrow
   */
  export type guild_invitesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_invites
     */
    select?: guild_invitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_invitesInclude<ExtArgs> | null
    /**
     * Filter, which guild_invites to fetch.
     */
    where: guild_invitesWhereUniqueInput
  }


  /**
   * guild_invites base type for findFirst actions
   */
  export type guild_invitesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_invites
     */
    select?: guild_invitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_invitesInclude<ExtArgs> | null
    /**
     * Filter, which guild_invites to fetch.
     */
    where?: guild_invitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_invites to fetch.
     */
    orderBy?: Enumerable<guild_invitesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guild_invites.
     */
    cursor?: guild_invitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guild_invites.
     */
    distinct?: Enumerable<Guild_invitesScalarFieldEnum>
  }

  /**
   * guild_invites findFirst
   */
  export interface guild_invitesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends guild_invitesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * guild_invites findFirstOrThrow
   */
  export type guild_invitesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_invites
     */
    select?: guild_invitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_invitesInclude<ExtArgs> | null
    /**
     * Filter, which guild_invites to fetch.
     */
    where?: guild_invitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_invites to fetch.
     */
    orderBy?: Enumerable<guild_invitesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guild_invites.
     */
    cursor?: guild_invitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guild_invites.
     */
    distinct?: Enumerable<Guild_invitesScalarFieldEnum>
  }


  /**
   * guild_invites findMany
   */
  export type guild_invitesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_invites
     */
    select?: guild_invitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_invitesInclude<ExtArgs> | null
    /**
     * Filter, which guild_invites to fetch.
     */
    where?: guild_invitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_invites to fetch.
     */
    orderBy?: Enumerable<guild_invitesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guild_invites.
     */
    cursor?: guild_invitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_invites.
     */
    skip?: number
    distinct?: Enumerable<Guild_invitesScalarFieldEnum>
  }


  /**
   * guild_invites create
   */
  export type guild_invitesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_invites
     */
    select?: guild_invitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_invitesInclude<ExtArgs> | null
    /**
     * The data needed to create a guild_invites.
     */
    data: XOR<guild_invitesCreateInput, guild_invitesUncheckedCreateInput>
  }


  /**
   * guild_invites createMany
   */
  export type guild_invitesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guild_invites.
     */
    data: Enumerable<guild_invitesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * guild_invites update
   */
  export type guild_invitesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_invites
     */
    select?: guild_invitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_invitesInclude<ExtArgs> | null
    /**
     * The data needed to update a guild_invites.
     */
    data: XOR<guild_invitesUpdateInput, guild_invitesUncheckedUpdateInput>
    /**
     * Choose, which guild_invites to update.
     */
    where: guild_invitesWhereUniqueInput
  }


  /**
   * guild_invites updateMany
   */
  export type guild_invitesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guild_invites.
     */
    data: XOR<guild_invitesUpdateManyMutationInput, guild_invitesUncheckedUpdateManyInput>
    /**
     * Filter which guild_invites to update
     */
    where?: guild_invitesWhereInput
  }


  /**
   * guild_invites upsert
   */
  export type guild_invitesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_invites
     */
    select?: guild_invitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_invitesInclude<ExtArgs> | null
    /**
     * The filter to search for the guild_invites to update in case it exists.
     */
    where: guild_invitesWhereUniqueInput
    /**
     * In case the guild_invites found by the `where` argument doesn't exist, create a new guild_invites with this data.
     */
    create: XOR<guild_invitesCreateInput, guild_invitesUncheckedCreateInput>
    /**
     * In case the guild_invites was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guild_invitesUpdateInput, guild_invitesUncheckedUpdateInput>
  }


  /**
   * guild_invites delete
   */
  export type guild_invitesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_invites
     */
    select?: guild_invitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_invitesInclude<ExtArgs> | null
    /**
     * Filter which guild_invites to delete.
     */
    where: guild_invitesWhereUniqueInput
  }


  /**
   * guild_invites deleteMany
   */
  export type guild_invitesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which guild_invites to delete
     */
    where?: guild_invitesWhereInput
  }


  /**
   * guild_invites without action
   */
  export type guild_invitesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_invites
     */
    select?: guild_invitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_invitesInclude<ExtArgs> | null
  }



  /**
   * Model guild_membership
   */


  export type AggregateGuild_membership = {
    _count: Guild_membershipCountAggregateOutputType | null
    _avg: Guild_membershipAvgAggregateOutputType | null
    _sum: Guild_membershipSumAggregateOutputType | null
    _min: Guild_membershipMinAggregateOutputType | null
    _max: Guild_membershipMaxAggregateOutputType | null
  }

  export type Guild_membershipAvgAggregateOutputType = {
    player_id: number | null
    guild_id: number | null
    rank_id: number | null
  }

  export type Guild_membershipSumAggregateOutputType = {
    player_id: number | null
    guild_id: number | null
    rank_id: number | null
  }

  export type Guild_membershipMinAggregateOutputType = {
    player_id: number | null
    guild_id: number | null
    rank_id: number | null
    nick: string | null
  }

  export type Guild_membershipMaxAggregateOutputType = {
    player_id: number | null
    guild_id: number | null
    rank_id: number | null
    nick: string | null
  }

  export type Guild_membershipCountAggregateOutputType = {
    player_id: number
    guild_id: number
    rank_id: number
    nick: number
    _all: number
  }


  export type Guild_membershipAvgAggregateInputType = {
    player_id?: true
    guild_id?: true
    rank_id?: true
  }

  export type Guild_membershipSumAggregateInputType = {
    player_id?: true
    guild_id?: true
    rank_id?: true
  }

  export type Guild_membershipMinAggregateInputType = {
    player_id?: true
    guild_id?: true
    rank_id?: true
    nick?: true
  }

  export type Guild_membershipMaxAggregateInputType = {
    player_id?: true
    guild_id?: true
    rank_id?: true
    nick?: true
  }

  export type Guild_membershipCountAggregateInputType = {
    player_id?: true
    guild_id?: true
    rank_id?: true
    nick?: true
    _all?: true
  }

  export type Guild_membershipAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which guild_membership to aggregate.
     */
    where?: guild_membershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_memberships to fetch.
     */
    orderBy?: Enumerable<guild_membershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guild_membershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guild_memberships
    **/
    _count?: true | Guild_membershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Guild_membershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Guild_membershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Guild_membershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Guild_membershipMaxAggregateInputType
  }

  export type GetGuild_membershipAggregateType<T extends Guild_membershipAggregateArgs> = {
        [P in keyof T & keyof AggregateGuild_membership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuild_membership[P]>
      : GetScalarType<T[P], AggregateGuild_membership[P]>
  }




  export type Guild_membershipGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: guild_membershipWhereInput
    orderBy?: Enumerable<guild_membershipOrderByWithAggregationInput>
    by: Guild_membershipScalarFieldEnum[]
    having?: guild_membershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Guild_membershipCountAggregateInputType | true
    _avg?: Guild_membershipAvgAggregateInputType
    _sum?: Guild_membershipSumAggregateInputType
    _min?: Guild_membershipMinAggregateInputType
    _max?: Guild_membershipMaxAggregateInputType
  }


  export type Guild_membershipGroupByOutputType = {
    player_id: number
    guild_id: number
    rank_id: number
    nick: string
    _count: Guild_membershipCountAggregateOutputType | null
    _avg: Guild_membershipAvgAggregateOutputType | null
    _sum: Guild_membershipSumAggregateOutputType | null
    _min: Guild_membershipMinAggregateOutputType | null
    _max: Guild_membershipMaxAggregateOutputType | null
  }

  type GetGuild_membershipGroupByPayload<T extends Guild_membershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Guild_membershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Guild_membershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Guild_membershipGroupByOutputType[P]>
            : GetScalarType<T[P], Guild_membershipGroupByOutputType[P]>
        }
      >
    >


  export type guild_membershipSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    player_id?: boolean
    guild_id?: boolean
    rank_id?: boolean
    nick?: boolean
    players?: boolean | PlayerArgs<ExtArgs>
    guilds?: boolean | guildsArgs<ExtArgs>
    guild_ranks?: boolean | guild_ranksArgs<ExtArgs>
  }, ExtArgs["result"]["guild_membership"]>

  export type guild_membershipSelectScalar = {
    player_id?: boolean
    guild_id?: boolean
    rank_id?: boolean
    nick?: boolean
  }

  export type guild_membershipInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    players?: boolean | PlayerArgs<ExtArgs>
    guilds?: boolean | guildsArgs<ExtArgs>
    guild_ranks?: boolean | guild_ranksArgs<ExtArgs>
  }


  type guild_membershipGetPayload<S extends boolean | null | undefined | guild_membershipArgs> = $Types.GetResult<guild_membershipPayload, S>

  type guild_membershipCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<guild_membershipFindManyArgs, 'select' | 'include'> & {
      select?: Guild_membershipCountAggregateInputType | true
    }

  export interface guild_membershipDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guild_membership'], meta: { name: 'guild_membership' } }
    /**
     * Find zero or one Guild_membership that matches the filter.
     * @param {guild_membershipFindUniqueArgs} args - Arguments to find a Guild_membership
     * @example
     * // Get one Guild_membership
     * const guild_membership = await prisma.guild_membership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends guild_membershipFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, guild_membershipFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'guild_membership'> extends True ? Prisma__guild_membershipClient<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__guild_membershipClient<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Guild_membership that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {guild_membershipFindUniqueOrThrowArgs} args - Arguments to find a Guild_membership
     * @example
     * // Get one Guild_membership
     * const guild_membership = await prisma.guild_membership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends guild_membershipFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_membershipFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__guild_membershipClient<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Guild_membership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_membershipFindFirstArgs} args - Arguments to find a Guild_membership
     * @example
     * // Get one Guild_membership
     * const guild_membership = await prisma.guild_membership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends guild_membershipFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, guild_membershipFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'guild_membership'> extends True ? Prisma__guild_membershipClient<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__guild_membershipClient<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Guild_membership that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_membershipFindFirstOrThrowArgs} args - Arguments to find a Guild_membership
     * @example
     * // Get one Guild_membership
     * const guild_membership = await prisma.guild_membership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends guild_membershipFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_membershipFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__guild_membershipClient<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Guild_memberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_membershipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guild_memberships
     * const guild_memberships = await prisma.guild_membership.findMany()
     * 
     * // Get first 10 Guild_memberships
     * const guild_memberships = await prisma.guild_membership.findMany({ take: 10 })
     * 
     * // Only select the `player_id`
     * const guild_membershipWithPlayer_idOnly = await prisma.guild_membership.findMany({ select: { player_id: true } })
     * 
    **/
    findMany<T extends guild_membershipFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_membershipFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Guild_membership.
     * @param {guild_membershipCreateArgs} args - Arguments to create a Guild_membership.
     * @example
     * // Create one Guild_membership
     * const Guild_membership = await prisma.guild_membership.create({
     *   data: {
     *     // ... data to create a Guild_membership
     *   }
     * })
     * 
    **/
    create<T extends guild_membershipCreateArgs<ExtArgs>>(
      args: SelectSubset<T, guild_membershipCreateArgs<ExtArgs>>
    ): Prisma__guild_membershipClient<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Guild_memberships.
     *     @param {guild_membershipCreateManyArgs} args - Arguments to create many Guild_memberships.
     *     @example
     *     // Create many Guild_memberships
     *     const guild_membership = await prisma.guild_membership.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends guild_membershipCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_membershipCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guild_membership.
     * @param {guild_membershipDeleteArgs} args - Arguments to delete one Guild_membership.
     * @example
     * // Delete one Guild_membership
     * const Guild_membership = await prisma.guild_membership.delete({
     *   where: {
     *     // ... filter to delete one Guild_membership
     *   }
     * })
     * 
    **/
    delete<T extends guild_membershipDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, guild_membershipDeleteArgs<ExtArgs>>
    ): Prisma__guild_membershipClient<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Guild_membership.
     * @param {guild_membershipUpdateArgs} args - Arguments to update one Guild_membership.
     * @example
     * // Update one Guild_membership
     * const guild_membership = await prisma.guild_membership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends guild_membershipUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, guild_membershipUpdateArgs<ExtArgs>>
    ): Prisma__guild_membershipClient<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Guild_memberships.
     * @param {guild_membershipDeleteManyArgs} args - Arguments to filter Guild_memberships to delete.
     * @example
     * // Delete a few Guild_memberships
     * const { count } = await prisma.guild_membership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends guild_membershipDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_membershipDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guild_memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_membershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guild_memberships
     * const guild_membership = await prisma.guild_membership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends guild_membershipUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, guild_membershipUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guild_membership.
     * @param {guild_membershipUpsertArgs} args - Arguments to update or create a Guild_membership.
     * @example
     * // Update or create a Guild_membership
     * const guild_membership = await prisma.guild_membership.upsert({
     *   create: {
     *     // ... data to create a Guild_membership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guild_membership we want to update
     *   }
     * })
    **/
    upsert<T extends guild_membershipUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, guild_membershipUpsertArgs<ExtArgs>>
    ): Prisma__guild_membershipClient<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Guild_memberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_membershipCountArgs} args - Arguments to filter Guild_memberships to count.
     * @example
     * // Count the number of Guild_memberships
     * const count = await prisma.guild_membership.count({
     *   where: {
     *     // ... the filter for the Guild_memberships we want to count
     *   }
     * })
    **/
    count<T extends guild_membershipCountArgs>(
      args?: Subset<T, guild_membershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Guild_membershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guild_membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Guild_membershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Guild_membershipAggregateArgs>(args: Subset<T, Guild_membershipAggregateArgs>): Prisma.PrismaPromise<GetGuild_membershipAggregateType<T>>

    /**
     * Group by Guild_membership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Guild_membershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Guild_membershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Guild_membershipGroupByArgs['orderBy'] }
        : { orderBy?: Guild_membershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Guild_membershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuild_membershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for guild_membership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__guild_membershipClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    players<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    guilds<T extends guildsArgs<ExtArgs> = {}>(args?: Subset<T, guildsArgs<ExtArgs>>): Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    guild_ranks<T extends guild_ranksArgs<ExtArgs> = {}>(args?: Subset<T, guild_ranksArgs<ExtArgs>>): Prisma__guild_ranksClient<$Types.GetResult<guild_ranksPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * guild_membership base type for findUnique actions
   */
  export type guild_membershipFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_membership
     */
    select?: guild_membershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_membershipInclude<ExtArgs> | null
    /**
     * Filter, which guild_membership to fetch.
     */
    where: guild_membershipWhereUniqueInput
  }

  /**
   * guild_membership findUnique
   */
  export interface guild_membershipFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends guild_membershipFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * guild_membership findUniqueOrThrow
   */
  export type guild_membershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_membership
     */
    select?: guild_membershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_membershipInclude<ExtArgs> | null
    /**
     * Filter, which guild_membership to fetch.
     */
    where: guild_membershipWhereUniqueInput
  }


  /**
   * guild_membership base type for findFirst actions
   */
  export type guild_membershipFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_membership
     */
    select?: guild_membershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_membershipInclude<ExtArgs> | null
    /**
     * Filter, which guild_membership to fetch.
     */
    where?: guild_membershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_memberships to fetch.
     */
    orderBy?: Enumerable<guild_membershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guild_memberships.
     */
    cursor?: guild_membershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guild_memberships.
     */
    distinct?: Enumerable<Guild_membershipScalarFieldEnum>
  }

  /**
   * guild_membership findFirst
   */
  export interface guild_membershipFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends guild_membershipFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * guild_membership findFirstOrThrow
   */
  export type guild_membershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_membership
     */
    select?: guild_membershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_membershipInclude<ExtArgs> | null
    /**
     * Filter, which guild_membership to fetch.
     */
    where?: guild_membershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_memberships to fetch.
     */
    orderBy?: Enumerable<guild_membershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guild_memberships.
     */
    cursor?: guild_membershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_memberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guild_memberships.
     */
    distinct?: Enumerable<Guild_membershipScalarFieldEnum>
  }


  /**
   * guild_membership findMany
   */
  export type guild_membershipFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_membership
     */
    select?: guild_membershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_membershipInclude<ExtArgs> | null
    /**
     * Filter, which guild_memberships to fetch.
     */
    where?: guild_membershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_memberships to fetch.
     */
    orderBy?: Enumerable<guild_membershipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guild_memberships.
     */
    cursor?: guild_membershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_memberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_memberships.
     */
    skip?: number
    distinct?: Enumerable<Guild_membershipScalarFieldEnum>
  }


  /**
   * guild_membership create
   */
  export type guild_membershipCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_membership
     */
    select?: guild_membershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_membershipInclude<ExtArgs> | null
    /**
     * The data needed to create a guild_membership.
     */
    data: XOR<guild_membershipCreateInput, guild_membershipUncheckedCreateInput>
  }


  /**
   * guild_membership createMany
   */
  export type guild_membershipCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guild_memberships.
     */
    data: Enumerable<guild_membershipCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * guild_membership update
   */
  export type guild_membershipUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_membership
     */
    select?: guild_membershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_membershipInclude<ExtArgs> | null
    /**
     * The data needed to update a guild_membership.
     */
    data: XOR<guild_membershipUpdateInput, guild_membershipUncheckedUpdateInput>
    /**
     * Choose, which guild_membership to update.
     */
    where: guild_membershipWhereUniqueInput
  }


  /**
   * guild_membership updateMany
   */
  export type guild_membershipUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guild_memberships.
     */
    data: XOR<guild_membershipUpdateManyMutationInput, guild_membershipUncheckedUpdateManyInput>
    /**
     * Filter which guild_memberships to update
     */
    where?: guild_membershipWhereInput
  }


  /**
   * guild_membership upsert
   */
  export type guild_membershipUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_membership
     */
    select?: guild_membershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_membershipInclude<ExtArgs> | null
    /**
     * The filter to search for the guild_membership to update in case it exists.
     */
    where: guild_membershipWhereUniqueInput
    /**
     * In case the guild_membership found by the `where` argument doesn't exist, create a new guild_membership with this data.
     */
    create: XOR<guild_membershipCreateInput, guild_membershipUncheckedCreateInput>
    /**
     * In case the guild_membership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guild_membershipUpdateInput, guild_membershipUncheckedUpdateInput>
  }


  /**
   * guild_membership delete
   */
  export type guild_membershipDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_membership
     */
    select?: guild_membershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_membershipInclude<ExtArgs> | null
    /**
     * Filter which guild_membership to delete.
     */
    where: guild_membershipWhereUniqueInput
  }


  /**
   * guild_membership deleteMany
   */
  export type guild_membershipDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which guild_memberships to delete
     */
    where?: guild_membershipWhereInput
  }


  /**
   * guild_membership without action
   */
  export type guild_membershipArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_membership
     */
    select?: guild_membershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_membershipInclude<ExtArgs> | null
  }



  /**
   * Model guild_ranks
   */


  export type AggregateGuild_ranks = {
    _count: Guild_ranksCountAggregateOutputType | null
    _avg: Guild_ranksAvgAggregateOutputType | null
    _sum: Guild_ranksSumAggregateOutputType | null
    _min: Guild_ranksMinAggregateOutputType | null
    _max: Guild_ranksMaxAggregateOutputType | null
  }

  export type Guild_ranksAvgAggregateOutputType = {
    id: number | null
    guild_id: number | null
    level: number | null
  }

  export type Guild_ranksSumAggregateOutputType = {
    id: number | null
    guild_id: number | null
    level: number | null
  }

  export type Guild_ranksMinAggregateOutputType = {
    id: number | null
    guild_id: number | null
    name: string | null
    level: number | null
  }

  export type Guild_ranksMaxAggregateOutputType = {
    id: number | null
    guild_id: number | null
    name: string | null
    level: number | null
  }

  export type Guild_ranksCountAggregateOutputType = {
    id: number
    guild_id: number
    name: number
    level: number
    _all: number
  }


  export type Guild_ranksAvgAggregateInputType = {
    id?: true
    guild_id?: true
    level?: true
  }

  export type Guild_ranksSumAggregateInputType = {
    id?: true
    guild_id?: true
    level?: true
  }

  export type Guild_ranksMinAggregateInputType = {
    id?: true
    guild_id?: true
    name?: true
    level?: true
  }

  export type Guild_ranksMaxAggregateInputType = {
    id?: true
    guild_id?: true
    name?: true
    level?: true
  }

  export type Guild_ranksCountAggregateInputType = {
    id?: true
    guild_id?: true
    name?: true
    level?: true
    _all?: true
  }

  export type Guild_ranksAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which guild_ranks to aggregate.
     */
    where?: guild_ranksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_ranks to fetch.
     */
    orderBy?: Enumerable<guild_ranksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guild_ranksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guild_ranks
    **/
    _count?: true | Guild_ranksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Guild_ranksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Guild_ranksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Guild_ranksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Guild_ranksMaxAggregateInputType
  }

  export type GetGuild_ranksAggregateType<T extends Guild_ranksAggregateArgs> = {
        [P in keyof T & keyof AggregateGuild_ranks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuild_ranks[P]>
      : GetScalarType<T[P], AggregateGuild_ranks[P]>
  }




  export type Guild_ranksGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: guild_ranksWhereInput
    orderBy?: Enumerable<guild_ranksOrderByWithAggregationInput>
    by: Guild_ranksScalarFieldEnum[]
    having?: guild_ranksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Guild_ranksCountAggregateInputType | true
    _avg?: Guild_ranksAvgAggregateInputType
    _sum?: Guild_ranksSumAggregateInputType
    _min?: Guild_ranksMinAggregateInputType
    _max?: Guild_ranksMaxAggregateInputType
  }


  export type Guild_ranksGroupByOutputType = {
    id: number
    guild_id: number
    name: string
    level: number
    _count: Guild_ranksCountAggregateOutputType | null
    _avg: Guild_ranksAvgAggregateOutputType | null
    _sum: Guild_ranksSumAggregateOutputType | null
    _min: Guild_ranksMinAggregateOutputType | null
    _max: Guild_ranksMaxAggregateOutputType | null
  }

  type GetGuild_ranksGroupByPayload<T extends Guild_ranksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Guild_ranksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Guild_ranksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Guild_ranksGroupByOutputType[P]>
            : GetScalarType<T[P], Guild_ranksGroupByOutputType[P]>
        }
      >
    >


  export type guild_ranksSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guild_id?: boolean
    name?: boolean
    level?: boolean
    guild_membership?: boolean | guild_ranks$guild_membershipArgs<ExtArgs>
    guilds?: boolean | guildsArgs<ExtArgs>
    _count?: boolean | Guild_ranksCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["guild_ranks"]>

  export type guild_ranksSelectScalar = {
    id?: boolean
    guild_id?: boolean
    name?: boolean
    level?: boolean
  }

  export type guild_ranksInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    guild_membership?: boolean | guild_ranks$guild_membershipArgs<ExtArgs>
    guilds?: boolean | guildsArgs<ExtArgs>
    _count?: boolean | Guild_ranksCountOutputTypeArgs<ExtArgs>
  }


  type guild_ranksGetPayload<S extends boolean | null | undefined | guild_ranksArgs> = $Types.GetResult<guild_ranksPayload, S>

  type guild_ranksCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<guild_ranksFindManyArgs, 'select' | 'include'> & {
      select?: Guild_ranksCountAggregateInputType | true
    }

  export interface guild_ranksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guild_ranks'], meta: { name: 'guild_ranks' } }
    /**
     * Find zero or one Guild_ranks that matches the filter.
     * @param {guild_ranksFindUniqueArgs} args - Arguments to find a Guild_ranks
     * @example
     * // Get one Guild_ranks
     * const guild_ranks = await prisma.guild_ranks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends guild_ranksFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, guild_ranksFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'guild_ranks'> extends True ? Prisma__guild_ranksClient<$Types.GetResult<guild_ranksPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__guild_ranksClient<$Types.GetResult<guild_ranksPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Guild_ranks that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {guild_ranksFindUniqueOrThrowArgs} args - Arguments to find a Guild_ranks
     * @example
     * // Get one Guild_ranks
     * const guild_ranks = await prisma.guild_ranks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends guild_ranksFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_ranksFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__guild_ranksClient<$Types.GetResult<guild_ranksPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Guild_ranks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_ranksFindFirstArgs} args - Arguments to find a Guild_ranks
     * @example
     * // Get one Guild_ranks
     * const guild_ranks = await prisma.guild_ranks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends guild_ranksFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, guild_ranksFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'guild_ranks'> extends True ? Prisma__guild_ranksClient<$Types.GetResult<guild_ranksPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__guild_ranksClient<$Types.GetResult<guild_ranksPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Guild_ranks that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_ranksFindFirstOrThrowArgs} args - Arguments to find a Guild_ranks
     * @example
     * // Get one Guild_ranks
     * const guild_ranks = await prisma.guild_ranks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends guild_ranksFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_ranksFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__guild_ranksClient<$Types.GetResult<guild_ranksPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Guild_ranks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_ranksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guild_ranks
     * const guild_ranks = await prisma.guild_ranks.findMany()
     * 
     * // Get first 10 Guild_ranks
     * const guild_ranks = await prisma.guild_ranks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guild_ranksWithIdOnly = await prisma.guild_ranks.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends guild_ranksFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_ranksFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<guild_ranksPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Guild_ranks.
     * @param {guild_ranksCreateArgs} args - Arguments to create a Guild_ranks.
     * @example
     * // Create one Guild_ranks
     * const Guild_ranks = await prisma.guild_ranks.create({
     *   data: {
     *     // ... data to create a Guild_ranks
     *   }
     * })
     * 
    **/
    create<T extends guild_ranksCreateArgs<ExtArgs>>(
      args: SelectSubset<T, guild_ranksCreateArgs<ExtArgs>>
    ): Prisma__guild_ranksClient<$Types.GetResult<guild_ranksPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Guild_ranks.
     *     @param {guild_ranksCreateManyArgs} args - Arguments to create many Guild_ranks.
     *     @example
     *     // Create many Guild_ranks
     *     const guild_ranks = await prisma.guild_ranks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends guild_ranksCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_ranksCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guild_ranks.
     * @param {guild_ranksDeleteArgs} args - Arguments to delete one Guild_ranks.
     * @example
     * // Delete one Guild_ranks
     * const Guild_ranks = await prisma.guild_ranks.delete({
     *   where: {
     *     // ... filter to delete one Guild_ranks
     *   }
     * })
     * 
    **/
    delete<T extends guild_ranksDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, guild_ranksDeleteArgs<ExtArgs>>
    ): Prisma__guild_ranksClient<$Types.GetResult<guild_ranksPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Guild_ranks.
     * @param {guild_ranksUpdateArgs} args - Arguments to update one Guild_ranks.
     * @example
     * // Update one Guild_ranks
     * const guild_ranks = await prisma.guild_ranks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends guild_ranksUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, guild_ranksUpdateArgs<ExtArgs>>
    ): Prisma__guild_ranksClient<$Types.GetResult<guild_ranksPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Guild_ranks.
     * @param {guild_ranksDeleteManyArgs} args - Arguments to filter Guild_ranks to delete.
     * @example
     * // Delete a few Guild_ranks
     * const { count } = await prisma.guild_ranks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends guild_ranksDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_ranksDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guild_ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_ranksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guild_ranks
     * const guild_ranks = await prisma.guild_ranks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends guild_ranksUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, guild_ranksUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guild_ranks.
     * @param {guild_ranksUpsertArgs} args - Arguments to update or create a Guild_ranks.
     * @example
     * // Update or create a Guild_ranks
     * const guild_ranks = await prisma.guild_ranks.upsert({
     *   create: {
     *     // ... data to create a Guild_ranks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guild_ranks we want to update
     *   }
     * })
    **/
    upsert<T extends guild_ranksUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, guild_ranksUpsertArgs<ExtArgs>>
    ): Prisma__guild_ranksClient<$Types.GetResult<guild_ranksPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Guild_ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_ranksCountArgs} args - Arguments to filter Guild_ranks to count.
     * @example
     * // Count the number of Guild_ranks
     * const count = await prisma.guild_ranks.count({
     *   where: {
     *     // ... the filter for the Guild_ranks we want to count
     *   }
     * })
    **/
    count<T extends guild_ranksCountArgs>(
      args?: Subset<T, guild_ranksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Guild_ranksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guild_ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Guild_ranksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Guild_ranksAggregateArgs>(args: Subset<T, Guild_ranksAggregateArgs>): Prisma.PrismaPromise<GetGuild_ranksAggregateType<T>>

    /**
     * Group by Guild_ranks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Guild_ranksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Guild_ranksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Guild_ranksGroupByArgs['orderBy'] }
        : { orderBy?: Guild_ranksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Guild_ranksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuild_ranksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for guild_ranks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__guild_ranksClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    guild_membership<T extends guild_ranks$guild_membershipArgs<ExtArgs> = {}>(args?: Subset<T, guild_ranks$guild_membershipArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'findMany', never>| Null>;

    guilds<T extends guildsArgs<ExtArgs> = {}>(args?: Subset<T, guildsArgs<ExtArgs>>): Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * guild_ranks base type for findUnique actions
   */
  export type guild_ranksFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_ranks
     */
    select?: guild_ranksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_ranksInclude<ExtArgs> | null
    /**
     * Filter, which guild_ranks to fetch.
     */
    where: guild_ranksWhereUniqueInput
  }

  /**
   * guild_ranks findUnique
   */
  export interface guild_ranksFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends guild_ranksFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * guild_ranks findUniqueOrThrow
   */
  export type guild_ranksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_ranks
     */
    select?: guild_ranksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_ranksInclude<ExtArgs> | null
    /**
     * Filter, which guild_ranks to fetch.
     */
    where: guild_ranksWhereUniqueInput
  }


  /**
   * guild_ranks base type for findFirst actions
   */
  export type guild_ranksFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_ranks
     */
    select?: guild_ranksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_ranksInclude<ExtArgs> | null
    /**
     * Filter, which guild_ranks to fetch.
     */
    where?: guild_ranksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_ranks to fetch.
     */
    orderBy?: Enumerable<guild_ranksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guild_ranks.
     */
    cursor?: guild_ranksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guild_ranks.
     */
    distinct?: Enumerable<Guild_ranksScalarFieldEnum>
  }

  /**
   * guild_ranks findFirst
   */
  export interface guild_ranksFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends guild_ranksFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * guild_ranks findFirstOrThrow
   */
  export type guild_ranksFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_ranks
     */
    select?: guild_ranksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_ranksInclude<ExtArgs> | null
    /**
     * Filter, which guild_ranks to fetch.
     */
    where?: guild_ranksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_ranks to fetch.
     */
    orderBy?: Enumerable<guild_ranksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guild_ranks.
     */
    cursor?: guild_ranksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_ranks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guild_ranks.
     */
    distinct?: Enumerable<Guild_ranksScalarFieldEnum>
  }


  /**
   * guild_ranks findMany
   */
  export type guild_ranksFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_ranks
     */
    select?: guild_ranksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_ranksInclude<ExtArgs> | null
    /**
     * Filter, which guild_ranks to fetch.
     */
    where?: guild_ranksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_ranks to fetch.
     */
    orderBy?: Enumerable<guild_ranksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guild_ranks.
     */
    cursor?: guild_ranksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_ranks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_ranks.
     */
    skip?: number
    distinct?: Enumerable<Guild_ranksScalarFieldEnum>
  }


  /**
   * guild_ranks create
   */
  export type guild_ranksCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_ranks
     */
    select?: guild_ranksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_ranksInclude<ExtArgs> | null
    /**
     * The data needed to create a guild_ranks.
     */
    data: XOR<guild_ranksCreateInput, guild_ranksUncheckedCreateInput>
  }


  /**
   * guild_ranks createMany
   */
  export type guild_ranksCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guild_ranks.
     */
    data: Enumerable<guild_ranksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * guild_ranks update
   */
  export type guild_ranksUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_ranks
     */
    select?: guild_ranksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_ranksInclude<ExtArgs> | null
    /**
     * The data needed to update a guild_ranks.
     */
    data: XOR<guild_ranksUpdateInput, guild_ranksUncheckedUpdateInput>
    /**
     * Choose, which guild_ranks to update.
     */
    where: guild_ranksWhereUniqueInput
  }


  /**
   * guild_ranks updateMany
   */
  export type guild_ranksUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guild_ranks.
     */
    data: XOR<guild_ranksUpdateManyMutationInput, guild_ranksUncheckedUpdateManyInput>
    /**
     * Filter which guild_ranks to update
     */
    where?: guild_ranksWhereInput
  }


  /**
   * guild_ranks upsert
   */
  export type guild_ranksUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_ranks
     */
    select?: guild_ranksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_ranksInclude<ExtArgs> | null
    /**
     * The filter to search for the guild_ranks to update in case it exists.
     */
    where: guild_ranksWhereUniqueInput
    /**
     * In case the guild_ranks found by the `where` argument doesn't exist, create a new guild_ranks with this data.
     */
    create: XOR<guild_ranksCreateInput, guild_ranksUncheckedCreateInput>
    /**
     * In case the guild_ranks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guild_ranksUpdateInput, guild_ranksUncheckedUpdateInput>
  }


  /**
   * guild_ranks delete
   */
  export type guild_ranksDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_ranks
     */
    select?: guild_ranksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_ranksInclude<ExtArgs> | null
    /**
     * Filter which guild_ranks to delete.
     */
    where: guild_ranksWhereUniqueInput
  }


  /**
   * guild_ranks deleteMany
   */
  export type guild_ranksDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which guild_ranks to delete
     */
    where?: guild_ranksWhereInput
  }


  /**
   * guild_ranks.guild_membership
   */
  export type guild_ranks$guild_membershipArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_membership
     */
    select?: guild_membershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_membershipInclude<ExtArgs> | null
    where?: guild_membershipWhereInput
    orderBy?: Enumerable<guild_membershipOrderByWithRelationInput>
    cursor?: guild_membershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Guild_membershipScalarFieldEnum>
  }


  /**
   * guild_ranks without action
   */
  export type guild_ranksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_ranks
     */
    select?: guild_ranksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_ranksInclude<ExtArgs> | null
  }



  /**
   * Model guild_wars
   */


  export type AggregateGuild_wars = {
    _count: Guild_warsCountAggregateOutputType | null
    _avg: Guild_warsAvgAggregateOutputType | null
    _sum: Guild_warsSumAggregateOutputType | null
    _min: Guild_warsMinAggregateOutputType | null
    _max: Guild_warsMaxAggregateOutputType | null
  }

  export type Guild_warsAvgAggregateOutputType = {
    id: number | null
    guild1: number | null
    guild2: number | null
    status: number | null
    started: number | null
    ended: number | null
  }

  export type Guild_warsSumAggregateOutputType = {
    id: number | null
    guild1: number | null
    guild2: number | null
    status: number | null
    started: bigint | null
    ended: bigint | null
  }

  export type Guild_warsMinAggregateOutputType = {
    id: number | null
    guild1: number | null
    guild2: number | null
    name1: string | null
    name2: string | null
    status: number | null
    started: bigint | null
    ended: bigint | null
  }

  export type Guild_warsMaxAggregateOutputType = {
    id: number | null
    guild1: number | null
    guild2: number | null
    name1: string | null
    name2: string | null
    status: number | null
    started: bigint | null
    ended: bigint | null
  }

  export type Guild_warsCountAggregateOutputType = {
    id: number
    guild1: number
    guild2: number
    name1: number
    name2: number
    status: number
    started: number
    ended: number
    _all: number
  }


  export type Guild_warsAvgAggregateInputType = {
    id?: true
    guild1?: true
    guild2?: true
    status?: true
    started?: true
    ended?: true
  }

  export type Guild_warsSumAggregateInputType = {
    id?: true
    guild1?: true
    guild2?: true
    status?: true
    started?: true
    ended?: true
  }

  export type Guild_warsMinAggregateInputType = {
    id?: true
    guild1?: true
    guild2?: true
    name1?: true
    name2?: true
    status?: true
    started?: true
    ended?: true
  }

  export type Guild_warsMaxAggregateInputType = {
    id?: true
    guild1?: true
    guild2?: true
    name1?: true
    name2?: true
    status?: true
    started?: true
    ended?: true
  }

  export type Guild_warsCountAggregateInputType = {
    id?: true
    guild1?: true
    guild2?: true
    name1?: true
    name2?: true
    status?: true
    started?: true
    ended?: true
    _all?: true
  }

  export type Guild_warsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which guild_wars to aggregate.
     */
    where?: guild_warsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_wars to fetch.
     */
    orderBy?: Enumerable<guild_warsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guild_warsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_wars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_wars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guild_wars
    **/
    _count?: true | Guild_warsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Guild_warsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Guild_warsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Guild_warsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Guild_warsMaxAggregateInputType
  }

  export type GetGuild_warsAggregateType<T extends Guild_warsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuild_wars]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuild_wars[P]>
      : GetScalarType<T[P], AggregateGuild_wars[P]>
  }




  export type Guild_warsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: guild_warsWhereInput
    orderBy?: Enumerable<guild_warsOrderByWithAggregationInput>
    by: Guild_warsScalarFieldEnum[]
    having?: guild_warsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Guild_warsCountAggregateInputType | true
    _avg?: Guild_warsAvgAggregateInputType
    _sum?: Guild_warsSumAggregateInputType
    _min?: Guild_warsMinAggregateInputType
    _max?: Guild_warsMaxAggregateInputType
  }


  export type Guild_warsGroupByOutputType = {
    id: number
    guild1: number
    guild2: number
    name1: string
    name2: string
    status: number
    started: bigint
    ended: bigint
    _count: Guild_warsCountAggregateOutputType | null
    _avg: Guild_warsAvgAggregateOutputType | null
    _sum: Guild_warsSumAggregateOutputType | null
    _min: Guild_warsMinAggregateOutputType | null
    _max: Guild_warsMaxAggregateOutputType | null
  }

  type GetGuild_warsGroupByPayload<T extends Guild_warsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Guild_warsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Guild_warsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Guild_warsGroupByOutputType[P]>
            : GetScalarType<T[P], Guild_warsGroupByOutputType[P]>
        }
      >
    >


  export type guild_warsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guild1?: boolean
    guild2?: boolean
    name1?: boolean
    name2?: boolean
    status?: boolean
    started?: boolean
    ended?: boolean
    guildwar_kills?: boolean | guild_wars$guildwar_killsArgs<ExtArgs>
    _count?: boolean | Guild_warsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["guild_wars"]>

  export type guild_warsSelectScalar = {
    id?: boolean
    guild1?: boolean
    guild2?: boolean
    name1?: boolean
    name2?: boolean
    status?: boolean
    started?: boolean
    ended?: boolean
  }

  export type guild_warsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    guildwar_kills?: boolean | guild_wars$guildwar_killsArgs<ExtArgs>
    _count?: boolean | Guild_warsCountOutputTypeArgs<ExtArgs>
  }


  type guild_warsGetPayload<S extends boolean | null | undefined | guild_warsArgs> = $Types.GetResult<guild_warsPayload, S>

  type guild_warsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<guild_warsFindManyArgs, 'select' | 'include'> & {
      select?: Guild_warsCountAggregateInputType | true
    }

  export interface guild_warsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guild_wars'], meta: { name: 'guild_wars' } }
    /**
     * Find zero or one Guild_wars that matches the filter.
     * @param {guild_warsFindUniqueArgs} args - Arguments to find a Guild_wars
     * @example
     * // Get one Guild_wars
     * const guild_wars = await prisma.guild_wars.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends guild_warsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, guild_warsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'guild_wars'> extends True ? Prisma__guild_warsClient<$Types.GetResult<guild_warsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__guild_warsClient<$Types.GetResult<guild_warsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Guild_wars that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {guild_warsFindUniqueOrThrowArgs} args - Arguments to find a Guild_wars
     * @example
     * // Get one Guild_wars
     * const guild_wars = await prisma.guild_wars.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends guild_warsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_warsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__guild_warsClient<$Types.GetResult<guild_warsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Guild_wars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_warsFindFirstArgs} args - Arguments to find a Guild_wars
     * @example
     * // Get one Guild_wars
     * const guild_wars = await prisma.guild_wars.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends guild_warsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, guild_warsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'guild_wars'> extends True ? Prisma__guild_warsClient<$Types.GetResult<guild_warsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__guild_warsClient<$Types.GetResult<guild_warsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Guild_wars that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_warsFindFirstOrThrowArgs} args - Arguments to find a Guild_wars
     * @example
     * // Get one Guild_wars
     * const guild_wars = await prisma.guild_wars.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends guild_warsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_warsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__guild_warsClient<$Types.GetResult<guild_warsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Guild_wars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_warsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guild_wars
     * const guild_wars = await prisma.guild_wars.findMany()
     * 
     * // Get first 10 Guild_wars
     * const guild_wars = await prisma.guild_wars.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guild_warsWithIdOnly = await prisma.guild_wars.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends guild_warsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_warsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<guild_warsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Guild_wars.
     * @param {guild_warsCreateArgs} args - Arguments to create a Guild_wars.
     * @example
     * // Create one Guild_wars
     * const Guild_wars = await prisma.guild_wars.create({
     *   data: {
     *     // ... data to create a Guild_wars
     *   }
     * })
     * 
    **/
    create<T extends guild_warsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, guild_warsCreateArgs<ExtArgs>>
    ): Prisma__guild_warsClient<$Types.GetResult<guild_warsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Guild_wars.
     *     @param {guild_warsCreateManyArgs} args - Arguments to create many Guild_wars.
     *     @example
     *     // Create many Guild_wars
     *     const guild_wars = await prisma.guild_wars.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends guild_warsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_warsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guild_wars.
     * @param {guild_warsDeleteArgs} args - Arguments to delete one Guild_wars.
     * @example
     * // Delete one Guild_wars
     * const Guild_wars = await prisma.guild_wars.delete({
     *   where: {
     *     // ... filter to delete one Guild_wars
     *   }
     * })
     * 
    **/
    delete<T extends guild_warsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, guild_warsDeleteArgs<ExtArgs>>
    ): Prisma__guild_warsClient<$Types.GetResult<guild_warsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Guild_wars.
     * @param {guild_warsUpdateArgs} args - Arguments to update one Guild_wars.
     * @example
     * // Update one Guild_wars
     * const guild_wars = await prisma.guild_wars.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends guild_warsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, guild_warsUpdateArgs<ExtArgs>>
    ): Prisma__guild_warsClient<$Types.GetResult<guild_warsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Guild_wars.
     * @param {guild_warsDeleteManyArgs} args - Arguments to filter Guild_wars to delete.
     * @example
     * // Delete a few Guild_wars
     * const { count } = await prisma.guild_wars.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends guild_warsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guild_warsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guild_wars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_warsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guild_wars
     * const guild_wars = await prisma.guild_wars.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends guild_warsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, guild_warsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guild_wars.
     * @param {guild_warsUpsertArgs} args - Arguments to update or create a Guild_wars.
     * @example
     * // Update or create a Guild_wars
     * const guild_wars = await prisma.guild_wars.upsert({
     *   create: {
     *     // ... data to create a Guild_wars
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guild_wars we want to update
     *   }
     * })
    **/
    upsert<T extends guild_warsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, guild_warsUpsertArgs<ExtArgs>>
    ): Prisma__guild_warsClient<$Types.GetResult<guild_warsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Guild_wars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guild_warsCountArgs} args - Arguments to filter Guild_wars to count.
     * @example
     * // Count the number of Guild_wars
     * const count = await prisma.guild_wars.count({
     *   where: {
     *     // ... the filter for the Guild_wars we want to count
     *   }
     * })
    **/
    count<T extends guild_warsCountArgs>(
      args?: Subset<T, guild_warsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Guild_warsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guild_wars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Guild_warsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Guild_warsAggregateArgs>(args: Subset<T, Guild_warsAggregateArgs>): Prisma.PrismaPromise<GetGuild_warsAggregateType<T>>

    /**
     * Group by Guild_wars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Guild_warsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Guild_warsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Guild_warsGroupByArgs['orderBy'] }
        : { orderBy?: Guild_warsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Guild_warsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuild_warsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for guild_wars.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__guild_warsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    guildwar_kills<T extends guild_wars$guildwar_killsArgs<ExtArgs> = {}>(args?: Subset<T, guild_wars$guildwar_killsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<guildwar_killsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * guild_wars base type for findUnique actions
   */
  export type guild_warsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_wars
     */
    select?: guild_warsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_warsInclude<ExtArgs> | null
    /**
     * Filter, which guild_wars to fetch.
     */
    where: guild_warsWhereUniqueInput
  }

  /**
   * guild_wars findUnique
   */
  export interface guild_warsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends guild_warsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * guild_wars findUniqueOrThrow
   */
  export type guild_warsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_wars
     */
    select?: guild_warsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_warsInclude<ExtArgs> | null
    /**
     * Filter, which guild_wars to fetch.
     */
    where: guild_warsWhereUniqueInput
  }


  /**
   * guild_wars base type for findFirst actions
   */
  export type guild_warsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_wars
     */
    select?: guild_warsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_warsInclude<ExtArgs> | null
    /**
     * Filter, which guild_wars to fetch.
     */
    where?: guild_warsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_wars to fetch.
     */
    orderBy?: Enumerable<guild_warsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guild_wars.
     */
    cursor?: guild_warsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_wars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_wars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guild_wars.
     */
    distinct?: Enumerable<Guild_warsScalarFieldEnum>
  }

  /**
   * guild_wars findFirst
   */
  export interface guild_warsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends guild_warsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * guild_wars findFirstOrThrow
   */
  export type guild_warsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_wars
     */
    select?: guild_warsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_warsInclude<ExtArgs> | null
    /**
     * Filter, which guild_wars to fetch.
     */
    where?: guild_warsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_wars to fetch.
     */
    orderBy?: Enumerable<guild_warsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guild_wars.
     */
    cursor?: guild_warsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_wars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_wars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guild_wars.
     */
    distinct?: Enumerable<Guild_warsScalarFieldEnum>
  }


  /**
   * guild_wars findMany
   */
  export type guild_warsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_wars
     */
    select?: guild_warsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_warsInclude<ExtArgs> | null
    /**
     * Filter, which guild_wars to fetch.
     */
    where?: guild_warsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guild_wars to fetch.
     */
    orderBy?: Enumerable<guild_warsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guild_wars.
     */
    cursor?: guild_warsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guild_wars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guild_wars.
     */
    skip?: number
    distinct?: Enumerable<Guild_warsScalarFieldEnum>
  }


  /**
   * guild_wars create
   */
  export type guild_warsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_wars
     */
    select?: guild_warsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_warsInclude<ExtArgs> | null
    /**
     * The data needed to create a guild_wars.
     */
    data: XOR<guild_warsCreateInput, guild_warsUncheckedCreateInput>
  }


  /**
   * guild_wars createMany
   */
  export type guild_warsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guild_wars.
     */
    data: Enumerable<guild_warsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * guild_wars update
   */
  export type guild_warsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_wars
     */
    select?: guild_warsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_warsInclude<ExtArgs> | null
    /**
     * The data needed to update a guild_wars.
     */
    data: XOR<guild_warsUpdateInput, guild_warsUncheckedUpdateInput>
    /**
     * Choose, which guild_wars to update.
     */
    where: guild_warsWhereUniqueInput
  }


  /**
   * guild_wars updateMany
   */
  export type guild_warsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guild_wars.
     */
    data: XOR<guild_warsUpdateManyMutationInput, guild_warsUncheckedUpdateManyInput>
    /**
     * Filter which guild_wars to update
     */
    where?: guild_warsWhereInput
  }


  /**
   * guild_wars upsert
   */
  export type guild_warsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_wars
     */
    select?: guild_warsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_warsInclude<ExtArgs> | null
    /**
     * The filter to search for the guild_wars to update in case it exists.
     */
    where: guild_warsWhereUniqueInput
    /**
     * In case the guild_wars found by the `where` argument doesn't exist, create a new guild_wars with this data.
     */
    create: XOR<guild_warsCreateInput, guild_warsUncheckedCreateInput>
    /**
     * In case the guild_wars was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guild_warsUpdateInput, guild_warsUncheckedUpdateInput>
  }


  /**
   * guild_wars delete
   */
  export type guild_warsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_wars
     */
    select?: guild_warsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_warsInclude<ExtArgs> | null
    /**
     * Filter which guild_wars to delete.
     */
    where: guild_warsWhereUniqueInput
  }


  /**
   * guild_wars deleteMany
   */
  export type guild_warsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which guild_wars to delete
     */
    where?: guild_warsWhereInput
  }


  /**
   * guild_wars.guildwar_kills
   */
  export type guild_wars$guildwar_killsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildwar_kills
     */
    select?: guildwar_killsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildwar_killsInclude<ExtArgs> | null
    where?: guildwar_killsWhereInput
    orderBy?: Enumerable<guildwar_killsOrderByWithRelationInput>
    cursor?: guildwar_killsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Guildwar_killsScalarFieldEnum>
  }


  /**
   * guild_wars without action
   */
  export type guild_warsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_wars
     */
    select?: guild_warsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_warsInclude<ExtArgs> | null
  }



  /**
   * Model guilds
   */


  export type AggregateGuilds = {
    _count: GuildsCountAggregateOutputType | null
    _avg: GuildsAvgAggregateOutputType | null
    _sum: GuildsSumAggregateOutputType | null
    _min: GuildsMinAggregateOutputType | null
    _max: GuildsMaxAggregateOutputType | null
  }

  export type GuildsAvgAggregateOutputType = {
    id: number | null
    ownerid: number | null
    creationdata: number | null
  }

  export type GuildsSumAggregateOutputType = {
    id: number | null
    ownerid: number | null
    creationdata: number | null
  }

  export type GuildsMinAggregateOutputType = {
    id: number | null
    name: string | null
    ownerid: number | null
    creationdata: number | null
    motd: string | null
  }

  export type GuildsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    ownerid: number | null
    creationdata: number | null
    motd: string | null
  }

  export type GuildsCountAggregateOutputType = {
    id: number
    name: number
    ownerid: number
    creationdata: number
    motd: number
    _all: number
  }


  export type GuildsAvgAggregateInputType = {
    id?: true
    ownerid?: true
    creationdata?: true
  }

  export type GuildsSumAggregateInputType = {
    id?: true
    ownerid?: true
    creationdata?: true
  }

  export type GuildsMinAggregateInputType = {
    id?: true
    name?: true
    ownerid?: true
    creationdata?: true
    motd?: true
  }

  export type GuildsMaxAggregateInputType = {
    id?: true
    name?: true
    ownerid?: true
    creationdata?: true
    motd?: true
  }

  export type GuildsCountAggregateInputType = {
    id?: true
    name?: true
    ownerid?: true
    creationdata?: true
    motd?: true
    _all?: true
  }

  export type GuildsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which guilds to aggregate.
     */
    where?: guildsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guilds to fetch.
     */
    orderBy?: Enumerable<guildsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guilds
    **/
    _count?: true | GuildsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuildsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuildsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuildsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuildsMaxAggregateInputType
  }

  export type GetGuildsAggregateType<T extends GuildsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuilds]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuilds[P]>
      : GetScalarType<T[P], AggregateGuilds[P]>
  }




  export type GuildsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: guildsWhereInput
    orderBy?: Enumerable<guildsOrderByWithAggregationInput>
    by: GuildsScalarFieldEnum[]
    having?: guildsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuildsCountAggregateInputType | true
    _avg?: GuildsAvgAggregateInputType
    _sum?: GuildsSumAggregateInputType
    _min?: GuildsMinAggregateInputType
    _max?: GuildsMaxAggregateInputType
  }


  export type GuildsGroupByOutputType = {
    id: number
    name: string
    ownerid: number
    creationdata: number
    motd: string
    _count: GuildsCountAggregateOutputType | null
    _avg: GuildsAvgAggregateOutputType | null
    _sum: GuildsSumAggregateOutputType | null
    _min: GuildsMinAggregateOutputType | null
    _max: GuildsMaxAggregateOutputType | null
  }

  type GetGuildsGroupByPayload<T extends GuildsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GuildsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuildsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuildsGroupByOutputType[P]>
            : GetScalarType<T[P], GuildsGroupByOutputType[P]>
        }
      >
    >


  export type guildsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerid?: boolean
    creationdata?: boolean
    motd?: boolean
    guild_invites?: boolean | guilds$guild_invitesArgs<ExtArgs>
    guild_membership?: boolean | guilds$guild_membershipArgs<ExtArgs>
    guild_ranks?: boolean | guilds$guild_ranksArgs<ExtArgs>
    players?: boolean | PlayerArgs<ExtArgs>
    _count?: boolean | GuildsCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["guilds"]>

  export type guildsSelectScalar = {
    id?: boolean
    name?: boolean
    ownerid?: boolean
    creationdata?: boolean
    motd?: boolean
  }

  export type guildsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    guild_invites?: boolean | guilds$guild_invitesArgs<ExtArgs>
    guild_membership?: boolean | guilds$guild_membershipArgs<ExtArgs>
    guild_ranks?: boolean | guilds$guild_ranksArgs<ExtArgs>
    players?: boolean | PlayerArgs<ExtArgs>
    _count?: boolean | GuildsCountOutputTypeArgs<ExtArgs>
  }


  type guildsGetPayload<S extends boolean | null | undefined | guildsArgs> = $Types.GetResult<guildsPayload, S>

  type guildsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<guildsFindManyArgs, 'select' | 'include'> & {
      select?: GuildsCountAggregateInputType | true
    }

  export interface guildsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guilds'], meta: { name: 'guilds' } }
    /**
     * Find zero or one Guilds that matches the filter.
     * @param {guildsFindUniqueArgs} args - Arguments to find a Guilds
     * @example
     * // Get one Guilds
     * const guilds = await prisma.guilds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends guildsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, guildsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'guilds'> extends True ? Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Guilds that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {guildsFindUniqueOrThrowArgs} args - Arguments to find a Guilds
     * @example
     * // Get one Guilds
     * const guilds = await prisma.guilds.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends guildsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, guildsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Guilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildsFindFirstArgs} args - Arguments to find a Guilds
     * @example
     * // Get one Guilds
     * const guilds = await prisma.guilds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends guildsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, guildsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'guilds'> extends True ? Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Guilds that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildsFindFirstOrThrowArgs} args - Arguments to find a Guilds
     * @example
     * // Get one Guilds
     * const guilds = await prisma.guilds.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends guildsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, guildsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Guilds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guilds
     * const guilds = await prisma.guilds.findMany()
     * 
     * // Get first 10 Guilds
     * const guilds = await prisma.guilds.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildsWithIdOnly = await prisma.guilds.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends guildsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guildsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<guildsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Guilds.
     * @param {guildsCreateArgs} args - Arguments to create a Guilds.
     * @example
     * // Create one Guilds
     * const Guilds = await prisma.guilds.create({
     *   data: {
     *     // ... data to create a Guilds
     *   }
     * })
     * 
    **/
    create<T extends guildsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, guildsCreateArgs<ExtArgs>>
    ): Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Guilds.
     *     @param {guildsCreateManyArgs} args - Arguments to create many Guilds.
     *     @example
     *     // Create many Guilds
     *     const guilds = await prisma.guilds.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends guildsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guildsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guilds.
     * @param {guildsDeleteArgs} args - Arguments to delete one Guilds.
     * @example
     * // Delete one Guilds
     * const Guilds = await prisma.guilds.delete({
     *   where: {
     *     // ... filter to delete one Guilds
     *   }
     * })
     * 
    **/
    delete<T extends guildsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, guildsDeleteArgs<ExtArgs>>
    ): Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Guilds.
     * @param {guildsUpdateArgs} args - Arguments to update one Guilds.
     * @example
     * // Update one Guilds
     * const guilds = await prisma.guilds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends guildsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, guildsUpdateArgs<ExtArgs>>
    ): Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Guilds.
     * @param {guildsDeleteManyArgs} args - Arguments to filter Guilds to delete.
     * @example
     * // Delete a few Guilds
     * const { count } = await prisma.guilds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends guildsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guildsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guilds
     * const guilds = await prisma.guilds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends guildsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, guildsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guilds.
     * @param {guildsUpsertArgs} args - Arguments to update or create a Guilds.
     * @example
     * // Update or create a Guilds
     * const guilds = await prisma.guilds.upsert({
     *   create: {
     *     // ... data to create a Guilds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guilds we want to update
     *   }
     * })
    **/
    upsert<T extends guildsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, guildsUpsertArgs<ExtArgs>>
    ): Prisma__guildsClient<$Types.GetResult<guildsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildsCountArgs} args - Arguments to filter Guilds to count.
     * @example
     * // Count the number of Guilds
     * const count = await prisma.guilds.count({
     *   where: {
     *     // ... the filter for the Guilds we want to count
     *   }
     * })
    **/
    count<T extends guildsCountArgs>(
      args?: Subset<T, guildsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuildsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuildsAggregateArgs>(args: Subset<T, GuildsAggregateArgs>): Prisma.PrismaPromise<GetGuildsAggregateType<T>>

    /**
     * Group by Guilds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuildsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuildsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuildsGroupByArgs['orderBy'] }
        : { orderBy?: GuildsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuildsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for guilds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__guildsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    guild_invites<T extends guilds$guild_invitesArgs<ExtArgs> = {}>(args?: Subset<T, guilds$guild_invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<guild_invitesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    guild_membership<T extends guilds$guild_membershipArgs<ExtArgs> = {}>(args?: Subset<T, guilds$guild_membershipArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<guild_membershipPayload<ExtArgs>, T, 'findMany', never>| Null>;

    guild_ranks<T extends guilds$guild_ranksArgs<ExtArgs> = {}>(args?: Subset<T, guilds$guild_ranksArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<guild_ranksPayload<ExtArgs>, T, 'findMany', never>| Null>;

    players<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * guilds base type for findUnique actions
   */
  export type guildsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildsInclude<ExtArgs> | null
    /**
     * Filter, which guilds to fetch.
     */
    where: guildsWhereUniqueInput
  }

  /**
   * guilds findUnique
   */
  export interface guildsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends guildsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * guilds findUniqueOrThrow
   */
  export type guildsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildsInclude<ExtArgs> | null
    /**
     * Filter, which guilds to fetch.
     */
    where: guildsWhereUniqueInput
  }


  /**
   * guilds base type for findFirst actions
   */
  export type guildsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildsInclude<ExtArgs> | null
    /**
     * Filter, which guilds to fetch.
     */
    where?: guildsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guilds to fetch.
     */
    orderBy?: Enumerable<guildsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guilds.
     */
    cursor?: guildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guilds.
     */
    distinct?: Enumerable<GuildsScalarFieldEnum>
  }

  /**
   * guilds findFirst
   */
  export interface guildsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends guildsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * guilds findFirstOrThrow
   */
  export type guildsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildsInclude<ExtArgs> | null
    /**
     * Filter, which guilds to fetch.
     */
    where?: guildsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guilds to fetch.
     */
    orderBy?: Enumerable<guildsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guilds.
     */
    cursor?: guildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guilds.
     */
    distinct?: Enumerable<GuildsScalarFieldEnum>
  }


  /**
   * guilds findMany
   */
  export type guildsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildsInclude<ExtArgs> | null
    /**
     * Filter, which guilds to fetch.
     */
    where?: guildsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guilds to fetch.
     */
    orderBy?: Enumerable<guildsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guilds.
     */
    cursor?: guildsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guilds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guilds.
     */
    skip?: number
    distinct?: Enumerable<GuildsScalarFieldEnum>
  }


  /**
   * guilds create
   */
  export type guildsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildsInclude<ExtArgs> | null
    /**
     * The data needed to create a guilds.
     */
    data: XOR<guildsCreateInput, guildsUncheckedCreateInput>
  }


  /**
   * guilds createMany
   */
  export type guildsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guilds.
     */
    data: Enumerable<guildsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * guilds update
   */
  export type guildsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildsInclude<ExtArgs> | null
    /**
     * The data needed to update a guilds.
     */
    data: XOR<guildsUpdateInput, guildsUncheckedUpdateInput>
    /**
     * Choose, which guilds to update.
     */
    where: guildsWhereUniqueInput
  }


  /**
   * guilds updateMany
   */
  export type guildsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guilds.
     */
    data: XOR<guildsUpdateManyMutationInput, guildsUncheckedUpdateManyInput>
    /**
     * Filter which guilds to update
     */
    where?: guildsWhereInput
  }


  /**
   * guilds upsert
   */
  export type guildsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildsInclude<ExtArgs> | null
    /**
     * The filter to search for the guilds to update in case it exists.
     */
    where: guildsWhereUniqueInput
    /**
     * In case the guilds found by the `where` argument doesn't exist, create a new guilds with this data.
     */
    create: XOR<guildsCreateInput, guildsUncheckedCreateInput>
    /**
     * In case the guilds was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guildsUpdateInput, guildsUncheckedUpdateInput>
  }


  /**
   * guilds delete
   */
  export type guildsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildsInclude<ExtArgs> | null
    /**
     * Filter which guilds to delete.
     */
    where: guildsWhereUniqueInput
  }


  /**
   * guilds deleteMany
   */
  export type guildsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which guilds to delete
     */
    where?: guildsWhereInput
  }


  /**
   * guilds.guild_invites
   */
  export type guilds$guild_invitesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_invites
     */
    select?: guild_invitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_invitesInclude<ExtArgs> | null
    where?: guild_invitesWhereInput
    orderBy?: Enumerable<guild_invitesOrderByWithRelationInput>
    cursor?: guild_invitesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Guild_invitesScalarFieldEnum>
  }


  /**
   * guilds.guild_membership
   */
  export type guilds$guild_membershipArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_membership
     */
    select?: guild_membershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_membershipInclude<ExtArgs> | null
    where?: guild_membershipWhereInput
    orderBy?: Enumerable<guild_membershipOrderByWithRelationInput>
    cursor?: guild_membershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Guild_membershipScalarFieldEnum>
  }


  /**
   * guilds.guild_ranks
   */
  export type guilds$guild_ranksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guild_ranks
     */
    select?: guild_ranksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guild_ranksInclude<ExtArgs> | null
    where?: guild_ranksWhereInput
    orderBy?: Enumerable<guild_ranksOrderByWithRelationInput>
    cursor?: guild_ranksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Guild_ranksScalarFieldEnum>
  }


  /**
   * guilds without action
   */
  export type guildsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guilds
     */
    select?: guildsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildsInclude<ExtArgs> | null
  }



  /**
   * Model guildwar_kills
   */


  export type AggregateGuildwar_kills = {
    _count: Guildwar_killsCountAggregateOutputType | null
    _avg: Guildwar_killsAvgAggregateOutputType | null
    _sum: Guildwar_killsSumAggregateOutputType | null
    _min: Guildwar_killsMinAggregateOutputType | null
    _max: Guildwar_killsMaxAggregateOutputType | null
  }

  export type Guildwar_killsAvgAggregateOutputType = {
    id: number | null
    killerguild: number | null
    targetguild: number | null
    warid: number | null
    time: number | null
  }

  export type Guildwar_killsSumAggregateOutputType = {
    id: number | null
    killerguild: number | null
    targetguild: number | null
    warid: number | null
    time: bigint | null
  }

  export type Guildwar_killsMinAggregateOutputType = {
    id: number | null
    killer: string | null
    target: string | null
    killerguild: number | null
    targetguild: number | null
    warid: number | null
    time: bigint | null
  }

  export type Guildwar_killsMaxAggregateOutputType = {
    id: number | null
    killer: string | null
    target: string | null
    killerguild: number | null
    targetguild: number | null
    warid: number | null
    time: bigint | null
  }

  export type Guildwar_killsCountAggregateOutputType = {
    id: number
    killer: number
    target: number
    killerguild: number
    targetguild: number
    warid: number
    time: number
    _all: number
  }


  export type Guildwar_killsAvgAggregateInputType = {
    id?: true
    killerguild?: true
    targetguild?: true
    warid?: true
    time?: true
  }

  export type Guildwar_killsSumAggregateInputType = {
    id?: true
    killerguild?: true
    targetguild?: true
    warid?: true
    time?: true
  }

  export type Guildwar_killsMinAggregateInputType = {
    id?: true
    killer?: true
    target?: true
    killerguild?: true
    targetguild?: true
    warid?: true
    time?: true
  }

  export type Guildwar_killsMaxAggregateInputType = {
    id?: true
    killer?: true
    target?: true
    killerguild?: true
    targetguild?: true
    warid?: true
    time?: true
  }

  export type Guildwar_killsCountAggregateInputType = {
    id?: true
    killer?: true
    target?: true
    killerguild?: true
    targetguild?: true
    warid?: true
    time?: true
    _all?: true
  }

  export type Guildwar_killsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which guildwar_kills to aggregate.
     */
    where?: guildwar_killsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildwar_kills to fetch.
     */
    orderBy?: Enumerable<guildwar_killsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guildwar_killsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildwar_kills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildwar_kills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guildwar_kills
    **/
    _count?: true | Guildwar_killsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Guildwar_killsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Guildwar_killsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Guildwar_killsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Guildwar_killsMaxAggregateInputType
  }

  export type GetGuildwar_killsAggregateType<T extends Guildwar_killsAggregateArgs> = {
        [P in keyof T & keyof AggregateGuildwar_kills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuildwar_kills[P]>
      : GetScalarType<T[P], AggregateGuildwar_kills[P]>
  }




  export type Guildwar_killsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: guildwar_killsWhereInput
    orderBy?: Enumerable<guildwar_killsOrderByWithAggregationInput>
    by: Guildwar_killsScalarFieldEnum[]
    having?: guildwar_killsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Guildwar_killsCountAggregateInputType | true
    _avg?: Guildwar_killsAvgAggregateInputType
    _sum?: Guildwar_killsSumAggregateInputType
    _min?: Guildwar_killsMinAggregateInputType
    _max?: Guildwar_killsMaxAggregateInputType
  }


  export type Guildwar_killsGroupByOutputType = {
    id: number
    killer: string
    target: string
    killerguild: number
    targetguild: number
    warid: number
    time: bigint
    _count: Guildwar_killsCountAggregateOutputType | null
    _avg: Guildwar_killsAvgAggregateOutputType | null
    _sum: Guildwar_killsSumAggregateOutputType | null
    _min: Guildwar_killsMinAggregateOutputType | null
    _max: Guildwar_killsMaxAggregateOutputType | null
  }

  type GetGuildwar_killsGroupByPayload<T extends Guildwar_killsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Guildwar_killsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Guildwar_killsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Guildwar_killsGroupByOutputType[P]>
            : GetScalarType<T[P], Guildwar_killsGroupByOutputType[P]>
        }
      >
    >


  export type guildwar_killsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    killer?: boolean
    target?: boolean
    killerguild?: boolean
    targetguild?: boolean
    warid?: boolean
    time?: boolean
    guild_wars?: boolean | guild_warsArgs<ExtArgs>
  }, ExtArgs["result"]["guildwar_kills"]>

  export type guildwar_killsSelectScalar = {
    id?: boolean
    killer?: boolean
    target?: boolean
    killerguild?: boolean
    targetguild?: boolean
    warid?: boolean
    time?: boolean
  }

  export type guildwar_killsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    guild_wars?: boolean | guild_warsArgs<ExtArgs>
  }


  type guildwar_killsGetPayload<S extends boolean | null | undefined | guildwar_killsArgs> = $Types.GetResult<guildwar_killsPayload, S>

  type guildwar_killsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<guildwar_killsFindManyArgs, 'select' | 'include'> & {
      select?: Guildwar_killsCountAggregateInputType | true
    }

  export interface guildwar_killsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guildwar_kills'], meta: { name: 'guildwar_kills' } }
    /**
     * Find zero or one Guildwar_kills that matches the filter.
     * @param {guildwar_killsFindUniqueArgs} args - Arguments to find a Guildwar_kills
     * @example
     * // Get one Guildwar_kills
     * const guildwar_kills = await prisma.guildwar_kills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends guildwar_killsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, guildwar_killsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'guildwar_kills'> extends True ? Prisma__guildwar_killsClient<$Types.GetResult<guildwar_killsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__guildwar_killsClient<$Types.GetResult<guildwar_killsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Guildwar_kills that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {guildwar_killsFindUniqueOrThrowArgs} args - Arguments to find a Guildwar_kills
     * @example
     * // Get one Guildwar_kills
     * const guildwar_kills = await prisma.guildwar_kills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends guildwar_killsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, guildwar_killsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__guildwar_killsClient<$Types.GetResult<guildwar_killsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Guildwar_kills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildwar_killsFindFirstArgs} args - Arguments to find a Guildwar_kills
     * @example
     * // Get one Guildwar_kills
     * const guildwar_kills = await prisma.guildwar_kills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends guildwar_killsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, guildwar_killsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'guildwar_kills'> extends True ? Prisma__guildwar_killsClient<$Types.GetResult<guildwar_killsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__guildwar_killsClient<$Types.GetResult<guildwar_killsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Guildwar_kills that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildwar_killsFindFirstOrThrowArgs} args - Arguments to find a Guildwar_kills
     * @example
     * // Get one Guildwar_kills
     * const guildwar_kills = await prisma.guildwar_kills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends guildwar_killsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, guildwar_killsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__guildwar_killsClient<$Types.GetResult<guildwar_killsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Guildwar_kills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildwar_killsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guildwar_kills
     * const guildwar_kills = await prisma.guildwar_kills.findMany()
     * 
     * // Get first 10 Guildwar_kills
     * const guildwar_kills = await prisma.guildwar_kills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guildwar_killsWithIdOnly = await prisma.guildwar_kills.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends guildwar_killsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guildwar_killsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<guildwar_killsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Guildwar_kills.
     * @param {guildwar_killsCreateArgs} args - Arguments to create a Guildwar_kills.
     * @example
     * // Create one Guildwar_kills
     * const Guildwar_kills = await prisma.guildwar_kills.create({
     *   data: {
     *     // ... data to create a Guildwar_kills
     *   }
     * })
     * 
    **/
    create<T extends guildwar_killsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, guildwar_killsCreateArgs<ExtArgs>>
    ): Prisma__guildwar_killsClient<$Types.GetResult<guildwar_killsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Guildwar_kills.
     *     @param {guildwar_killsCreateManyArgs} args - Arguments to create many Guildwar_kills.
     *     @example
     *     // Create many Guildwar_kills
     *     const guildwar_kills = await prisma.guildwar_kills.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends guildwar_killsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guildwar_killsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Guildwar_kills.
     * @param {guildwar_killsDeleteArgs} args - Arguments to delete one Guildwar_kills.
     * @example
     * // Delete one Guildwar_kills
     * const Guildwar_kills = await prisma.guildwar_kills.delete({
     *   where: {
     *     // ... filter to delete one Guildwar_kills
     *   }
     * })
     * 
    **/
    delete<T extends guildwar_killsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, guildwar_killsDeleteArgs<ExtArgs>>
    ): Prisma__guildwar_killsClient<$Types.GetResult<guildwar_killsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Guildwar_kills.
     * @param {guildwar_killsUpdateArgs} args - Arguments to update one Guildwar_kills.
     * @example
     * // Update one Guildwar_kills
     * const guildwar_kills = await prisma.guildwar_kills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends guildwar_killsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, guildwar_killsUpdateArgs<ExtArgs>>
    ): Prisma__guildwar_killsClient<$Types.GetResult<guildwar_killsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Guildwar_kills.
     * @param {guildwar_killsDeleteManyArgs} args - Arguments to filter Guildwar_kills to delete.
     * @example
     * // Delete a few Guildwar_kills
     * const { count } = await prisma.guildwar_kills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends guildwar_killsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, guildwar_killsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guildwar_kills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildwar_killsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guildwar_kills
     * const guildwar_kills = await prisma.guildwar_kills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends guildwar_killsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, guildwar_killsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Guildwar_kills.
     * @param {guildwar_killsUpsertArgs} args - Arguments to update or create a Guildwar_kills.
     * @example
     * // Update or create a Guildwar_kills
     * const guildwar_kills = await prisma.guildwar_kills.upsert({
     *   create: {
     *     // ... data to create a Guildwar_kills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guildwar_kills we want to update
     *   }
     * })
    **/
    upsert<T extends guildwar_killsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, guildwar_killsUpsertArgs<ExtArgs>>
    ): Prisma__guildwar_killsClient<$Types.GetResult<guildwar_killsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Guildwar_kills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guildwar_killsCountArgs} args - Arguments to filter Guildwar_kills to count.
     * @example
     * // Count the number of Guildwar_kills
     * const count = await prisma.guildwar_kills.count({
     *   where: {
     *     // ... the filter for the Guildwar_kills we want to count
     *   }
     * })
    **/
    count<T extends guildwar_killsCountArgs>(
      args?: Subset<T, guildwar_killsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Guildwar_killsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guildwar_kills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Guildwar_killsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Guildwar_killsAggregateArgs>(args: Subset<T, Guildwar_killsAggregateArgs>): Prisma.PrismaPromise<GetGuildwar_killsAggregateType<T>>

    /**
     * Group by Guildwar_kills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Guildwar_killsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Guildwar_killsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Guildwar_killsGroupByArgs['orderBy'] }
        : { orderBy?: Guildwar_killsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Guildwar_killsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuildwar_killsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for guildwar_kills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__guildwar_killsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    guild_wars<T extends guild_warsArgs<ExtArgs> = {}>(args?: Subset<T, guild_warsArgs<ExtArgs>>): Prisma__guild_warsClient<$Types.GetResult<guild_warsPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * guildwar_kills base type for findUnique actions
   */
  export type guildwar_killsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildwar_kills
     */
    select?: guildwar_killsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildwar_killsInclude<ExtArgs> | null
    /**
     * Filter, which guildwar_kills to fetch.
     */
    where: guildwar_killsWhereUniqueInput
  }

  /**
   * guildwar_kills findUnique
   */
  export interface guildwar_killsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends guildwar_killsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * guildwar_kills findUniqueOrThrow
   */
  export type guildwar_killsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildwar_kills
     */
    select?: guildwar_killsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildwar_killsInclude<ExtArgs> | null
    /**
     * Filter, which guildwar_kills to fetch.
     */
    where: guildwar_killsWhereUniqueInput
  }


  /**
   * guildwar_kills base type for findFirst actions
   */
  export type guildwar_killsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildwar_kills
     */
    select?: guildwar_killsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildwar_killsInclude<ExtArgs> | null
    /**
     * Filter, which guildwar_kills to fetch.
     */
    where?: guildwar_killsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildwar_kills to fetch.
     */
    orderBy?: Enumerable<guildwar_killsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guildwar_kills.
     */
    cursor?: guildwar_killsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildwar_kills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildwar_kills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guildwar_kills.
     */
    distinct?: Enumerable<Guildwar_killsScalarFieldEnum>
  }

  /**
   * guildwar_kills findFirst
   */
  export interface guildwar_killsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends guildwar_killsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * guildwar_kills findFirstOrThrow
   */
  export type guildwar_killsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildwar_kills
     */
    select?: guildwar_killsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildwar_killsInclude<ExtArgs> | null
    /**
     * Filter, which guildwar_kills to fetch.
     */
    where?: guildwar_killsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildwar_kills to fetch.
     */
    orderBy?: Enumerable<guildwar_killsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guildwar_kills.
     */
    cursor?: guildwar_killsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildwar_kills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildwar_kills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guildwar_kills.
     */
    distinct?: Enumerable<Guildwar_killsScalarFieldEnum>
  }


  /**
   * guildwar_kills findMany
   */
  export type guildwar_killsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildwar_kills
     */
    select?: guildwar_killsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildwar_killsInclude<ExtArgs> | null
    /**
     * Filter, which guildwar_kills to fetch.
     */
    where?: guildwar_killsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guildwar_kills to fetch.
     */
    orderBy?: Enumerable<guildwar_killsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guildwar_kills.
     */
    cursor?: guildwar_killsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guildwar_kills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guildwar_kills.
     */
    skip?: number
    distinct?: Enumerable<Guildwar_killsScalarFieldEnum>
  }


  /**
   * guildwar_kills create
   */
  export type guildwar_killsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildwar_kills
     */
    select?: guildwar_killsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildwar_killsInclude<ExtArgs> | null
    /**
     * The data needed to create a guildwar_kills.
     */
    data: XOR<guildwar_killsCreateInput, guildwar_killsUncheckedCreateInput>
  }


  /**
   * guildwar_kills createMany
   */
  export type guildwar_killsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guildwar_kills.
     */
    data: Enumerable<guildwar_killsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * guildwar_kills update
   */
  export type guildwar_killsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildwar_kills
     */
    select?: guildwar_killsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildwar_killsInclude<ExtArgs> | null
    /**
     * The data needed to update a guildwar_kills.
     */
    data: XOR<guildwar_killsUpdateInput, guildwar_killsUncheckedUpdateInput>
    /**
     * Choose, which guildwar_kills to update.
     */
    where: guildwar_killsWhereUniqueInput
  }


  /**
   * guildwar_kills updateMany
   */
  export type guildwar_killsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guildwar_kills.
     */
    data: XOR<guildwar_killsUpdateManyMutationInput, guildwar_killsUncheckedUpdateManyInput>
    /**
     * Filter which guildwar_kills to update
     */
    where?: guildwar_killsWhereInput
  }


  /**
   * guildwar_kills upsert
   */
  export type guildwar_killsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildwar_kills
     */
    select?: guildwar_killsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildwar_killsInclude<ExtArgs> | null
    /**
     * The filter to search for the guildwar_kills to update in case it exists.
     */
    where: guildwar_killsWhereUniqueInput
    /**
     * In case the guildwar_kills found by the `where` argument doesn't exist, create a new guildwar_kills with this data.
     */
    create: XOR<guildwar_killsCreateInput, guildwar_killsUncheckedCreateInput>
    /**
     * In case the guildwar_kills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guildwar_killsUpdateInput, guildwar_killsUncheckedUpdateInput>
  }


  /**
   * guildwar_kills delete
   */
  export type guildwar_killsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildwar_kills
     */
    select?: guildwar_killsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildwar_killsInclude<ExtArgs> | null
    /**
     * Filter which guildwar_kills to delete.
     */
    where: guildwar_killsWhereUniqueInput
  }


  /**
   * guildwar_kills deleteMany
   */
  export type guildwar_killsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which guildwar_kills to delete
     */
    where?: guildwar_killsWhereInput
  }


  /**
   * guildwar_kills without action
   */
  export type guildwar_killsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guildwar_kills
     */
    select?: guildwar_killsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: guildwar_killsInclude<ExtArgs> | null
  }



  /**
   * Model ip_bans
   */


  export type AggregateIp_bans = {
    _count: Ip_bansCountAggregateOutputType | null
    _avg: Ip_bansAvgAggregateOutputType | null
    _sum: Ip_bansSumAggregateOutputType | null
    _min: Ip_bansMinAggregateOutputType | null
    _max: Ip_bansMaxAggregateOutputType | null
  }

  export type Ip_bansAvgAggregateOutputType = {
    ip: number | null
    banned_at: number | null
    expires_at: number | null
    banned_by: number | null
  }

  export type Ip_bansSumAggregateOutputType = {
    ip: number | null
    banned_at: bigint | null
    expires_at: bigint | null
    banned_by: number | null
  }

  export type Ip_bansMinAggregateOutputType = {
    ip: number | null
    reason: string | null
    banned_at: bigint | null
    expires_at: bigint | null
    banned_by: number | null
  }

  export type Ip_bansMaxAggregateOutputType = {
    ip: number | null
    reason: string | null
    banned_at: bigint | null
    expires_at: bigint | null
    banned_by: number | null
  }

  export type Ip_bansCountAggregateOutputType = {
    ip: number
    reason: number
    banned_at: number
    expires_at: number
    banned_by: number
    _all: number
  }


  export type Ip_bansAvgAggregateInputType = {
    ip?: true
    banned_at?: true
    expires_at?: true
    banned_by?: true
  }

  export type Ip_bansSumAggregateInputType = {
    ip?: true
    banned_at?: true
    expires_at?: true
    banned_by?: true
  }

  export type Ip_bansMinAggregateInputType = {
    ip?: true
    reason?: true
    banned_at?: true
    expires_at?: true
    banned_by?: true
  }

  export type Ip_bansMaxAggregateInputType = {
    ip?: true
    reason?: true
    banned_at?: true
    expires_at?: true
    banned_by?: true
  }

  export type Ip_bansCountAggregateInputType = {
    ip?: true
    reason?: true
    banned_at?: true
    expires_at?: true
    banned_by?: true
    _all?: true
  }

  export type Ip_bansAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ip_bans to aggregate.
     */
    where?: ip_bansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ip_bans to fetch.
     */
    orderBy?: Enumerable<ip_bansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ip_bansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ip_bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ip_bans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ip_bans
    **/
    _count?: true | Ip_bansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ip_bansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ip_bansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ip_bansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ip_bansMaxAggregateInputType
  }

  export type GetIp_bansAggregateType<T extends Ip_bansAggregateArgs> = {
        [P in keyof T & keyof AggregateIp_bans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIp_bans[P]>
      : GetScalarType<T[P], AggregateIp_bans[P]>
  }




  export type Ip_bansGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ip_bansWhereInput
    orderBy?: Enumerable<ip_bansOrderByWithAggregationInput>
    by: Ip_bansScalarFieldEnum[]
    having?: ip_bansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ip_bansCountAggregateInputType | true
    _avg?: Ip_bansAvgAggregateInputType
    _sum?: Ip_bansSumAggregateInputType
    _min?: Ip_bansMinAggregateInputType
    _max?: Ip_bansMaxAggregateInputType
  }


  export type Ip_bansGroupByOutputType = {
    ip: number
    reason: string
    banned_at: bigint
    expires_at: bigint
    banned_by: number
    _count: Ip_bansCountAggregateOutputType | null
    _avg: Ip_bansAvgAggregateOutputType | null
    _sum: Ip_bansSumAggregateOutputType | null
    _min: Ip_bansMinAggregateOutputType | null
    _max: Ip_bansMaxAggregateOutputType | null
  }

  type GetIp_bansGroupByPayload<T extends Ip_bansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Ip_bansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ip_bansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ip_bansGroupByOutputType[P]>
            : GetScalarType<T[P], Ip_bansGroupByOutputType[P]>
        }
      >
    >


  export type ip_bansSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ip?: boolean
    reason?: boolean
    banned_at?: boolean
    expires_at?: boolean
    banned_by?: boolean
    players?: boolean | PlayerArgs<ExtArgs>
  }, ExtArgs["result"]["ip_bans"]>

  export type ip_bansSelectScalar = {
    ip?: boolean
    reason?: boolean
    banned_at?: boolean
    expires_at?: boolean
    banned_by?: boolean
  }

  export type ip_bansInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    players?: boolean | PlayerArgs<ExtArgs>
  }


  type ip_bansGetPayload<S extends boolean | null | undefined | ip_bansArgs> = $Types.GetResult<ip_bansPayload, S>

  type ip_bansCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ip_bansFindManyArgs, 'select' | 'include'> & {
      select?: Ip_bansCountAggregateInputType | true
    }

  export interface ip_bansDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ip_bans'], meta: { name: 'ip_bans' } }
    /**
     * Find zero or one Ip_bans that matches the filter.
     * @param {ip_bansFindUniqueArgs} args - Arguments to find a Ip_bans
     * @example
     * // Get one Ip_bans
     * const ip_bans = await prisma.ip_bans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ip_bansFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ip_bansFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ip_bans'> extends True ? Prisma__ip_bansClient<$Types.GetResult<ip_bansPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ip_bansClient<$Types.GetResult<ip_bansPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Ip_bans that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ip_bansFindUniqueOrThrowArgs} args - Arguments to find a Ip_bans
     * @example
     * // Get one Ip_bans
     * const ip_bans = await prisma.ip_bans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ip_bansFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ip_bansFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ip_bansClient<$Types.GetResult<ip_bansPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Ip_bans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ip_bansFindFirstArgs} args - Arguments to find a Ip_bans
     * @example
     * // Get one Ip_bans
     * const ip_bans = await prisma.ip_bans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ip_bansFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ip_bansFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ip_bans'> extends True ? Prisma__ip_bansClient<$Types.GetResult<ip_bansPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ip_bansClient<$Types.GetResult<ip_bansPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Ip_bans that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ip_bansFindFirstOrThrowArgs} args - Arguments to find a Ip_bans
     * @example
     * // Get one Ip_bans
     * const ip_bans = await prisma.ip_bans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ip_bansFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ip_bansFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ip_bansClient<$Types.GetResult<ip_bansPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Ip_bans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ip_bansFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ip_bans
     * const ip_bans = await prisma.ip_bans.findMany()
     * 
     * // Get first 10 Ip_bans
     * const ip_bans = await prisma.ip_bans.findMany({ take: 10 })
     * 
     * // Only select the `ip`
     * const ip_bansWithIpOnly = await prisma.ip_bans.findMany({ select: { ip: true } })
     * 
    **/
    findMany<T extends ip_bansFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ip_bansFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ip_bansPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Ip_bans.
     * @param {ip_bansCreateArgs} args - Arguments to create a Ip_bans.
     * @example
     * // Create one Ip_bans
     * const Ip_bans = await prisma.ip_bans.create({
     *   data: {
     *     // ... data to create a Ip_bans
     *   }
     * })
     * 
    **/
    create<T extends ip_bansCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ip_bansCreateArgs<ExtArgs>>
    ): Prisma__ip_bansClient<$Types.GetResult<ip_bansPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Ip_bans.
     *     @param {ip_bansCreateManyArgs} args - Arguments to create many Ip_bans.
     *     @example
     *     // Create many Ip_bans
     *     const ip_bans = await prisma.ip_bans.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ip_bansCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ip_bansCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ip_bans.
     * @param {ip_bansDeleteArgs} args - Arguments to delete one Ip_bans.
     * @example
     * // Delete one Ip_bans
     * const Ip_bans = await prisma.ip_bans.delete({
     *   where: {
     *     // ... filter to delete one Ip_bans
     *   }
     * })
     * 
    **/
    delete<T extends ip_bansDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ip_bansDeleteArgs<ExtArgs>>
    ): Prisma__ip_bansClient<$Types.GetResult<ip_bansPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Ip_bans.
     * @param {ip_bansUpdateArgs} args - Arguments to update one Ip_bans.
     * @example
     * // Update one Ip_bans
     * const ip_bans = await prisma.ip_bans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ip_bansUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ip_bansUpdateArgs<ExtArgs>>
    ): Prisma__ip_bansClient<$Types.GetResult<ip_bansPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Ip_bans.
     * @param {ip_bansDeleteManyArgs} args - Arguments to filter Ip_bans to delete.
     * @example
     * // Delete a few Ip_bans
     * const { count } = await prisma.ip_bans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ip_bansDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ip_bansDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ip_bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ip_bansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ip_bans
     * const ip_bans = await prisma.ip_bans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ip_bansUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ip_bansUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ip_bans.
     * @param {ip_bansUpsertArgs} args - Arguments to update or create a Ip_bans.
     * @example
     * // Update or create a Ip_bans
     * const ip_bans = await prisma.ip_bans.upsert({
     *   create: {
     *     // ... data to create a Ip_bans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ip_bans we want to update
     *   }
     * })
    **/
    upsert<T extends ip_bansUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ip_bansUpsertArgs<ExtArgs>>
    ): Prisma__ip_bansClient<$Types.GetResult<ip_bansPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Ip_bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ip_bansCountArgs} args - Arguments to filter Ip_bans to count.
     * @example
     * // Count the number of Ip_bans
     * const count = await prisma.ip_bans.count({
     *   where: {
     *     // ... the filter for the Ip_bans we want to count
     *   }
     * })
    **/
    count<T extends ip_bansCountArgs>(
      args?: Subset<T, ip_bansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ip_bansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ip_bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ip_bansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ip_bansAggregateArgs>(args: Subset<T, Ip_bansAggregateArgs>): Prisma.PrismaPromise<GetIp_bansAggregateType<T>>

    /**
     * Group by Ip_bans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ip_bansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Ip_bansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Ip_bansGroupByArgs['orderBy'] }
        : { orderBy?: Ip_bansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Ip_bansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIp_bansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ip_bans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ip_bansClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    players<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ip_bans base type for findUnique actions
   */
  export type ip_bansFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ip_bans
     */
    select?: ip_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ip_bansInclude<ExtArgs> | null
    /**
     * Filter, which ip_bans to fetch.
     */
    where: ip_bansWhereUniqueInput
  }

  /**
   * ip_bans findUnique
   */
  export interface ip_bansFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ip_bansFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ip_bans findUniqueOrThrow
   */
  export type ip_bansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ip_bans
     */
    select?: ip_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ip_bansInclude<ExtArgs> | null
    /**
     * Filter, which ip_bans to fetch.
     */
    where: ip_bansWhereUniqueInput
  }


  /**
   * ip_bans base type for findFirst actions
   */
  export type ip_bansFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ip_bans
     */
    select?: ip_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ip_bansInclude<ExtArgs> | null
    /**
     * Filter, which ip_bans to fetch.
     */
    where?: ip_bansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ip_bans to fetch.
     */
    orderBy?: Enumerable<ip_bansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ip_bans.
     */
    cursor?: ip_bansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ip_bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ip_bans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ip_bans.
     */
    distinct?: Enumerable<Ip_bansScalarFieldEnum>
  }

  /**
   * ip_bans findFirst
   */
  export interface ip_bansFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ip_bansFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ip_bans findFirstOrThrow
   */
  export type ip_bansFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ip_bans
     */
    select?: ip_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ip_bansInclude<ExtArgs> | null
    /**
     * Filter, which ip_bans to fetch.
     */
    where?: ip_bansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ip_bans to fetch.
     */
    orderBy?: Enumerable<ip_bansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ip_bans.
     */
    cursor?: ip_bansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ip_bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ip_bans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ip_bans.
     */
    distinct?: Enumerable<Ip_bansScalarFieldEnum>
  }


  /**
   * ip_bans findMany
   */
  export type ip_bansFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ip_bans
     */
    select?: ip_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ip_bansInclude<ExtArgs> | null
    /**
     * Filter, which ip_bans to fetch.
     */
    where?: ip_bansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ip_bans to fetch.
     */
    orderBy?: Enumerable<ip_bansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ip_bans.
     */
    cursor?: ip_bansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ip_bans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ip_bans.
     */
    skip?: number
    distinct?: Enumerable<Ip_bansScalarFieldEnum>
  }


  /**
   * ip_bans create
   */
  export type ip_bansCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ip_bans
     */
    select?: ip_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ip_bansInclude<ExtArgs> | null
    /**
     * The data needed to create a ip_bans.
     */
    data: XOR<ip_bansCreateInput, ip_bansUncheckedCreateInput>
  }


  /**
   * ip_bans createMany
   */
  export type ip_bansCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ip_bans.
     */
    data: Enumerable<ip_bansCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ip_bans update
   */
  export type ip_bansUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ip_bans
     */
    select?: ip_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ip_bansInclude<ExtArgs> | null
    /**
     * The data needed to update a ip_bans.
     */
    data: XOR<ip_bansUpdateInput, ip_bansUncheckedUpdateInput>
    /**
     * Choose, which ip_bans to update.
     */
    where: ip_bansWhereUniqueInput
  }


  /**
   * ip_bans updateMany
   */
  export type ip_bansUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ip_bans.
     */
    data: XOR<ip_bansUpdateManyMutationInput, ip_bansUncheckedUpdateManyInput>
    /**
     * Filter which ip_bans to update
     */
    where?: ip_bansWhereInput
  }


  /**
   * ip_bans upsert
   */
  export type ip_bansUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ip_bans
     */
    select?: ip_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ip_bansInclude<ExtArgs> | null
    /**
     * The filter to search for the ip_bans to update in case it exists.
     */
    where: ip_bansWhereUniqueInput
    /**
     * In case the ip_bans found by the `where` argument doesn't exist, create a new ip_bans with this data.
     */
    create: XOR<ip_bansCreateInput, ip_bansUncheckedCreateInput>
    /**
     * In case the ip_bans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ip_bansUpdateInput, ip_bansUncheckedUpdateInput>
  }


  /**
   * ip_bans delete
   */
  export type ip_bansDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ip_bans
     */
    select?: ip_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ip_bansInclude<ExtArgs> | null
    /**
     * Filter which ip_bans to delete.
     */
    where: ip_bansWhereUniqueInput
  }


  /**
   * ip_bans deleteMany
   */
  export type ip_bansDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ip_bans to delete
     */
    where?: ip_bansWhereInput
  }


  /**
   * ip_bans without action
   */
  export type ip_bansArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ip_bans
     */
    select?: ip_bansSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ip_bansInclude<ExtArgs> | null
  }



  /**
   * Model market_history
   */


  export type AggregateMarket_history = {
    _count: Market_historyCountAggregateOutputType | null
    _avg: Market_historyAvgAggregateOutputType | null
    _sum: Market_historySumAggregateOutputType | null
    _min: Market_historyMinAggregateOutputType | null
    _max: Market_historyMaxAggregateOutputType | null
  }

  export type Market_historyAvgAggregateOutputType = {
    id: number | null
    player_id: number | null
    itemtype: number | null
    amount: number | null
    price: number | null
    expires_at: number | null
    inserted: number | null
    state: number | null
  }

  export type Market_historySumAggregateOutputType = {
    id: number | null
    player_id: number | null
    itemtype: number | null
    amount: number | null
    price: number | null
    expires_at: bigint | null
    inserted: bigint | null
    state: number | null
  }

  export type Market_historyMinAggregateOutputType = {
    id: number | null
    player_id: number | null
    sale: boolean | null
    itemtype: number | null
    amount: number | null
    price: number | null
    expires_at: bigint | null
    inserted: bigint | null
    state: number | null
  }

  export type Market_historyMaxAggregateOutputType = {
    id: number | null
    player_id: number | null
    sale: boolean | null
    itemtype: number | null
    amount: number | null
    price: number | null
    expires_at: bigint | null
    inserted: bigint | null
    state: number | null
  }

  export type Market_historyCountAggregateOutputType = {
    id: number
    player_id: number
    sale: number
    itemtype: number
    amount: number
    price: number
    expires_at: number
    inserted: number
    state: number
    _all: number
  }


  export type Market_historyAvgAggregateInputType = {
    id?: true
    player_id?: true
    itemtype?: true
    amount?: true
    price?: true
    expires_at?: true
    inserted?: true
    state?: true
  }

  export type Market_historySumAggregateInputType = {
    id?: true
    player_id?: true
    itemtype?: true
    amount?: true
    price?: true
    expires_at?: true
    inserted?: true
    state?: true
  }

  export type Market_historyMinAggregateInputType = {
    id?: true
    player_id?: true
    sale?: true
    itemtype?: true
    amount?: true
    price?: true
    expires_at?: true
    inserted?: true
    state?: true
  }

  export type Market_historyMaxAggregateInputType = {
    id?: true
    player_id?: true
    sale?: true
    itemtype?: true
    amount?: true
    price?: true
    expires_at?: true
    inserted?: true
    state?: true
  }

  export type Market_historyCountAggregateInputType = {
    id?: true
    player_id?: true
    sale?: true
    itemtype?: true
    amount?: true
    price?: true
    expires_at?: true
    inserted?: true
    state?: true
    _all?: true
  }

  export type Market_historyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which market_history to aggregate.
     */
    where?: market_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_histories to fetch.
     */
    orderBy?: Enumerable<market_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: market_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned market_histories
    **/
    _count?: true | Market_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Market_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Market_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Market_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Market_historyMaxAggregateInputType
  }

  export type GetMarket_historyAggregateType<T extends Market_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateMarket_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarket_history[P]>
      : GetScalarType<T[P], AggregateMarket_history[P]>
  }




  export type Market_historyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: market_historyWhereInput
    orderBy?: Enumerable<market_historyOrderByWithAggregationInput>
    by: Market_historyScalarFieldEnum[]
    having?: market_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Market_historyCountAggregateInputType | true
    _avg?: Market_historyAvgAggregateInputType
    _sum?: Market_historySumAggregateInputType
    _min?: Market_historyMinAggregateInputType
    _max?: Market_historyMaxAggregateInputType
  }


  export type Market_historyGroupByOutputType = {
    id: number
    player_id: number
    sale: boolean
    itemtype: number
    amount: number
    price: number
    expires_at: bigint
    inserted: bigint
    state: number
    _count: Market_historyCountAggregateOutputType | null
    _avg: Market_historyAvgAggregateOutputType | null
    _sum: Market_historySumAggregateOutputType | null
    _min: Market_historyMinAggregateOutputType | null
    _max: Market_historyMaxAggregateOutputType | null
  }

  type GetMarket_historyGroupByPayload<T extends Market_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Market_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Market_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Market_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Market_historyGroupByOutputType[P]>
        }
      >
    >


  export type market_historySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    sale?: boolean
    itemtype?: boolean
    amount?: boolean
    price?: boolean
    expires_at?: boolean
    inserted?: boolean
    state?: boolean
    players?: boolean | PlayerArgs<ExtArgs>
  }, ExtArgs["result"]["market_history"]>

  export type market_historySelectScalar = {
    id?: boolean
    player_id?: boolean
    sale?: boolean
    itemtype?: boolean
    amount?: boolean
    price?: boolean
    expires_at?: boolean
    inserted?: boolean
    state?: boolean
  }

  export type market_historyInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    players?: boolean | PlayerArgs<ExtArgs>
  }


  type market_historyGetPayload<S extends boolean | null | undefined | market_historyArgs> = $Types.GetResult<market_historyPayload, S>

  type market_historyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<market_historyFindManyArgs, 'select' | 'include'> & {
      select?: Market_historyCountAggregateInputType | true
    }

  export interface market_historyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['market_history'], meta: { name: 'market_history' } }
    /**
     * Find zero or one Market_history that matches the filter.
     * @param {market_historyFindUniqueArgs} args - Arguments to find a Market_history
     * @example
     * // Get one Market_history
     * const market_history = await prisma.market_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends market_historyFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, market_historyFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'market_history'> extends True ? Prisma__market_historyClient<$Types.GetResult<market_historyPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__market_historyClient<$Types.GetResult<market_historyPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Market_history that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {market_historyFindUniqueOrThrowArgs} args - Arguments to find a Market_history
     * @example
     * // Get one Market_history
     * const market_history = await prisma.market_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends market_historyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, market_historyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__market_historyClient<$Types.GetResult<market_historyPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Market_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_historyFindFirstArgs} args - Arguments to find a Market_history
     * @example
     * // Get one Market_history
     * const market_history = await prisma.market_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends market_historyFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, market_historyFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'market_history'> extends True ? Prisma__market_historyClient<$Types.GetResult<market_historyPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__market_historyClient<$Types.GetResult<market_historyPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Market_history that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_historyFindFirstOrThrowArgs} args - Arguments to find a Market_history
     * @example
     * // Get one Market_history
     * const market_history = await prisma.market_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends market_historyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, market_historyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__market_historyClient<$Types.GetResult<market_historyPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Market_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_historyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Market_histories
     * const market_histories = await prisma.market_history.findMany()
     * 
     * // Get first 10 Market_histories
     * const market_histories = await prisma.market_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const market_historyWithIdOnly = await prisma.market_history.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends market_historyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, market_historyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<market_historyPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Market_history.
     * @param {market_historyCreateArgs} args - Arguments to create a Market_history.
     * @example
     * // Create one Market_history
     * const Market_history = await prisma.market_history.create({
     *   data: {
     *     // ... data to create a Market_history
     *   }
     * })
     * 
    **/
    create<T extends market_historyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, market_historyCreateArgs<ExtArgs>>
    ): Prisma__market_historyClient<$Types.GetResult<market_historyPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Market_histories.
     *     @param {market_historyCreateManyArgs} args - Arguments to create many Market_histories.
     *     @example
     *     // Create many Market_histories
     *     const market_history = await prisma.market_history.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends market_historyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, market_historyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Market_history.
     * @param {market_historyDeleteArgs} args - Arguments to delete one Market_history.
     * @example
     * // Delete one Market_history
     * const Market_history = await prisma.market_history.delete({
     *   where: {
     *     // ... filter to delete one Market_history
     *   }
     * })
     * 
    **/
    delete<T extends market_historyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, market_historyDeleteArgs<ExtArgs>>
    ): Prisma__market_historyClient<$Types.GetResult<market_historyPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Market_history.
     * @param {market_historyUpdateArgs} args - Arguments to update one Market_history.
     * @example
     * // Update one Market_history
     * const market_history = await prisma.market_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends market_historyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, market_historyUpdateArgs<ExtArgs>>
    ): Prisma__market_historyClient<$Types.GetResult<market_historyPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Market_histories.
     * @param {market_historyDeleteManyArgs} args - Arguments to filter Market_histories to delete.
     * @example
     * // Delete a few Market_histories
     * const { count } = await prisma.market_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends market_historyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, market_historyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Market_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Market_histories
     * const market_history = await prisma.market_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends market_historyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, market_historyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Market_history.
     * @param {market_historyUpsertArgs} args - Arguments to update or create a Market_history.
     * @example
     * // Update or create a Market_history
     * const market_history = await prisma.market_history.upsert({
     *   create: {
     *     // ... data to create a Market_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Market_history we want to update
     *   }
     * })
    **/
    upsert<T extends market_historyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, market_historyUpsertArgs<ExtArgs>>
    ): Prisma__market_historyClient<$Types.GetResult<market_historyPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Market_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_historyCountArgs} args - Arguments to filter Market_histories to count.
     * @example
     * // Count the number of Market_histories
     * const count = await prisma.market_history.count({
     *   where: {
     *     // ... the filter for the Market_histories we want to count
     *   }
     * })
    **/
    count<T extends market_historyCountArgs>(
      args?: Subset<T, market_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Market_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Market_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Market_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Market_historyAggregateArgs>(args: Subset<T, Market_historyAggregateArgs>): Prisma.PrismaPromise<GetMarket_historyAggregateType<T>>

    /**
     * Group by Market_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Market_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Market_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Market_historyGroupByArgs['orderBy'] }
        : { orderBy?: Market_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Market_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarket_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for market_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__market_historyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    players<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * market_history base type for findUnique actions
   */
  export type market_historyFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_history
     */
    select?: market_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_historyInclude<ExtArgs> | null
    /**
     * Filter, which market_history to fetch.
     */
    where: market_historyWhereUniqueInput
  }

  /**
   * market_history findUnique
   */
  export interface market_historyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends market_historyFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * market_history findUniqueOrThrow
   */
  export type market_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_history
     */
    select?: market_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_historyInclude<ExtArgs> | null
    /**
     * Filter, which market_history to fetch.
     */
    where: market_historyWhereUniqueInput
  }


  /**
   * market_history base type for findFirst actions
   */
  export type market_historyFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_history
     */
    select?: market_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_historyInclude<ExtArgs> | null
    /**
     * Filter, which market_history to fetch.
     */
    where?: market_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_histories to fetch.
     */
    orderBy?: Enumerable<market_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for market_histories.
     */
    cursor?: market_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of market_histories.
     */
    distinct?: Enumerable<Market_historyScalarFieldEnum>
  }

  /**
   * market_history findFirst
   */
  export interface market_historyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends market_historyFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * market_history findFirstOrThrow
   */
  export type market_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_history
     */
    select?: market_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_historyInclude<ExtArgs> | null
    /**
     * Filter, which market_history to fetch.
     */
    where?: market_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_histories to fetch.
     */
    orderBy?: Enumerable<market_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for market_histories.
     */
    cursor?: market_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of market_histories.
     */
    distinct?: Enumerable<Market_historyScalarFieldEnum>
  }


  /**
   * market_history findMany
   */
  export type market_historyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_history
     */
    select?: market_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_historyInclude<ExtArgs> | null
    /**
     * Filter, which market_histories to fetch.
     */
    where?: market_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_histories to fetch.
     */
    orderBy?: Enumerable<market_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing market_histories.
     */
    cursor?: market_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_histories.
     */
    skip?: number
    distinct?: Enumerable<Market_historyScalarFieldEnum>
  }


  /**
   * market_history create
   */
  export type market_historyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_history
     */
    select?: market_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a market_history.
     */
    data: XOR<market_historyCreateInput, market_historyUncheckedCreateInput>
  }


  /**
   * market_history createMany
   */
  export type market_historyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many market_histories.
     */
    data: Enumerable<market_historyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * market_history update
   */
  export type market_historyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_history
     */
    select?: market_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a market_history.
     */
    data: XOR<market_historyUpdateInput, market_historyUncheckedUpdateInput>
    /**
     * Choose, which market_history to update.
     */
    where: market_historyWhereUniqueInput
  }


  /**
   * market_history updateMany
   */
  export type market_historyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update market_histories.
     */
    data: XOR<market_historyUpdateManyMutationInput, market_historyUncheckedUpdateManyInput>
    /**
     * Filter which market_histories to update
     */
    where?: market_historyWhereInput
  }


  /**
   * market_history upsert
   */
  export type market_historyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_history
     */
    select?: market_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the market_history to update in case it exists.
     */
    where: market_historyWhereUniqueInput
    /**
     * In case the market_history found by the `where` argument doesn't exist, create a new market_history with this data.
     */
    create: XOR<market_historyCreateInput, market_historyUncheckedCreateInput>
    /**
     * In case the market_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<market_historyUpdateInput, market_historyUncheckedUpdateInput>
  }


  /**
   * market_history delete
   */
  export type market_historyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_history
     */
    select?: market_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_historyInclude<ExtArgs> | null
    /**
     * Filter which market_history to delete.
     */
    where: market_historyWhereUniqueInput
  }


  /**
   * market_history deleteMany
   */
  export type market_historyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which market_histories to delete
     */
    where?: market_historyWhereInput
  }


  /**
   * market_history without action
   */
  export type market_historyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_history
     */
    select?: market_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_historyInclude<ExtArgs> | null
  }



  /**
   * Model market_offers
   */


  export type AggregateMarket_offers = {
    _count: Market_offersCountAggregateOutputType | null
    _avg: Market_offersAvgAggregateOutputType | null
    _sum: Market_offersSumAggregateOutputType | null
    _min: Market_offersMinAggregateOutputType | null
    _max: Market_offersMaxAggregateOutputType | null
  }

  export type Market_offersAvgAggregateOutputType = {
    id: number | null
    player_id: number | null
    itemtype: number | null
    amount: number | null
    created: number | null
    price: number | null
  }

  export type Market_offersSumAggregateOutputType = {
    id: number | null
    player_id: number | null
    itemtype: number | null
    amount: number | null
    created: bigint | null
    price: number | null
  }

  export type Market_offersMinAggregateOutputType = {
    id: number | null
    player_id: number | null
    sale: boolean | null
    itemtype: number | null
    amount: number | null
    created: bigint | null
    anonymous: boolean | null
    price: number | null
  }

  export type Market_offersMaxAggregateOutputType = {
    id: number | null
    player_id: number | null
    sale: boolean | null
    itemtype: number | null
    amount: number | null
    created: bigint | null
    anonymous: boolean | null
    price: number | null
  }

  export type Market_offersCountAggregateOutputType = {
    id: number
    player_id: number
    sale: number
    itemtype: number
    amount: number
    created: number
    anonymous: number
    price: number
    _all: number
  }


  export type Market_offersAvgAggregateInputType = {
    id?: true
    player_id?: true
    itemtype?: true
    amount?: true
    created?: true
    price?: true
  }

  export type Market_offersSumAggregateInputType = {
    id?: true
    player_id?: true
    itemtype?: true
    amount?: true
    created?: true
    price?: true
  }

  export type Market_offersMinAggregateInputType = {
    id?: true
    player_id?: true
    sale?: true
    itemtype?: true
    amount?: true
    created?: true
    anonymous?: true
    price?: true
  }

  export type Market_offersMaxAggregateInputType = {
    id?: true
    player_id?: true
    sale?: true
    itemtype?: true
    amount?: true
    created?: true
    anonymous?: true
    price?: true
  }

  export type Market_offersCountAggregateInputType = {
    id?: true
    player_id?: true
    sale?: true
    itemtype?: true
    amount?: true
    created?: true
    anonymous?: true
    price?: true
    _all?: true
  }

  export type Market_offersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which market_offers to aggregate.
     */
    where?: market_offersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_offers to fetch.
     */
    orderBy?: Enumerable<market_offersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: market_offersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned market_offers
    **/
    _count?: true | Market_offersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Market_offersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Market_offersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Market_offersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Market_offersMaxAggregateInputType
  }

  export type GetMarket_offersAggregateType<T extends Market_offersAggregateArgs> = {
        [P in keyof T & keyof AggregateMarket_offers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarket_offers[P]>
      : GetScalarType<T[P], AggregateMarket_offers[P]>
  }




  export type Market_offersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: market_offersWhereInput
    orderBy?: Enumerable<market_offersOrderByWithAggregationInput>
    by: Market_offersScalarFieldEnum[]
    having?: market_offersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Market_offersCountAggregateInputType | true
    _avg?: Market_offersAvgAggregateInputType
    _sum?: Market_offersSumAggregateInputType
    _min?: Market_offersMinAggregateInputType
    _max?: Market_offersMaxAggregateInputType
  }


  export type Market_offersGroupByOutputType = {
    id: number
    player_id: number
    sale: boolean
    itemtype: number
    amount: number
    created: bigint
    anonymous: boolean
    price: number
    _count: Market_offersCountAggregateOutputType | null
    _avg: Market_offersAvgAggregateOutputType | null
    _sum: Market_offersSumAggregateOutputType | null
    _min: Market_offersMinAggregateOutputType | null
    _max: Market_offersMaxAggregateOutputType | null
  }

  type GetMarket_offersGroupByPayload<T extends Market_offersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Market_offersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Market_offersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Market_offersGroupByOutputType[P]>
            : GetScalarType<T[P], Market_offersGroupByOutputType[P]>
        }
      >
    >


  export type market_offersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    sale?: boolean
    itemtype?: boolean
    amount?: boolean
    created?: boolean
    anonymous?: boolean
    price?: boolean
    players?: boolean | PlayerArgs<ExtArgs>
  }, ExtArgs["result"]["market_offers"]>

  export type market_offersSelectScalar = {
    id?: boolean
    player_id?: boolean
    sale?: boolean
    itemtype?: boolean
    amount?: boolean
    created?: boolean
    anonymous?: boolean
    price?: boolean
  }

  export type market_offersInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    players?: boolean | PlayerArgs<ExtArgs>
  }


  type market_offersGetPayload<S extends boolean | null | undefined | market_offersArgs> = $Types.GetResult<market_offersPayload, S>

  type market_offersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<market_offersFindManyArgs, 'select' | 'include'> & {
      select?: Market_offersCountAggregateInputType | true
    }

  export interface market_offersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['market_offers'], meta: { name: 'market_offers' } }
    /**
     * Find zero or one Market_offers that matches the filter.
     * @param {market_offersFindUniqueArgs} args - Arguments to find a Market_offers
     * @example
     * // Get one Market_offers
     * const market_offers = await prisma.market_offers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends market_offersFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, market_offersFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'market_offers'> extends True ? Prisma__market_offersClient<$Types.GetResult<market_offersPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__market_offersClient<$Types.GetResult<market_offersPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Market_offers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {market_offersFindUniqueOrThrowArgs} args - Arguments to find a Market_offers
     * @example
     * // Get one Market_offers
     * const market_offers = await prisma.market_offers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends market_offersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, market_offersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__market_offersClient<$Types.GetResult<market_offersPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Market_offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_offersFindFirstArgs} args - Arguments to find a Market_offers
     * @example
     * // Get one Market_offers
     * const market_offers = await prisma.market_offers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends market_offersFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, market_offersFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'market_offers'> extends True ? Prisma__market_offersClient<$Types.GetResult<market_offersPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__market_offersClient<$Types.GetResult<market_offersPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Market_offers that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_offersFindFirstOrThrowArgs} args - Arguments to find a Market_offers
     * @example
     * // Get one Market_offers
     * const market_offers = await prisma.market_offers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends market_offersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, market_offersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__market_offersClient<$Types.GetResult<market_offersPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Market_offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_offersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Market_offers
     * const market_offers = await prisma.market_offers.findMany()
     * 
     * // Get first 10 Market_offers
     * const market_offers = await prisma.market_offers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const market_offersWithIdOnly = await prisma.market_offers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends market_offersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, market_offersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<market_offersPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Market_offers.
     * @param {market_offersCreateArgs} args - Arguments to create a Market_offers.
     * @example
     * // Create one Market_offers
     * const Market_offers = await prisma.market_offers.create({
     *   data: {
     *     // ... data to create a Market_offers
     *   }
     * })
     * 
    **/
    create<T extends market_offersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, market_offersCreateArgs<ExtArgs>>
    ): Prisma__market_offersClient<$Types.GetResult<market_offersPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Market_offers.
     *     @param {market_offersCreateManyArgs} args - Arguments to create many Market_offers.
     *     @example
     *     // Create many Market_offers
     *     const market_offers = await prisma.market_offers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends market_offersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, market_offersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Market_offers.
     * @param {market_offersDeleteArgs} args - Arguments to delete one Market_offers.
     * @example
     * // Delete one Market_offers
     * const Market_offers = await prisma.market_offers.delete({
     *   where: {
     *     // ... filter to delete one Market_offers
     *   }
     * })
     * 
    **/
    delete<T extends market_offersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, market_offersDeleteArgs<ExtArgs>>
    ): Prisma__market_offersClient<$Types.GetResult<market_offersPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Market_offers.
     * @param {market_offersUpdateArgs} args - Arguments to update one Market_offers.
     * @example
     * // Update one Market_offers
     * const market_offers = await prisma.market_offers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends market_offersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, market_offersUpdateArgs<ExtArgs>>
    ): Prisma__market_offersClient<$Types.GetResult<market_offersPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Market_offers.
     * @param {market_offersDeleteManyArgs} args - Arguments to filter Market_offers to delete.
     * @example
     * // Delete a few Market_offers
     * const { count } = await prisma.market_offers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends market_offersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, market_offersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Market_offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_offersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Market_offers
     * const market_offers = await prisma.market_offers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends market_offersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, market_offersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Market_offers.
     * @param {market_offersUpsertArgs} args - Arguments to update or create a Market_offers.
     * @example
     * // Update or create a Market_offers
     * const market_offers = await prisma.market_offers.upsert({
     *   create: {
     *     // ... data to create a Market_offers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Market_offers we want to update
     *   }
     * })
    **/
    upsert<T extends market_offersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, market_offersUpsertArgs<ExtArgs>>
    ): Prisma__market_offersClient<$Types.GetResult<market_offersPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Market_offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {market_offersCountArgs} args - Arguments to filter Market_offers to count.
     * @example
     * // Count the number of Market_offers
     * const count = await prisma.market_offers.count({
     *   where: {
     *     // ... the filter for the Market_offers we want to count
     *   }
     * })
    **/
    count<T extends market_offersCountArgs>(
      args?: Subset<T, market_offersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Market_offersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Market_offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Market_offersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Market_offersAggregateArgs>(args: Subset<T, Market_offersAggregateArgs>): Prisma.PrismaPromise<GetMarket_offersAggregateType<T>>

    /**
     * Group by Market_offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Market_offersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Market_offersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Market_offersGroupByArgs['orderBy'] }
        : { orderBy?: Market_offersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Market_offersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarket_offersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for market_offers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__market_offersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    players<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * market_offers base type for findUnique actions
   */
  export type market_offersFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_offers
     */
    select?: market_offersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_offersInclude<ExtArgs> | null
    /**
     * Filter, which market_offers to fetch.
     */
    where: market_offersWhereUniqueInput
  }

  /**
   * market_offers findUnique
   */
  export interface market_offersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends market_offersFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * market_offers findUniqueOrThrow
   */
  export type market_offersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_offers
     */
    select?: market_offersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_offersInclude<ExtArgs> | null
    /**
     * Filter, which market_offers to fetch.
     */
    where: market_offersWhereUniqueInput
  }


  /**
   * market_offers base type for findFirst actions
   */
  export type market_offersFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_offers
     */
    select?: market_offersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_offersInclude<ExtArgs> | null
    /**
     * Filter, which market_offers to fetch.
     */
    where?: market_offersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_offers to fetch.
     */
    orderBy?: Enumerable<market_offersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for market_offers.
     */
    cursor?: market_offersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of market_offers.
     */
    distinct?: Enumerable<Market_offersScalarFieldEnum>
  }

  /**
   * market_offers findFirst
   */
  export interface market_offersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends market_offersFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * market_offers findFirstOrThrow
   */
  export type market_offersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_offers
     */
    select?: market_offersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_offersInclude<ExtArgs> | null
    /**
     * Filter, which market_offers to fetch.
     */
    where?: market_offersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_offers to fetch.
     */
    orderBy?: Enumerable<market_offersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for market_offers.
     */
    cursor?: market_offersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of market_offers.
     */
    distinct?: Enumerable<Market_offersScalarFieldEnum>
  }


  /**
   * market_offers findMany
   */
  export type market_offersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_offers
     */
    select?: market_offersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_offersInclude<ExtArgs> | null
    /**
     * Filter, which market_offers to fetch.
     */
    where?: market_offersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of market_offers to fetch.
     */
    orderBy?: Enumerable<market_offersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing market_offers.
     */
    cursor?: market_offersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` market_offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` market_offers.
     */
    skip?: number
    distinct?: Enumerable<Market_offersScalarFieldEnum>
  }


  /**
   * market_offers create
   */
  export type market_offersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_offers
     */
    select?: market_offersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_offersInclude<ExtArgs> | null
    /**
     * The data needed to create a market_offers.
     */
    data: XOR<market_offersCreateInput, market_offersUncheckedCreateInput>
  }


  /**
   * market_offers createMany
   */
  export type market_offersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many market_offers.
     */
    data: Enumerable<market_offersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * market_offers update
   */
  export type market_offersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_offers
     */
    select?: market_offersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_offersInclude<ExtArgs> | null
    /**
     * The data needed to update a market_offers.
     */
    data: XOR<market_offersUpdateInput, market_offersUncheckedUpdateInput>
    /**
     * Choose, which market_offers to update.
     */
    where: market_offersWhereUniqueInput
  }


  /**
   * market_offers updateMany
   */
  export type market_offersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update market_offers.
     */
    data: XOR<market_offersUpdateManyMutationInput, market_offersUncheckedUpdateManyInput>
    /**
     * Filter which market_offers to update
     */
    where?: market_offersWhereInput
  }


  /**
   * market_offers upsert
   */
  export type market_offersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_offers
     */
    select?: market_offersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_offersInclude<ExtArgs> | null
    /**
     * The filter to search for the market_offers to update in case it exists.
     */
    where: market_offersWhereUniqueInput
    /**
     * In case the market_offers found by the `where` argument doesn't exist, create a new market_offers with this data.
     */
    create: XOR<market_offersCreateInput, market_offersUncheckedCreateInput>
    /**
     * In case the market_offers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<market_offersUpdateInput, market_offersUncheckedUpdateInput>
  }


  /**
   * market_offers delete
   */
  export type market_offersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_offers
     */
    select?: market_offersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_offersInclude<ExtArgs> | null
    /**
     * Filter which market_offers to delete.
     */
    where: market_offersWhereUniqueInput
  }


  /**
   * market_offers deleteMany
   */
  export type market_offersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which market_offers to delete
     */
    where?: market_offersWhereInput
  }


  /**
   * market_offers without action
   */
  export type market_offersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the market_offers
     */
    select?: market_offersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: market_offersInclude<ExtArgs> | null
  }



  /**
   * Model pets
   */


  export type AggregatePets = {
    _count: PetsCountAggregateOutputType | null
    _avg: PetsAvgAggregateOutputType | null
    _sum: PetsSumAggregateOutputType | null
    _min: PetsMinAggregateOutputType | null
    _max: PetsMaxAggregateOutputType | null
  }

  export type PetsAvgAggregateOutputType = {
    id: number | null
    type: number | null
    rank: number | null
    stage: number | null
    level: number | null
    experience: number | null
    addonItem: number | null
    strength: number | null
    wisdom: number | null
    agility: number | null
    sustain: number | null
    magicResistance: number | null
    lucky: number | null
    hungry: number | null
    hygiene: number | null
    happiness: number | null
    health: number | null
  }

  export type PetsSumAggregateOutputType = {
    id: number | null
    type: number | null
    rank: number | null
    stage: number | null
    level: number | null
    experience: number | null
    addonItem: number | null
    strength: number | null
    wisdom: number | null
    agility: number | null
    sustain: number | null
    magicResistance: number | null
    lucky: number | null
    hungry: number | null
    hygiene: number | null
    happiness: number | null
    health: bigint | null
  }

  export type PetsMinAggregateOutputType = {
    id: number | null
    type: number | null
    rank: number | null
    stage: number | null
    name: string | null
    pet: string | null
    owner: string | null
    level: number | null
    experience: number | null
    addonItem: number | null
    strength: number | null
    wisdom: number | null
    agility: number | null
    sustain: number | null
    magicResistance: number | null
    lucky: number | null
    hungry: number | null
    hygiene: number | null
    happiness: number | null
    health: bigint | null
    cooldowns: string | null
    world_id: boolean | null
    wallet: string | null
  }

  export type PetsMaxAggregateOutputType = {
    id: number | null
    type: number | null
    rank: number | null
    stage: number | null
    name: string | null
    pet: string | null
    owner: string | null
    level: number | null
    experience: number | null
    addonItem: number | null
    strength: number | null
    wisdom: number | null
    agility: number | null
    sustain: number | null
    magicResistance: number | null
    lucky: number | null
    hungry: number | null
    hygiene: number | null
    happiness: number | null
    health: bigint | null
    cooldowns: string | null
    world_id: boolean | null
    wallet: string | null
  }

  export type PetsCountAggregateOutputType = {
    id: number
    type: number
    rank: number
    stage: number
    name: number
    pet: number
    owner: number
    level: number
    experience: number
    addonItem: number
    strength: number
    wisdom: number
    agility: number
    sustain: number
    magicResistance: number
    lucky: number
    hungry: number
    hygiene: number
    happiness: number
    health: number
    cooldowns: number
    world_id: number
    wallet: number
    _all: number
  }


  export type PetsAvgAggregateInputType = {
    id?: true
    type?: true
    rank?: true
    stage?: true
    level?: true
    experience?: true
    addonItem?: true
    strength?: true
    wisdom?: true
    agility?: true
    sustain?: true
    magicResistance?: true
    lucky?: true
    hungry?: true
    hygiene?: true
    happiness?: true
    health?: true
  }

  export type PetsSumAggregateInputType = {
    id?: true
    type?: true
    rank?: true
    stage?: true
    level?: true
    experience?: true
    addonItem?: true
    strength?: true
    wisdom?: true
    agility?: true
    sustain?: true
    magicResistance?: true
    lucky?: true
    hungry?: true
    hygiene?: true
    happiness?: true
    health?: true
  }

  export type PetsMinAggregateInputType = {
    id?: true
    type?: true
    rank?: true
    stage?: true
    name?: true
    pet?: true
    owner?: true
    level?: true
    experience?: true
    addonItem?: true
    strength?: true
    wisdom?: true
    agility?: true
    sustain?: true
    magicResistance?: true
    lucky?: true
    hungry?: true
    hygiene?: true
    happiness?: true
    health?: true
    cooldowns?: true
    world_id?: true
    wallet?: true
  }

  export type PetsMaxAggregateInputType = {
    id?: true
    type?: true
    rank?: true
    stage?: true
    name?: true
    pet?: true
    owner?: true
    level?: true
    experience?: true
    addonItem?: true
    strength?: true
    wisdom?: true
    agility?: true
    sustain?: true
    magicResistance?: true
    lucky?: true
    hungry?: true
    hygiene?: true
    happiness?: true
    health?: true
    cooldowns?: true
    world_id?: true
    wallet?: true
  }

  export type PetsCountAggregateInputType = {
    id?: true
    type?: true
    rank?: true
    stage?: true
    name?: true
    pet?: true
    owner?: true
    level?: true
    experience?: true
    addonItem?: true
    strength?: true
    wisdom?: true
    agility?: true
    sustain?: true
    magicResistance?: true
    lucky?: true
    hungry?: true
    hygiene?: true
    happiness?: true
    health?: true
    cooldowns?: true
    world_id?: true
    wallet?: true
    _all?: true
  }

  export type PetsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which pets to aggregate.
     */
    where?: petsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pets to fetch.
     */
    orderBy?: Enumerable<petsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: petsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pets
    **/
    _count?: true | PetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PetsMaxAggregateInputType
  }

  export type GetPetsAggregateType<T extends PetsAggregateArgs> = {
        [P in keyof T & keyof AggregatePets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePets[P]>
      : GetScalarType<T[P], AggregatePets[P]>
  }




  export type PetsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: petsWhereInput
    orderBy?: Enumerable<petsOrderByWithAggregationInput>
    by: PetsScalarFieldEnum[]
    having?: petsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PetsCountAggregateInputType | true
    _avg?: PetsAvgAggregateInputType
    _sum?: PetsSumAggregateInputType
    _min?: PetsMinAggregateInputType
    _max?: PetsMaxAggregateInputType
  }


  export type PetsGroupByOutputType = {
    id: number
    type: number
    rank: number
    stage: number
    name: string
    pet: string
    owner: string
    level: number
    experience: number
    addonItem: number
    strength: number
    wisdom: number
    agility: number
    sustain: number
    magicResistance: number
    lucky: number
    hungry: number
    hygiene: number
    happiness: number
    health: bigint
    cooldowns: string
    world_id: boolean
    wallet: string
    _count: PetsCountAggregateOutputType | null
    _avg: PetsAvgAggregateOutputType | null
    _sum: PetsSumAggregateOutputType | null
    _min: PetsMinAggregateOutputType | null
    _max: PetsMaxAggregateOutputType | null
  }

  type GetPetsGroupByPayload<T extends PetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PetsGroupByOutputType[P]>
            : GetScalarType<T[P], PetsGroupByOutputType[P]>
        }
      >
    >


  export type petsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    rank?: boolean
    stage?: boolean
    name?: boolean
    pet?: boolean
    owner?: boolean
    level?: boolean
    experience?: boolean
    addonItem?: boolean
    strength?: boolean
    wisdom?: boolean
    agility?: boolean
    sustain?: boolean
    magicResistance?: boolean
    lucky?: boolean
    hungry?: boolean
    hygiene?: boolean
    happiness?: boolean
    health?: boolean
    cooldowns?: boolean
    world_id?: boolean
    wallet?: boolean
  }, ExtArgs["result"]["pets"]>

  export type petsSelectScalar = {
    id?: boolean
    type?: boolean
    rank?: boolean
    stage?: boolean
    name?: boolean
    pet?: boolean
    owner?: boolean
    level?: boolean
    experience?: boolean
    addonItem?: boolean
    strength?: boolean
    wisdom?: boolean
    agility?: boolean
    sustain?: boolean
    magicResistance?: boolean
    lucky?: boolean
    hungry?: boolean
    hygiene?: boolean
    happiness?: boolean
    health?: boolean
    cooldowns?: boolean
    world_id?: boolean
    wallet?: boolean
  }


  type petsGetPayload<S extends boolean | null | undefined | petsArgs> = $Types.GetResult<petsPayload, S>

  type petsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<petsFindManyArgs, 'select' | 'include'> & {
      select?: PetsCountAggregateInputType | true
    }

  export interface petsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pets'], meta: { name: 'pets' } }
    /**
     * Find zero or one Pets that matches the filter.
     * @param {petsFindUniqueArgs} args - Arguments to find a Pets
     * @example
     * // Get one Pets
     * const pets = await prisma.pets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends petsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, petsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pets'> extends True ? Prisma__petsClient<$Types.GetResult<petsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__petsClient<$Types.GetResult<petsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Pets that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {petsFindUniqueOrThrowArgs} args - Arguments to find a Pets
     * @example
     * // Get one Pets
     * const pets = await prisma.pets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends petsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, petsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__petsClient<$Types.GetResult<petsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Pets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petsFindFirstArgs} args - Arguments to find a Pets
     * @example
     * // Get one Pets
     * const pets = await prisma.pets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends petsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, petsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pets'> extends True ? Prisma__petsClient<$Types.GetResult<petsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__petsClient<$Types.GetResult<petsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Pets that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petsFindFirstOrThrowArgs} args - Arguments to find a Pets
     * @example
     * // Get one Pets
     * const pets = await prisma.pets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends petsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, petsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__petsClient<$Types.GetResult<petsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Pets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pets
     * const pets = await prisma.pets.findMany()
     * 
     * // Get first 10 Pets
     * const pets = await prisma.pets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const petsWithIdOnly = await prisma.pets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends petsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, petsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<petsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Pets.
     * @param {petsCreateArgs} args - Arguments to create a Pets.
     * @example
     * // Create one Pets
     * const Pets = await prisma.pets.create({
     *   data: {
     *     // ... data to create a Pets
     *   }
     * })
     * 
    **/
    create<T extends petsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, petsCreateArgs<ExtArgs>>
    ): Prisma__petsClient<$Types.GetResult<petsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Pets.
     *     @param {petsCreateManyArgs} args - Arguments to create many Pets.
     *     @example
     *     // Create many Pets
     *     const pets = await prisma.pets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends petsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, petsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pets.
     * @param {petsDeleteArgs} args - Arguments to delete one Pets.
     * @example
     * // Delete one Pets
     * const Pets = await prisma.pets.delete({
     *   where: {
     *     // ... filter to delete one Pets
     *   }
     * })
     * 
    **/
    delete<T extends petsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, petsDeleteArgs<ExtArgs>>
    ): Prisma__petsClient<$Types.GetResult<petsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Pets.
     * @param {petsUpdateArgs} args - Arguments to update one Pets.
     * @example
     * // Update one Pets
     * const pets = await prisma.pets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends petsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, petsUpdateArgs<ExtArgs>>
    ): Prisma__petsClient<$Types.GetResult<petsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Pets.
     * @param {petsDeleteManyArgs} args - Arguments to filter Pets to delete.
     * @example
     * // Delete a few Pets
     * const { count } = await prisma.pets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends petsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, petsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pets
     * const pets = await prisma.pets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends petsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, petsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pets.
     * @param {petsUpsertArgs} args - Arguments to update or create a Pets.
     * @example
     * // Update or create a Pets
     * const pets = await prisma.pets.upsert({
     *   create: {
     *     // ... data to create a Pets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pets we want to update
     *   }
     * })
    **/
    upsert<T extends petsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, petsUpsertArgs<ExtArgs>>
    ): Prisma__petsClient<$Types.GetResult<petsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {petsCountArgs} args - Arguments to filter Pets to count.
     * @example
     * // Count the number of Pets
     * const count = await prisma.pets.count({
     *   where: {
     *     // ... the filter for the Pets we want to count
     *   }
     * })
    **/
    count<T extends petsCountArgs>(
      args?: Subset<T, petsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PetsAggregateArgs>(args: Subset<T, PetsAggregateArgs>): Prisma.PrismaPromise<GetPetsAggregateType<T>>

    /**
     * Group by Pets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PetsGroupByArgs['orderBy'] }
        : { orderBy?: PetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__petsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pets base type for findUnique actions
   */
  export type petsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pets
     */
    select?: petsSelect<ExtArgs> | null
    /**
     * Filter, which pets to fetch.
     */
    where: petsWhereUniqueInput
  }

  /**
   * pets findUnique
   */
  export interface petsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends petsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pets findUniqueOrThrow
   */
  export type petsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pets
     */
    select?: petsSelect<ExtArgs> | null
    /**
     * Filter, which pets to fetch.
     */
    where: petsWhereUniqueInput
  }


  /**
   * pets base type for findFirst actions
   */
  export type petsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pets
     */
    select?: petsSelect<ExtArgs> | null
    /**
     * Filter, which pets to fetch.
     */
    where?: petsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pets to fetch.
     */
    orderBy?: Enumerable<petsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pets.
     */
    cursor?: petsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pets.
     */
    distinct?: Enumerable<PetsScalarFieldEnum>
  }

  /**
   * pets findFirst
   */
  export interface petsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends petsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pets findFirstOrThrow
   */
  export type petsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pets
     */
    select?: petsSelect<ExtArgs> | null
    /**
     * Filter, which pets to fetch.
     */
    where?: petsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pets to fetch.
     */
    orderBy?: Enumerable<petsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pets.
     */
    cursor?: petsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pets.
     */
    distinct?: Enumerable<PetsScalarFieldEnum>
  }


  /**
   * pets findMany
   */
  export type petsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pets
     */
    select?: petsSelect<ExtArgs> | null
    /**
     * Filter, which pets to fetch.
     */
    where?: petsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pets to fetch.
     */
    orderBy?: Enumerable<petsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pets.
     */
    cursor?: petsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pets.
     */
    skip?: number
    distinct?: Enumerable<PetsScalarFieldEnum>
  }


  /**
   * pets create
   */
  export type petsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pets
     */
    select?: petsSelect<ExtArgs> | null
    /**
     * The data needed to create a pets.
     */
    data: XOR<petsCreateInput, petsUncheckedCreateInput>
  }


  /**
   * pets createMany
   */
  export type petsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pets.
     */
    data: Enumerable<petsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pets update
   */
  export type petsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pets
     */
    select?: petsSelect<ExtArgs> | null
    /**
     * The data needed to update a pets.
     */
    data: XOR<petsUpdateInput, petsUncheckedUpdateInput>
    /**
     * Choose, which pets to update.
     */
    where: petsWhereUniqueInput
  }


  /**
   * pets updateMany
   */
  export type petsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pets.
     */
    data: XOR<petsUpdateManyMutationInput, petsUncheckedUpdateManyInput>
    /**
     * Filter which pets to update
     */
    where?: petsWhereInput
  }


  /**
   * pets upsert
   */
  export type petsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pets
     */
    select?: petsSelect<ExtArgs> | null
    /**
     * The filter to search for the pets to update in case it exists.
     */
    where: petsWhereUniqueInput
    /**
     * In case the pets found by the `where` argument doesn't exist, create a new pets with this data.
     */
    create: XOR<petsCreateInput, petsUncheckedCreateInput>
    /**
     * In case the pets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<petsUpdateInput, petsUncheckedUpdateInput>
  }


  /**
   * pets delete
   */
  export type petsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pets
     */
    select?: petsSelect<ExtArgs> | null
    /**
     * Filter which pets to delete.
     */
    where: petsWhereUniqueInput
  }


  /**
   * pets deleteMany
   */
  export type petsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which pets to delete
     */
    where?: petsWhereInput
  }


  /**
   * pets without action
   */
  export type petsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pets
     */
    select?: petsSelect<ExtArgs> | null
  }



  /**
   * Model player_depotitems
   */


  export type AggregatePlayer_depotitems = {
    _count: Player_depotitemsCountAggregateOutputType | null
    _avg: Player_depotitemsAvgAggregateOutputType | null
    _sum: Player_depotitemsSumAggregateOutputType | null
    _min: Player_depotitemsMinAggregateOutputType | null
    _max: Player_depotitemsMaxAggregateOutputType | null
  }

  export type Player_depotitemsAvgAggregateOutputType = {
    player_id: number | null
    sid: number | null
    pid: number | null
    itemtype: number | null
    count: number | null
  }

  export type Player_depotitemsSumAggregateOutputType = {
    player_id: number | null
    sid: number | null
    pid: number | null
    itemtype: number | null
    count: number | null
  }

  export type Player_depotitemsMinAggregateOutputType = {
    player_id: number | null
    sid: number | null
    pid: number | null
    itemtype: number | null
    count: number | null
    attributes: Buffer | null
  }

  export type Player_depotitemsMaxAggregateOutputType = {
    player_id: number | null
    sid: number | null
    pid: number | null
    itemtype: number | null
    count: number | null
    attributes: Buffer | null
  }

  export type Player_depotitemsCountAggregateOutputType = {
    player_id: number
    sid: number
    pid: number
    itemtype: number
    count: number
    attributes: number
    json_data: number
    _all: number
  }


  export type Player_depotitemsAvgAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
  }

  export type Player_depotitemsSumAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
  }

  export type Player_depotitemsMinAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
    attributes?: true
  }

  export type Player_depotitemsMaxAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
    attributes?: true
  }

  export type Player_depotitemsCountAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
    attributes?: true
    json_data?: true
    _all?: true
  }

  export type Player_depotitemsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which player_depotitems to aggregate.
     */
    where?: player_depotitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_depotitems to fetch.
     */
    orderBy?: Enumerable<player_depotitemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: player_depotitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_depotitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_depotitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned player_depotitems
    **/
    _count?: true | Player_depotitemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Player_depotitemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Player_depotitemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Player_depotitemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Player_depotitemsMaxAggregateInputType
  }

  export type GetPlayer_depotitemsAggregateType<T extends Player_depotitemsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer_depotitems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer_depotitems[P]>
      : GetScalarType<T[P], AggregatePlayer_depotitems[P]>
  }




  export type Player_depotitemsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: player_depotitemsWhereInput
    orderBy?: Enumerable<player_depotitemsOrderByWithAggregationInput>
    by: Player_depotitemsScalarFieldEnum[]
    having?: player_depotitemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Player_depotitemsCountAggregateInputType | true
    _avg?: Player_depotitemsAvgAggregateInputType
    _sum?: Player_depotitemsSumAggregateInputType
    _min?: Player_depotitemsMinAggregateInputType
    _max?: Player_depotitemsMaxAggregateInputType
  }


  export type Player_depotitemsGroupByOutputType = {
    player_id: number
    sid: number
    pid: number
    itemtype: number
    count: number
    attributes: Buffer
    json_data: JsonValue | null
    _count: Player_depotitemsCountAggregateOutputType | null
    _avg: Player_depotitemsAvgAggregateOutputType | null
    _sum: Player_depotitemsSumAggregateOutputType | null
    _min: Player_depotitemsMinAggregateOutputType | null
    _max: Player_depotitemsMaxAggregateOutputType | null
  }

  type GetPlayer_depotitemsGroupByPayload<T extends Player_depotitemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Player_depotitemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Player_depotitemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Player_depotitemsGroupByOutputType[P]>
            : GetScalarType<T[P], Player_depotitemsGroupByOutputType[P]>
        }
      >
    >


  export type player_depotitemsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    player_id?: boolean
    sid?: boolean
    pid?: boolean
    itemtype?: boolean
    count?: boolean
    attributes?: boolean
    json_data?: boolean
    players?: boolean | PlayerArgs<ExtArgs>
  }, ExtArgs["result"]["player_depotitems"]>

  export type player_depotitemsSelectScalar = {
    player_id?: boolean
    sid?: boolean
    pid?: boolean
    itemtype?: boolean
    count?: boolean
    attributes?: boolean
    json_data?: boolean
  }

  export type player_depotitemsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    players?: boolean | PlayerArgs<ExtArgs>
  }


  type player_depotitemsGetPayload<S extends boolean | null | undefined | player_depotitemsArgs> = $Types.GetResult<player_depotitemsPayload, S>

  type player_depotitemsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<player_depotitemsFindManyArgs, 'select' | 'include'> & {
      select?: Player_depotitemsCountAggregateInputType | true
    }

  export interface player_depotitemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['player_depotitems'], meta: { name: 'player_depotitems' } }
    /**
     * Find zero or one Player_depotitems that matches the filter.
     * @param {player_depotitemsFindUniqueArgs} args - Arguments to find a Player_depotitems
     * @example
     * // Get one Player_depotitems
     * const player_depotitems = await prisma.player_depotitems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends player_depotitemsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, player_depotitemsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'player_depotitems'> extends True ? Prisma__player_depotitemsClient<$Types.GetResult<player_depotitemsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__player_depotitemsClient<$Types.GetResult<player_depotitemsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Player_depotitems that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {player_depotitemsFindUniqueOrThrowArgs} args - Arguments to find a Player_depotitems
     * @example
     * // Get one Player_depotitems
     * const player_depotitems = await prisma.player_depotitems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends player_depotitemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, player_depotitemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__player_depotitemsClient<$Types.GetResult<player_depotitemsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Player_depotitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_depotitemsFindFirstArgs} args - Arguments to find a Player_depotitems
     * @example
     * // Get one Player_depotitems
     * const player_depotitems = await prisma.player_depotitems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends player_depotitemsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, player_depotitemsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'player_depotitems'> extends True ? Prisma__player_depotitemsClient<$Types.GetResult<player_depotitemsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__player_depotitemsClient<$Types.GetResult<player_depotitemsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Player_depotitems that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_depotitemsFindFirstOrThrowArgs} args - Arguments to find a Player_depotitems
     * @example
     * // Get one Player_depotitems
     * const player_depotitems = await prisma.player_depotitems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends player_depotitemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, player_depotitemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__player_depotitemsClient<$Types.GetResult<player_depotitemsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Player_depotitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_depotitemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Player_depotitems
     * const player_depotitems = await prisma.player_depotitems.findMany()
     * 
     * // Get first 10 Player_depotitems
     * const player_depotitems = await prisma.player_depotitems.findMany({ take: 10 })
     * 
     * // Only select the `player_id`
     * const player_depotitemsWithPlayer_idOnly = await prisma.player_depotitems.findMany({ select: { player_id: true } })
     * 
    **/
    findMany<T extends player_depotitemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_depotitemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<player_depotitemsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Player_depotitems.
     * @param {player_depotitemsCreateArgs} args - Arguments to create a Player_depotitems.
     * @example
     * // Create one Player_depotitems
     * const Player_depotitems = await prisma.player_depotitems.create({
     *   data: {
     *     // ... data to create a Player_depotitems
     *   }
     * })
     * 
    **/
    create<T extends player_depotitemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, player_depotitemsCreateArgs<ExtArgs>>
    ): Prisma__player_depotitemsClient<$Types.GetResult<player_depotitemsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Player_depotitems.
     *     @param {player_depotitemsCreateManyArgs} args - Arguments to create many Player_depotitems.
     *     @example
     *     // Create many Player_depotitems
     *     const player_depotitems = await prisma.player_depotitems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends player_depotitemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_depotitemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Player_depotitems.
     * @param {player_depotitemsDeleteArgs} args - Arguments to delete one Player_depotitems.
     * @example
     * // Delete one Player_depotitems
     * const Player_depotitems = await prisma.player_depotitems.delete({
     *   where: {
     *     // ... filter to delete one Player_depotitems
     *   }
     * })
     * 
    **/
    delete<T extends player_depotitemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, player_depotitemsDeleteArgs<ExtArgs>>
    ): Prisma__player_depotitemsClient<$Types.GetResult<player_depotitemsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Player_depotitems.
     * @param {player_depotitemsUpdateArgs} args - Arguments to update one Player_depotitems.
     * @example
     * // Update one Player_depotitems
     * const player_depotitems = await prisma.player_depotitems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends player_depotitemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, player_depotitemsUpdateArgs<ExtArgs>>
    ): Prisma__player_depotitemsClient<$Types.GetResult<player_depotitemsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Player_depotitems.
     * @param {player_depotitemsDeleteManyArgs} args - Arguments to filter Player_depotitems to delete.
     * @example
     * // Delete a few Player_depotitems
     * const { count } = await prisma.player_depotitems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends player_depotitemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_depotitemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Player_depotitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_depotitemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Player_depotitems
     * const player_depotitems = await prisma.player_depotitems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends player_depotitemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, player_depotitemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Player_depotitems.
     * @param {player_depotitemsUpsertArgs} args - Arguments to update or create a Player_depotitems.
     * @example
     * // Update or create a Player_depotitems
     * const player_depotitems = await prisma.player_depotitems.upsert({
     *   create: {
     *     // ... data to create a Player_depotitems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player_depotitems we want to update
     *   }
     * })
    **/
    upsert<T extends player_depotitemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, player_depotitemsUpsertArgs<ExtArgs>>
    ): Prisma__player_depotitemsClient<$Types.GetResult<player_depotitemsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Player_depotitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_depotitemsCountArgs} args - Arguments to filter Player_depotitems to count.
     * @example
     * // Count the number of Player_depotitems
     * const count = await prisma.player_depotitems.count({
     *   where: {
     *     // ... the filter for the Player_depotitems we want to count
     *   }
     * })
    **/
    count<T extends player_depotitemsCountArgs>(
      args?: Subset<T, player_depotitemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Player_depotitemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player_depotitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Player_depotitemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Player_depotitemsAggregateArgs>(args: Subset<T, Player_depotitemsAggregateArgs>): Prisma.PrismaPromise<GetPlayer_depotitemsAggregateType<T>>

    /**
     * Group by Player_depotitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Player_depotitemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Player_depotitemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Player_depotitemsGroupByArgs['orderBy'] }
        : { orderBy?: Player_depotitemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Player_depotitemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayer_depotitemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for player_depotitems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__player_depotitemsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    players<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * player_depotitems base type for findUnique actions
   */
  export type player_depotitemsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_depotitems
     */
    select?: player_depotitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_depotitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_depotitems to fetch.
     */
    where: player_depotitemsWhereUniqueInput
  }

  /**
   * player_depotitems findUnique
   */
  export interface player_depotitemsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends player_depotitemsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * player_depotitems findUniqueOrThrow
   */
  export type player_depotitemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_depotitems
     */
    select?: player_depotitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_depotitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_depotitems to fetch.
     */
    where: player_depotitemsWhereUniqueInput
  }


  /**
   * player_depotitems base type for findFirst actions
   */
  export type player_depotitemsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_depotitems
     */
    select?: player_depotitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_depotitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_depotitems to fetch.
     */
    where?: player_depotitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_depotitems to fetch.
     */
    orderBy?: Enumerable<player_depotitemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for player_depotitems.
     */
    cursor?: player_depotitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_depotitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_depotitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of player_depotitems.
     */
    distinct?: Enumerable<Player_depotitemsScalarFieldEnum>
  }

  /**
   * player_depotitems findFirst
   */
  export interface player_depotitemsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends player_depotitemsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * player_depotitems findFirstOrThrow
   */
  export type player_depotitemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_depotitems
     */
    select?: player_depotitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_depotitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_depotitems to fetch.
     */
    where?: player_depotitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_depotitems to fetch.
     */
    orderBy?: Enumerable<player_depotitemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for player_depotitems.
     */
    cursor?: player_depotitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_depotitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_depotitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of player_depotitems.
     */
    distinct?: Enumerable<Player_depotitemsScalarFieldEnum>
  }


  /**
   * player_depotitems findMany
   */
  export type player_depotitemsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_depotitems
     */
    select?: player_depotitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_depotitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_depotitems to fetch.
     */
    where?: player_depotitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_depotitems to fetch.
     */
    orderBy?: Enumerable<player_depotitemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing player_depotitems.
     */
    cursor?: player_depotitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_depotitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_depotitems.
     */
    skip?: number
    distinct?: Enumerable<Player_depotitemsScalarFieldEnum>
  }


  /**
   * player_depotitems create
   */
  export type player_depotitemsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_depotitems
     */
    select?: player_depotitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_depotitemsInclude<ExtArgs> | null
    /**
     * The data needed to create a player_depotitems.
     */
    data: XOR<player_depotitemsCreateInput, player_depotitemsUncheckedCreateInput>
  }


  /**
   * player_depotitems createMany
   */
  export type player_depotitemsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many player_depotitems.
     */
    data: Enumerable<player_depotitemsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * player_depotitems update
   */
  export type player_depotitemsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_depotitems
     */
    select?: player_depotitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_depotitemsInclude<ExtArgs> | null
    /**
     * The data needed to update a player_depotitems.
     */
    data: XOR<player_depotitemsUpdateInput, player_depotitemsUncheckedUpdateInput>
    /**
     * Choose, which player_depotitems to update.
     */
    where: player_depotitemsWhereUniqueInput
  }


  /**
   * player_depotitems updateMany
   */
  export type player_depotitemsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update player_depotitems.
     */
    data: XOR<player_depotitemsUpdateManyMutationInput, player_depotitemsUncheckedUpdateManyInput>
    /**
     * Filter which player_depotitems to update
     */
    where?: player_depotitemsWhereInput
  }


  /**
   * player_depotitems upsert
   */
  export type player_depotitemsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_depotitems
     */
    select?: player_depotitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_depotitemsInclude<ExtArgs> | null
    /**
     * The filter to search for the player_depotitems to update in case it exists.
     */
    where: player_depotitemsWhereUniqueInput
    /**
     * In case the player_depotitems found by the `where` argument doesn't exist, create a new player_depotitems with this data.
     */
    create: XOR<player_depotitemsCreateInput, player_depotitemsUncheckedCreateInput>
    /**
     * In case the player_depotitems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<player_depotitemsUpdateInput, player_depotitemsUncheckedUpdateInput>
  }


  /**
   * player_depotitems delete
   */
  export type player_depotitemsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_depotitems
     */
    select?: player_depotitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_depotitemsInclude<ExtArgs> | null
    /**
     * Filter which player_depotitems to delete.
     */
    where: player_depotitemsWhereUniqueInput
  }


  /**
   * player_depotitems deleteMany
   */
  export type player_depotitemsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which player_depotitems to delete
     */
    where?: player_depotitemsWhereInput
  }


  /**
   * player_depotitems without action
   */
  export type player_depotitemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_depotitems
     */
    select?: player_depotitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_depotitemsInclude<ExtArgs> | null
  }



  /**
   * Model player_inboxitems
   */


  export type AggregatePlayer_inboxitems = {
    _count: Player_inboxitemsCountAggregateOutputType | null
    _avg: Player_inboxitemsAvgAggregateOutputType | null
    _sum: Player_inboxitemsSumAggregateOutputType | null
    _min: Player_inboxitemsMinAggregateOutputType | null
    _max: Player_inboxitemsMaxAggregateOutputType | null
  }

  export type Player_inboxitemsAvgAggregateOutputType = {
    player_id: number | null
    sid: number | null
    pid: number | null
    itemtype: number | null
    count: number | null
  }

  export type Player_inboxitemsSumAggregateOutputType = {
    player_id: number | null
    sid: number | null
    pid: number | null
    itemtype: number | null
    count: number | null
  }

  export type Player_inboxitemsMinAggregateOutputType = {
    player_id: number | null
    sid: number | null
    pid: number | null
    itemtype: number | null
    count: number | null
    attributes: Buffer | null
  }

  export type Player_inboxitemsMaxAggregateOutputType = {
    player_id: number | null
    sid: number | null
    pid: number | null
    itemtype: number | null
    count: number | null
    attributes: Buffer | null
  }

  export type Player_inboxitemsCountAggregateOutputType = {
    player_id: number
    sid: number
    pid: number
    itemtype: number
    count: number
    attributes: number
    json_data: number
    _all: number
  }


  export type Player_inboxitemsAvgAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
  }

  export type Player_inboxitemsSumAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
  }

  export type Player_inboxitemsMinAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
    attributes?: true
  }

  export type Player_inboxitemsMaxAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
    attributes?: true
  }

  export type Player_inboxitemsCountAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
    attributes?: true
    json_data?: true
    _all?: true
  }

  export type Player_inboxitemsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which player_inboxitems to aggregate.
     */
    where?: player_inboxitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_inboxitems to fetch.
     */
    orderBy?: Enumerable<player_inboxitemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: player_inboxitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_inboxitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_inboxitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned player_inboxitems
    **/
    _count?: true | Player_inboxitemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Player_inboxitemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Player_inboxitemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Player_inboxitemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Player_inboxitemsMaxAggregateInputType
  }

  export type GetPlayer_inboxitemsAggregateType<T extends Player_inboxitemsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer_inboxitems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer_inboxitems[P]>
      : GetScalarType<T[P], AggregatePlayer_inboxitems[P]>
  }




  export type Player_inboxitemsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: player_inboxitemsWhereInput
    orderBy?: Enumerable<player_inboxitemsOrderByWithAggregationInput>
    by: Player_inboxitemsScalarFieldEnum[]
    having?: player_inboxitemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Player_inboxitemsCountAggregateInputType | true
    _avg?: Player_inboxitemsAvgAggregateInputType
    _sum?: Player_inboxitemsSumAggregateInputType
    _min?: Player_inboxitemsMinAggregateInputType
    _max?: Player_inboxitemsMaxAggregateInputType
  }


  export type Player_inboxitemsGroupByOutputType = {
    player_id: number
    sid: number
    pid: number
    itemtype: number
    count: number
    attributes: Buffer
    json_data: JsonValue | null
    _count: Player_inboxitemsCountAggregateOutputType | null
    _avg: Player_inboxitemsAvgAggregateOutputType | null
    _sum: Player_inboxitemsSumAggregateOutputType | null
    _min: Player_inboxitemsMinAggregateOutputType | null
    _max: Player_inboxitemsMaxAggregateOutputType | null
  }

  type GetPlayer_inboxitemsGroupByPayload<T extends Player_inboxitemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Player_inboxitemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Player_inboxitemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Player_inboxitemsGroupByOutputType[P]>
            : GetScalarType<T[P], Player_inboxitemsGroupByOutputType[P]>
        }
      >
    >


  export type player_inboxitemsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    player_id?: boolean
    sid?: boolean
    pid?: boolean
    itemtype?: boolean
    count?: boolean
    attributes?: boolean
    json_data?: boolean
    players?: boolean | PlayerArgs<ExtArgs>
  }, ExtArgs["result"]["player_inboxitems"]>

  export type player_inboxitemsSelectScalar = {
    player_id?: boolean
    sid?: boolean
    pid?: boolean
    itemtype?: boolean
    count?: boolean
    attributes?: boolean
    json_data?: boolean
  }

  export type player_inboxitemsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    players?: boolean | PlayerArgs<ExtArgs>
  }


  type player_inboxitemsGetPayload<S extends boolean | null | undefined | player_inboxitemsArgs> = $Types.GetResult<player_inboxitemsPayload, S>

  type player_inboxitemsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<player_inboxitemsFindManyArgs, 'select' | 'include'> & {
      select?: Player_inboxitemsCountAggregateInputType | true
    }

  export interface player_inboxitemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['player_inboxitems'], meta: { name: 'player_inboxitems' } }
    /**
     * Find zero or one Player_inboxitems that matches the filter.
     * @param {player_inboxitemsFindUniqueArgs} args - Arguments to find a Player_inboxitems
     * @example
     * // Get one Player_inboxitems
     * const player_inboxitems = await prisma.player_inboxitems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends player_inboxitemsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, player_inboxitemsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'player_inboxitems'> extends True ? Prisma__player_inboxitemsClient<$Types.GetResult<player_inboxitemsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__player_inboxitemsClient<$Types.GetResult<player_inboxitemsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Player_inboxitems that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {player_inboxitemsFindUniqueOrThrowArgs} args - Arguments to find a Player_inboxitems
     * @example
     * // Get one Player_inboxitems
     * const player_inboxitems = await prisma.player_inboxitems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends player_inboxitemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, player_inboxitemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__player_inboxitemsClient<$Types.GetResult<player_inboxitemsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Player_inboxitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_inboxitemsFindFirstArgs} args - Arguments to find a Player_inboxitems
     * @example
     * // Get one Player_inboxitems
     * const player_inboxitems = await prisma.player_inboxitems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends player_inboxitemsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, player_inboxitemsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'player_inboxitems'> extends True ? Prisma__player_inboxitemsClient<$Types.GetResult<player_inboxitemsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__player_inboxitemsClient<$Types.GetResult<player_inboxitemsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Player_inboxitems that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_inboxitemsFindFirstOrThrowArgs} args - Arguments to find a Player_inboxitems
     * @example
     * // Get one Player_inboxitems
     * const player_inboxitems = await prisma.player_inboxitems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends player_inboxitemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, player_inboxitemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__player_inboxitemsClient<$Types.GetResult<player_inboxitemsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Player_inboxitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_inboxitemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Player_inboxitems
     * const player_inboxitems = await prisma.player_inboxitems.findMany()
     * 
     * // Get first 10 Player_inboxitems
     * const player_inboxitems = await prisma.player_inboxitems.findMany({ take: 10 })
     * 
     * // Only select the `player_id`
     * const player_inboxitemsWithPlayer_idOnly = await prisma.player_inboxitems.findMany({ select: { player_id: true } })
     * 
    **/
    findMany<T extends player_inboxitemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_inboxitemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<player_inboxitemsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Player_inboxitems.
     * @param {player_inboxitemsCreateArgs} args - Arguments to create a Player_inboxitems.
     * @example
     * // Create one Player_inboxitems
     * const Player_inboxitems = await prisma.player_inboxitems.create({
     *   data: {
     *     // ... data to create a Player_inboxitems
     *   }
     * })
     * 
    **/
    create<T extends player_inboxitemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, player_inboxitemsCreateArgs<ExtArgs>>
    ): Prisma__player_inboxitemsClient<$Types.GetResult<player_inboxitemsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Player_inboxitems.
     *     @param {player_inboxitemsCreateManyArgs} args - Arguments to create many Player_inboxitems.
     *     @example
     *     // Create many Player_inboxitems
     *     const player_inboxitems = await prisma.player_inboxitems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends player_inboxitemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_inboxitemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Player_inboxitems.
     * @param {player_inboxitemsDeleteArgs} args - Arguments to delete one Player_inboxitems.
     * @example
     * // Delete one Player_inboxitems
     * const Player_inboxitems = await prisma.player_inboxitems.delete({
     *   where: {
     *     // ... filter to delete one Player_inboxitems
     *   }
     * })
     * 
    **/
    delete<T extends player_inboxitemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, player_inboxitemsDeleteArgs<ExtArgs>>
    ): Prisma__player_inboxitemsClient<$Types.GetResult<player_inboxitemsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Player_inboxitems.
     * @param {player_inboxitemsUpdateArgs} args - Arguments to update one Player_inboxitems.
     * @example
     * // Update one Player_inboxitems
     * const player_inboxitems = await prisma.player_inboxitems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends player_inboxitemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, player_inboxitemsUpdateArgs<ExtArgs>>
    ): Prisma__player_inboxitemsClient<$Types.GetResult<player_inboxitemsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Player_inboxitems.
     * @param {player_inboxitemsDeleteManyArgs} args - Arguments to filter Player_inboxitems to delete.
     * @example
     * // Delete a few Player_inboxitems
     * const { count } = await prisma.player_inboxitems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends player_inboxitemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_inboxitemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Player_inboxitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_inboxitemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Player_inboxitems
     * const player_inboxitems = await prisma.player_inboxitems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends player_inboxitemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, player_inboxitemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Player_inboxitems.
     * @param {player_inboxitemsUpsertArgs} args - Arguments to update or create a Player_inboxitems.
     * @example
     * // Update or create a Player_inboxitems
     * const player_inboxitems = await prisma.player_inboxitems.upsert({
     *   create: {
     *     // ... data to create a Player_inboxitems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player_inboxitems we want to update
     *   }
     * })
    **/
    upsert<T extends player_inboxitemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, player_inboxitemsUpsertArgs<ExtArgs>>
    ): Prisma__player_inboxitemsClient<$Types.GetResult<player_inboxitemsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Player_inboxitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_inboxitemsCountArgs} args - Arguments to filter Player_inboxitems to count.
     * @example
     * // Count the number of Player_inboxitems
     * const count = await prisma.player_inboxitems.count({
     *   where: {
     *     // ... the filter for the Player_inboxitems we want to count
     *   }
     * })
    **/
    count<T extends player_inboxitemsCountArgs>(
      args?: Subset<T, player_inboxitemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Player_inboxitemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player_inboxitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Player_inboxitemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Player_inboxitemsAggregateArgs>(args: Subset<T, Player_inboxitemsAggregateArgs>): Prisma.PrismaPromise<GetPlayer_inboxitemsAggregateType<T>>

    /**
     * Group by Player_inboxitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Player_inboxitemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Player_inboxitemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Player_inboxitemsGroupByArgs['orderBy'] }
        : { orderBy?: Player_inboxitemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Player_inboxitemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayer_inboxitemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for player_inboxitems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__player_inboxitemsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    players<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * player_inboxitems base type for findUnique actions
   */
  export type player_inboxitemsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_inboxitems
     */
    select?: player_inboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_inboxitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_inboxitems to fetch.
     */
    where: player_inboxitemsWhereUniqueInput
  }

  /**
   * player_inboxitems findUnique
   */
  export interface player_inboxitemsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends player_inboxitemsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * player_inboxitems findUniqueOrThrow
   */
  export type player_inboxitemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_inboxitems
     */
    select?: player_inboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_inboxitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_inboxitems to fetch.
     */
    where: player_inboxitemsWhereUniqueInput
  }


  /**
   * player_inboxitems base type for findFirst actions
   */
  export type player_inboxitemsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_inboxitems
     */
    select?: player_inboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_inboxitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_inboxitems to fetch.
     */
    where?: player_inboxitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_inboxitems to fetch.
     */
    orderBy?: Enumerable<player_inboxitemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for player_inboxitems.
     */
    cursor?: player_inboxitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_inboxitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_inboxitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of player_inboxitems.
     */
    distinct?: Enumerable<Player_inboxitemsScalarFieldEnum>
  }

  /**
   * player_inboxitems findFirst
   */
  export interface player_inboxitemsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends player_inboxitemsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * player_inboxitems findFirstOrThrow
   */
  export type player_inboxitemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_inboxitems
     */
    select?: player_inboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_inboxitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_inboxitems to fetch.
     */
    where?: player_inboxitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_inboxitems to fetch.
     */
    orderBy?: Enumerable<player_inboxitemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for player_inboxitems.
     */
    cursor?: player_inboxitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_inboxitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_inboxitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of player_inboxitems.
     */
    distinct?: Enumerable<Player_inboxitemsScalarFieldEnum>
  }


  /**
   * player_inboxitems findMany
   */
  export type player_inboxitemsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_inboxitems
     */
    select?: player_inboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_inboxitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_inboxitems to fetch.
     */
    where?: player_inboxitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_inboxitems to fetch.
     */
    orderBy?: Enumerable<player_inboxitemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing player_inboxitems.
     */
    cursor?: player_inboxitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_inboxitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_inboxitems.
     */
    skip?: number
    distinct?: Enumerable<Player_inboxitemsScalarFieldEnum>
  }


  /**
   * player_inboxitems create
   */
  export type player_inboxitemsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_inboxitems
     */
    select?: player_inboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_inboxitemsInclude<ExtArgs> | null
    /**
     * The data needed to create a player_inboxitems.
     */
    data: XOR<player_inboxitemsCreateInput, player_inboxitemsUncheckedCreateInput>
  }


  /**
   * player_inboxitems createMany
   */
  export type player_inboxitemsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many player_inboxitems.
     */
    data: Enumerable<player_inboxitemsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * player_inboxitems update
   */
  export type player_inboxitemsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_inboxitems
     */
    select?: player_inboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_inboxitemsInclude<ExtArgs> | null
    /**
     * The data needed to update a player_inboxitems.
     */
    data: XOR<player_inboxitemsUpdateInput, player_inboxitemsUncheckedUpdateInput>
    /**
     * Choose, which player_inboxitems to update.
     */
    where: player_inboxitemsWhereUniqueInput
  }


  /**
   * player_inboxitems updateMany
   */
  export type player_inboxitemsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update player_inboxitems.
     */
    data: XOR<player_inboxitemsUpdateManyMutationInput, player_inboxitemsUncheckedUpdateManyInput>
    /**
     * Filter which player_inboxitems to update
     */
    where?: player_inboxitemsWhereInput
  }


  /**
   * player_inboxitems upsert
   */
  export type player_inboxitemsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_inboxitems
     */
    select?: player_inboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_inboxitemsInclude<ExtArgs> | null
    /**
     * The filter to search for the player_inboxitems to update in case it exists.
     */
    where: player_inboxitemsWhereUniqueInput
    /**
     * In case the player_inboxitems found by the `where` argument doesn't exist, create a new player_inboxitems with this data.
     */
    create: XOR<player_inboxitemsCreateInput, player_inboxitemsUncheckedCreateInput>
    /**
     * In case the player_inboxitems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<player_inboxitemsUpdateInput, player_inboxitemsUncheckedUpdateInput>
  }


  /**
   * player_inboxitems delete
   */
  export type player_inboxitemsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_inboxitems
     */
    select?: player_inboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_inboxitemsInclude<ExtArgs> | null
    /**
     * Filter which player_inboxitems to delete.
     */
    where: player_inboxitemsWhereUniqueInput
  }


  /**
   * player_inboxitems deleteMany
   */
  export type player_inboxitemsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which player_inboxitems to delete
     */
    where?: player_inboxitemsWhereInput
  }


  /**
   * player_inboxitems without action
   */
  export type player_inboxitemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_inboxitems
     */
    select?: player_inboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_inboxitemsInclude<ExtArgs> | null
  }



  /**
   * Model player_namelocks
   */


  export type AggregatePlayer_namelocks = {
    _count: Player_namelocksCountAggregateOutputType | null
    _avg: Player_namelocksAvgAggregateOutputType | null
    _sum: Player_namelocksSumAggregateOutputType | null
    _min: Player_namelocksMinAggregateOutputType | null
    _max: Player_namelocksMaxAggregateOutputType | null
  }

  export type Player_namelocksAvgAggregateOutputType = {
    player_id: number | null
    namelocked_at: number | null
    namelocked_by: number | null
  }

  export type Player_namelocksSumAggregateOutputType = {
    player_id: number | null
    namelocked_at: bigint | null
    namelocked_by: number | null
  }

  export type Player_namelocksMinAggregateOutputType = {
    player_id: number | null
    reason: string | null
    namelocked_at: bigint | null
    namelocked_by: number | null
  }

  export type Player_namelocksMaxAggregateOutputType = {
    player_id: number | null
    reason: string | null
    namelocked_at: bigint | null
    namelocked_by: number | null
  }

  export type Player_namelocksCountAggregateOutputType = {
    player_id: number
    reason: number
    namelocked_at: number
    namelocked_by: number
    _all: number
  }


  export type Player_namelocksAvgAggregateInputType = {
    player_id?: true
    namelocked_at?: true
    namelocked_by?: true
  }

  export type Player_namelocksSumAggregateInputType = {
    player_id?: true
    namelocked_at?: true
    namelocked_by?: true
  }

  export type Player_namelocksMinAggregateInputType = {
    player_id?: true
    reason?: true
    namelocked_at?: true
    namelocked_by?: true
  }

  export type Player_namelocksMaxAggregateInputType = {
    player_id?: true
    reason?: true
    namelocked_at?: true
    namelocked_by?: true
  }

  export type Player_namelocksCountAggregateInputType = {
    player_id?: true
    reason?: true
    namelocked_at?: true
    namelocked_by?: true
    _all?: true
  }

  export type Player_namelocksAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which player_namelocks to aggregate.
     */
    where?: player_namelocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_namelocks to fetch.
     */
    orderBy?: Enumerable<player_namelocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: player_namelocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_namelocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_namelocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned player_namelocks
    **/
    _count?: true | Player_namelocksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Player_namelocksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Player_namelocksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Player_namelocksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Player_namelocksMaxAggregateInputType
  }

  export type GetPlayer_namelocksAggregateType<T extends Player_namelocksAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer_namelocks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer_namelocks[P]>
      : GetScalarType<T[P], AggregatePlayer_namelocks[P]>
  }




  export type Player_namelocksGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: player_namelocksWhereInput
    orderBy?: Enumerable<player_namelocksOrderByWithAggregationInput>
    by: Player_namelocksScalarFieldEnum[]
    having?: player_namelocksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Player_namelocksCountAggregateInputType | true
    _avg?: Player_namelocksAvgAggregateInputType
    _sum?: Player_namelocksSumAggregateInputType
    _min?: Player_namelocksMinAggregateInputType
    _max?: Player_namelocksMaxAggregateInputType
  }


  export type Player_namelocksGroupByOutputType = {
    player_id: number
    reason: string
    namelocked_at: bigint
    namelocked_by: number
    _count: Player_namelocksCountAggregateOutputType | null
    _avg: Player_namelocksAvgAggregateOutputType | null
    _sum: Player_namelocksSumAggregateOutputType | null
    _min: Player_namelocksMinAggregateOutputType | null
    _max: Player_namelocksMaxAggregateOutputType | null
  }

  type GetPlayer_namelocksGroupByPayload<T extends Player_namelocksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Player_namelocksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Player_namelocksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Player_namelocksGroupByOutputType[P]>
            : GetScalarType<T[P], Player_namelocksGroupByOutputType[P]>
        }
      >
    >


  export type player_namelocksSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    player_id?: boolean
    reason?: boolean
    namelocked_at?: boolean
    namelocked_by?: boolean
    players_player_namelocks_player_idToplayers?: boolean | PlayerArgs<ExtArgs>
    players_player_namelocks_namelocked_byToplayers?: boolean | PlayerArgs<ExtArgs>
  }, ExtArgs["result"]["player_namelocks"]>

  export type player_namelocksSelectScalar = {
    player_id?: boolean
    reason?: boolean
    namelocked_at?: boolean
    namelocked_by?: boolean
  }

  export type player_namelocksInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    players_player_namelocks_player_idToplayers?: boolean | PlayerArgs<ExtArgs>
    players_player_namelocks_namelocked_byToplayers?: boolean | PlayerArgs<ExtArgs>
  }


  type player_namelocksGetPayload<S extends boolean | null | undefined | player_namelocksArgs> = $Types.GetResult<player_namelocksPayload, S>

  type player_namelocksCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<player_namelocksFindManyArgs, 'select' | 'include'> & {
      select?: Player_namelocksCountAggregateInputType | true
    }

  export interface player_namelocksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['player_namelocks'], meta: { name: 'player_namelocks' } }
    /**
     * Find zero or one Player_namelocks that matches the filter.
     * @param {player_namelocksFindUniqueArgs} args - Arguments to find a Player_namelocks
     * @example
     * // Get one Player_namelocks
     * const player_namelocks = await prisma.player_namelocks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends player_namelocksFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, player_namelocksFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'player_namelocks'> extends True ? Prisma__player_namelocksClient<$Types.GetResult<player_namelocksPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__player_namelocksClient<$Types.GetResult<player_namelocksPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Player_namelocks that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {player_namelocksFindUniqueOrThrowArgs} args - Arguments to find a Player_namelocks
     * @example
     * // Get one Player_namelocks
     * const player_namelocks = await prisma.player_namelocks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends player_namelocksFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, player_namelocksFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__player_namelocksClient<$Types.GetResult<player_namelocksPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Player_namelocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_namelocksFindFirstArgs} args - Arguments to find a Player_namelocks
     * @example
     * // Get one Player_namelocks
     * const player_namelocks = await prisma.player_namelocks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends player_namelocksFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, player_namelocksFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'player_namelocks'> extends True ? Prisma__player_namelocksClient<$Types.GetResult<player_namelocksPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__player_namelocksClient<$Types.GetResult<player_namelocksPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Player_namelocks that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_namelocksFindFirstOrThrowArgs} args - Arguments to find a Player_namelocks
     * @example
     * // Get one Player_namelocks
     * const player_namelocks = await prisma.player_namelocks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends player_namelocksFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, player_namelocksFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__player_namelocksClient<$Types.GetResult<player_namelocksPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Player_namelocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_namelocksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Player_namelocks
     * const player_namelocks = await prisma.player_namelocks.findMany()
     * 
     * // Get first 10 Player_namelocks
     * const player_namelocks = await prisma.player_namelocks.findMany({ take: 10 })
     * 
     * // Only select the `player_id`
     * const player_namelocksWithPlayer_idOnly = await prisma.player_namelocks.findMany({ select: { player_id: true } })
     * 
    **/
    findMany<T extends player_namelocksFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_namelocksFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<player_namelocksPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Player_namelocks.
     * @param {player_namelocksCreateArgs} args - Arguments to create a Player_namelocks.
     * @example
     * // Create one Player_namelocks
     * const Player_namelocks = await prisma.player_namelocks.create({
     *   data: {
     *     // ... data to create a Player_namelocks
     *   }
     * })
     * 
    **/
    create<T extends player_namelocksCreateArgs<ExtArgs>>(
      args: SelectSubset<T, player_namelocksCreateArgs<ExtArgs>>
    ): Prisma__player_namelocksClient<$Types.GetResult<player_namelocksPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Player_namelocks.
     *     @param {player_namelocksCreateManyArgs} args - Arguments to create many Player_namelocks.
     *     @example
     *     // Create many Player_namelocks
     *     const player_namelocks = await prisma.player_namelocks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends player_namelocksCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_namelocksCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Player_namelocks.
     * @param {player_namelocksDeleteArgs} args - Arguments to delete one Player_namelocks.
     * @example
     * // Delete one Player_namelocks
     * const Player_namelocks = await prisma.player_namelocks.delete({
     *   where: {
     *     // ... filter to delete one Player_namelocks
     *   }
     * })
     * 
    **/
    delete<T extends player_namelocksDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, player_namelocksDeleteArgs<ExtArgs>>
    ): Prisma__player_namelocksClient<$Types.GetResult<player_namelocksPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Player_namelocks.
     * @param {player_namelocksUpdateArgs} args - Arguments to update one Player_namelocks.
     * @example
     * // Update one Player_namelocks
     * const player_namelocks = await prisma.player_namelocks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends player_namelocksUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, player_namelocksUpdateArgs<ExtArgs>>
    ): Prisma__player_namelocksClient<$Types.GetResult<player_namelocksPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Player_namelocks.
     * @param {player_namelocksDeleteManyArgs} args - Arguments to filter Player_namelocks to delete.
     * @example
     * // Delete a few Player_namelocks
     * const { count } = await prisma.player_namelocks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends player_namelocksDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_namelocksDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Player_namelocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_namelocksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Player_namelocks
     * const player_namelocks = await prisma.player_namelocks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends player_namelocksUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, player_namelocksUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Player_namelocks.
     * @param {player_namelocksUpsertArgs} args - Arguments to update or create a Player_namelocks.
     * @example
     * // Update or create a Player_namelocks
     * const player_namelocks = await prisma.player_namelocks.upsert({
     *   create: {
     *     // ... data to create a Player_namelocks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player_namelocks we want to update
     *   }
     * })
    **/
    upsert<T extends player_namelocksUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, player_namelocksUpsertArgs<ExtArgs>>
    ): Prisma__player_namelocksClient<$Types.GetResult<player_namelocksPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Player_namelocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_namelocksCountArgs} args - Arguments to filter Player_namelocks to count.
     * @example
     * // Count the number of Player_namelocks
     * const count = await prisma.player_namelocks.count({
     *   where: {
     *     // ... the filter for the Player_namelocks we want to count
     *   }
     * })
    **/
    count<T extends player_namelocksCountArgs>(
      args?: Subset<T, player_namelocksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Player_namelocksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player_namelocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Player_namelocksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Player_namelocksAggregateArgs>(args: Subset<T, Player_namelocksAggregateArgs>): Prisma.PrismaPromise<GetPlayer_namelocksAggregateType<T>>

    /**
     * Group by Player_namelocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Player_namelocksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Player_namelocksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Player_namelocksGroupByArgs['orderBy'] }
        : { orderBy?: Player_namelocksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Player_namelocksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayer_namelocksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for player_namelocks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__player_namelocksClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    players_player_namelocks_player_idToplayers<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    players_player_namelocks_namelocked_byToplayers<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * player_namelocks base type for findUnique actions
   */
  export type player_namelocksFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_namelocks
     */
    select?: player_namelocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_namelocksInclude<ExtArgs> | null
    /**
     * Filter, which player_namelocks to fetch.
     */
    where: player_namelocksWhereUniqueInput
  }

  /**
   * player_namelocks findUnique
   */
  export interface player_namelocksFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends player_namelocksFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * player_namelocks findUniqueOrThrow
   */
  export type player_namelocksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_namelocks
     */
    select?: player_namelocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_namelocksInclude<ExtArgs> | null
    /**
     * Filter, which player_namelocks to fetch.
     */
    where: player_namelocksWhereUniqueInput
  }


  /**
   * player_namelocks base type for findFirst actions
   */
  export type player_namelocksFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_namelocks
     */
    select?: player_namelocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_namelocksInclude<ExtArgs> | null
    /**
     * Filter, which player_namelocks to fetch.
     */
    where?: player_namelocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_namelocks to fetch.
     */
    orderBy?: Enumerable<player_namelocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for player_namelocks.
     */
    cursor?: player_namelocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_namelocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_namelocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of player_namelocks.
     */
    distinct?: Enumerable<Player_namelocksScalarFieldEnum>
  }

  /**
   * player_namelocks findFirst
   */
  export interface player_namelocksFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends player_namelocksFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * player_namelocks findFirstOrThrow
   */
  export type player_namelocksFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_namelocks
     */
    select?: player_namelocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_namelocksInclude<ExtArgs> | null
    /**
     * Filter, which player_namelocks to fetch.
     */
    where?: player_namelocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_namelocks to fetch.
     */
    orderBy?: Enumerable<player_namelocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for player_namelocks.
     */
    cursor?: player_namelocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_namelocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_namelocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of player_namelocks.
     */
    distinct?: Enumerable<Player_namelocksScalarFieldEnum>
  }


  /**
   * player_namelocks findMany
   */
  export type player_namelocksFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_namelocks
     */
    select?: player_namelocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_namelocksInclude<ExtArgs> | null
    /**
     * Filter, which player_namelocks to fetch.
     */
    where?: player_namelocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_namelocks to fetch.
     */
    orderBy?: Enumerable<player_namelocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing player_namelocks.
     */
    cursor?: player_namelocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_namelocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_namelocks.
     */
    skip?: number
    distinct?: Enumerable<Player_namelocksScalarFieldEnum>
  }


  /**
   * player_namelocks create
   */
  export type player_namelocksCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_namelocks
     */
    select?: player_namelocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_namelocksInclude<ExtArgs> | null
    /**
     * The data needed to create a player_namelocks.
     */
    data: XOR<player_namelocksCreateInput, player_namelocksUncheckedCreateInput>
  }


  /**
   * player_namelocks createMany
   */
  export type player_namelocksCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many player_namelocks.
     */
    data: Enumerable<player_namelocksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * player_namelocks update
   */
  export type player_namelocksUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_namelocks
     */
    select?: player_namelocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_namelocksInclude<ExtArgs> | null
    /**
     * The data needed to update a player_namelocks.
     */
    data: XOR<player_namelocksUpdateInput, player_namelocksUncheckedUpdateInput>
    /**
     * Choose, which player_namelocks to update.
     */
    where: player_namelocksWhereUniqueInput
  }


  /**
   * player_namelocks updateMany
   */
  export type player_namelocksUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update player_namelocks.
     */
    data: XOR<player_namelocksUpdateManyMutationInput, player_namelocksUncheckedUpdateManyInput>
    /**
     * Filter which player_namelocks to update
     */
    where?: player_namelocksWhereInput
  }


  /**
   * player_namelocks upsert
   */
  export type player_namelocksUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_namelocks
     */
    select?: player_namelocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_namelocksInclude<ExtArgs> | null
    /**
     * The filter to search for the player_namelocks to update in case it exists.
     */
    where: player_namelocksWhereUniqueInput
    /**
     * In case the player_namelocks found by the `where` argument doesn't exist, create a new player_namelocks with this data.
     */
    create: XOR<player_namelocksCreateInput, player_namelocksUncheckedCreateInput>
    /**
     * In case the player_namelocks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<player_namelocksUpdateInput, player_namelocksUncheckedUpdateInput>
  }


  /**
   * player_namelocks delete
   */
  export type player_namelocksDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_namelocks
     */
    select?: player_namelocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_namelocksInclude<ExtArgs> | null
    /**
     * Filter which player_namelocks to delete.
     */
    where: player_namelocksWhereUniqueInput
  }


  /**
   * player_namelocks deleteMany
   */
  export type player_namelocksDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which player_namelocks to delete
     */
    where?: player_namelocksWhereInput
  }


  /**
   * player_namelocks without action
   */
  export type player_namelocksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_namelocks
     */
    select?: player_namelocksSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_namelocksInclude<ExtArgs> | null
  }



  /**
   * Model player_storage
   */


  export type AggregatePlayer_storage = {
    _count: Player_storageCountAggregateOutputType | null
    _avg: Player_storageAvgAggregateOutputType | null
    _sum: Player_storageSumAggregateOutputType | null
    _min: Player_storageMinAggregateOutputType | null
    _max: Player_storageMaxAggregateOutputType | null
  }

  export type Player_storageAvgAggregateOutputType = {
    player_id: number | null
    key: number | null
    value: number | null
  }

  export type Player_storageSumAggregateOutputType = {
    player_id: number | null
    key: number | null
    value: number | null
  }

  export type Player_storageMinAggregateOutputType = {
    player_id: number | null
    key: number | null
    value: number | null
  }

  export type Player_storageMaxAggregateOutputType = {
    player_id: number | null
    key: number | null
    value: number | null
  }

  export type Player_storageCountAggregateOutputType = {
    player_id: number
    key: number
    value: number
    _all: number
  }


  export type Player_storageAvgAggregateInputType = {
    player_id?: true
    key?: true
    value?: true
  }

  export type Player_storageSumAggregateInputType = {
    player_id?: true
    key?: true
    value?: true
  }

  export type Player_storageMinAggregateInputType = {
    player_id?: true
    key?: true
    value?: true
  }

  export type Player_storageMaxAggregateInputType = {
    player_id?: true
    key?: true
    value?: true
  }

  export type Player_storageCountAggregateInputType = {
    player_id?: true
    key?: true
    value?: true
    _all?: true
  }

  export type Player_storageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which player_storage to aggregate.
     */
    where?: player_storageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_storages to fetch.
     */
    orderBy?: Enumerable<player_storageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: player_storageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned player_storages
    **/
    _count?: true | Player_storageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Player_storageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Player_storageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Player_storageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Player_storageMaxAggregateInputType
  }

  export type GetPlayer_storageAggregateType<T extends Player_storageAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer_storage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer_storage[P]>
      : GetScalarType<T[P], AggregatePlayer_storage[P]>
  }




  export type Player_storageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: player_storageWhereInput
    orderBy?: Enumerable<player_storageOrderByWithAggregationInput>
    by: Player_storageScalarFieldEnum[]
    having?: player_storageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Player_storageCountAggregateInputType | true
    _avg?: Player_storageAvgAggregateInputType
    _sum?: Player_storageSumAggregateInputType
    _min?: Player_storageMinAggregateInputType
    _max?: Player_storageMaxAggregateInputType
  }


  export type Player_storageGroupByOutputType = {
    player_id: number
    key: number
    value: number
    _count: Player_storageCountAggregateOutputType | null
    _avg: Player_storageAvgAggregateOutputType | null
    _sum: Player_storageSumAggregateOutputType | null
    _min: Player_storageMinAggregateOutputType | null
    _max: Player_storageMaxAggregateOutputType | null
  }

  type GetPlayer_storageGroupByPayload<T extends Player_storageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Player_storageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Player_storageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Player_storageGroupByOutputType[P]>
            : GetScalarType<T[P], Player_storageGroupByOutputType[P]>
        }
      >
    >


  export type player_storageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    player_id?: boolean
    key?: boolean
    value?: boolean
    players?: boolean | PlayerArgs<ExtArgs>
  }, ExtArgs["result"]["player_storage"]>

  export type player_storageSelectScalar = {
    player_id?: boolean
    key?: boolean
    value?: boolean
  }

  export type player_storageInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    players?: boolean | PlayerArgs<ExtArgs>
  }


  type player_storageGetPayload<S extends boolean | null | undefined | player_storageArgs> = $Types.GetResult<player_storagePayload, S>

  type player_storageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<player_storageFindManyArgs, 'select' | 'include'> & {
      select?: Player_storageCountAggregateInputType | true
    }

  export interface player_storageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['player_storage'], meta: { name: 'player_storage' } }
    /**
     * Find zero or one Player_storage that matches the filter.
     * @param {player_storageFindUniqueArgs} args - Arguments to find a Player_storage
     * @example
     * // Get one Player_storage
     * const player_storage = await prisma.player_storage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends player_storageFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, player_storageFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'player_storage'> extends True ? Prisma__player_storageClient<$Types.GetResult<player_storagePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__player_storageClient<$Types.GetResult<player_storagePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Player_storage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {player_storageFindUniqueOrThrowArgs} args - Arguments to find a Player_storage
     * @example
     * // Get one Player_storage
     * const player_storage = await prisma.player_storage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends player_storageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, player_storageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__player_storageClient<$Types.GetResult<player_storagePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Player_storage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_storageFindFirstArgs} args - Arguments to find a Player_storage
     * @example
     * // Get one Player_storage
     * const player_storage = await prisma.player_storage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends player_storageFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, player_storageFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'player_storage'> extends True ? Prisma__player_storageClient<$Types.GetResult<player_storagePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__player_storageClient<$Types.GetResult<player_storagePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Player_storage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_storageFindFirstOrThrowArgs} args - Arguments to find a Player_storage
     * @example
     * // Get one Player_storage
     * const player_storage = await prisma.player_storage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends player_storageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, player_storageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__player_storageClient<$Types.GetResult<player_storagePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Player_storages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_storageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Player_storages
     * const player_storages = await prisma.player_storage.findMany()
     * 
     * // Get first 10 Player_storages
     * const player_storages = await prisma.player_storage.findMany({ take: 10 })
     * 
     * // Only select the `player_id`
     * const player_storageWithPlayer_idOnly = await prisma.player_storage.findMany({ select: { player_id: true } })
     * 
    **/
    findMany<T extends player_storageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_storageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<player_storagePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Player_storage.
     * @param {player_storageCreateArgs} args - Arguments to create a Player_storage.
     * @example
     * // Create one Player_storage
     * const Player_storage = await prisma.player_storage.create({
     *   data: {
     *     // ... data to create a Player_storage
     *   }
     * })
     * 
    **/
    create<T extends player_storageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, player_storageCreateArgs<ExtArgs>>
    ): Prisma__player_storageClient<$Types.GetResult<player_storagePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Player_storages.
     *     @param {player_storageCreateManyArgs} args - Arguments to create many Player_storages.
     *     @example
     *     // Create many Player_storages
     *     const player_storage = await prisma.player_storage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends player_storageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_storageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Player_storage.
     * @param {player_storageDeleteArgs} args - Arguments to delete one Player_storage.
     * @example
     * // Delete one Player_storage
     * const Player_storage = await prisma.player_storage.delete({
     *   where: {
     *     // ... filter to delete one Player_storage
     *   }
     * })
     * 
    **/
    delete<T extends player_storageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, player_storageDeleteArgs<ExtArgs>>
    ): Prisma__player_storageClient<$Types.GetResult<player_storagePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Player_storage.
     * @param {player_storageUpdateArgs} args - Arguments to update one Player_storage.
     * @example
     * // Update one Player_storage
     * const player_storage = await prisma.player_storage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends player_storageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, player_storageUpdateArgs<ExtArgs>>
    ): Prisma__player_storageClient<$Types.GetResult<player_storagePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Player_storages.
     * @param {player_storageDeleteManyArgs} args - Arguments to filter Player_storages to delete.
     * @example
     * // Delete a few Player_storages
     * const { count } = await prisma.player_storage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends player_storageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_storageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Player_storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_storageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Player_storages
     * const player_storage = await prisma.player_storage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends player_storageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, player_storageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Player_storage.
     * @param {player_storageUpsertArgs} args - Arguments to update or create a Player_storage.
     * @example
     * // Update or create a Player_storage
     * const player_storage = await prisma.player_storage.upsert({
     *   create: {
     *     // ... data to create a Player_storage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player_storage we want to update
     *   }
     * })
    **/
    upsert<T extends player_storageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, player_storageUpsertArgs<ExtArgs>>
    ): Prisma__player_storageClient<$Types.GetResult<player_storagePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Player_storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_storageCountArgs} args - Arguments to filter Player_storages to count.
     * @example
     * // Count the number of Player_storages
     * const count = await prisma.player_storage.count({
     *   where: {
     *     // ... the filter for the Player_storages we want to count
     *   }
     * })
    **/
    count<T extends player_storageCountArgs>(
      args?: Subset<T, player_storageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Player_storageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player_storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Player_storageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Player_storageAggregateArgs>(args: Subset<T, Player_storageAggregateArgs>): Prisma.PrismaPromise<GetPlayer_storageAggregateType<T>>

    /**
     * Group by Player_storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Player_storageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Player_storageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Player_storageGroupByArgs['orderBy'] }
        : { orderBy?: Player_storageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Player_storageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayer_storageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for player_storage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__player_storageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    players<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * player_storage base type for findUnique actions
   */
  export type player_storageFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storage
     */
    select?: player_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storageInclude<ExtArgs> | null
    /**
     * Filter, which player_storage to fetch.
     */
    where: player_storageWhereUniqueInput
  }

  /**
   * player_storage findUnique
   */
  export interface player_storageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends player_storageFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * player_storage findUniqueOrThrow
   */
  export type player_storageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storage
     */
    select?: player_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storageInclude<ExtArgs> | null
    /**
     * Filter, which player_storage to fetch.
     */
    where: player_storageWhereUniqueInput
  }


  /**
   * player_storage base type for findFirst actions
   */
  export type player_storageFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storage
     */
    select?: player_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storageInclude<ExtArgs> | null
    /**
     * Filter, which player_storage to fetch.
     */
    where?: player_storageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_storages to fetch.
     */
    orderBy?: Enumerable<player_storageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for player_storages.
     */
    cursor?: player_storageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of player_storages.
     */
    distinct?: Enumerable<Player_storageScalarFieldEnum>
  }

  /**
   * player_storage findFirst
   */
  export interface player_storageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends player_storageFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * player_storage findFirstOrThrow
   */
  export type player_storageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storage
     */
    select?: player_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storageInclude<ExtArgs> | null
    /**
     * Filter, which player_storage to fetch.
     */
    where?: player_storageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_storages to fetch.
     */
    orderBy?: Enumerable<player_storageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for player_storages.
     */
    cursor?: player_storageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of player_storages.
     */
    distinct?: Enumerable<Player_storageScalarFieldEnum>
  }


  /**
   * player_storage findMany
   */
  export type player_storageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storage
     */
    select?: player_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storageInclude<ExtArgs> | null
    /**
     * Filter, which player_storages to fetch.
     */
    where?: player_storageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_storages to fetch.
     */
    orderBy?: Enumerable<player_storageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing player_storages.
     */
    cursor?: player_storageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_storages.
     */
    skip?: number
    distinct?: Enumerable<Player_storageScalarFieldEnum>
  }


  /**
   * player_storage create
   */
  export type player_storageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storage
     */
    select?: player_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storageInclude<ExtArgs> | null
    /**
     * The data needed to create a player_storage.
     */
    data: XOR<player_storageCreateInput, player_storageUncheckedCreateInput>
  }


  /**
   * player_storage createMany
   */
  export type player_storageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many player_storages.
     */
    data: Enumerable<player_storageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * player_storage update
   */
  export type player_storageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storage
     */
    select?: player_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storageInclude<ExtArgs> | null
    /**
     * The data needed to update a player_storage.
     */
    data: XOR<player_storageUpdateInput, player_storageUncheckedUpdateInput>
    /**
     * Choose, which player_storage to update.
     */
    where: player_storageWhereUniqueInput
  }


  /**
   * player_storage updateMany
   */
  export type player_storageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update player_storages.
     */
    data: XOR<player_storageUpdateManyMutationInput, player_storageUncheckedUpdateManyInput>
    /**
     * Filter which player_storages to update
     */
    where?: player_storageWhereInput
  }


  /**
   * player_storage upsert
   */
  export type player_storageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storage
     */
    select?: player_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storageInclude<ExtArgs> | null
    /**
     * The filter to search for the player_storage to update in case it exists.
     */
    where: player_storageWhereUniqueInput
    /**
     * In case the player_storage found by the `where` argument doesn't exist, create a new player_storage with this data.
     */
    create: XOR<player_storageCreateInput, player_storageUncheckedCreateInput>
    /**
     * In case the player_storage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<player_storageUpdateInput, player_storageUncheckedUpdateInput>
  }


  /**
   * player_storage delete
   */
  export type player_storageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storage
     */
    select?: player_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storageInclude<ExtArgs> | null
    /**
     * Filter which player_storage to delete.
     */
    where: player_storageWhereUniqueInput
  }


  /**
   * player_storage deleteMany
   */
  export type player_storageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which player_storages to delete
     */
    where?: player_storageWhereInput
  }


  /**
   * player_storage without action
   */
  export type player_storageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storage
     */
    select?: player_storageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storageInclude<ExtArgs> | null
  }



  /**
   * Model player_storeinboxitems
   */


  export type AggregatePlayer_storeinboxitems = {
    _count: Player_storeinboxitemsCountAggregateOutputType | null
    _avg: Player_storeinboxitemsAvgAggregateOutputType | null
    _sum: Player_storeinboxitemsSumAggregateOutputType | null
    _min: Player_storeinboxitemsMinAggregateOutputType | null
    _max: Player_storeinboxitemsMaxAggregateOutputType | null
  }

  export type Player_storeinboxitemsAvgAggregateOutputType = {
    player_id: number | null
    sid: number | null
    pid: number | null
    itemtype: number | null
    count: number | null
  }

  export type Player_storeinboxitemsSumAggregateOutputType = {
    player_id: number | null
    sid: number | null
    pid: number | null
    itemtype: number | null
    count: number | null
  }

  export type Player_storeinboxitemsMinAggregateOutputType = {
    player_id: number | null
    sid: number | null
    pid: number | null
    itemtype: number | null
    count: number | null
    attributes: Buffer | null
  }

  export type Player_storeinboxitemsMaxAggregateOutputType = {
    player_id: number | null
    sid: number | null
    pid: number | null
    itemtype: number | null
    count: number | null
    attributes: Buffer | null
  }

  export type Player_storeinboxitemsCountAggregateOutputType = {
    player_id: number
    sid: number
    pid: number
    itemtype: number
    count: number
    attributes: number
    json_data: number
    _all: number
  }


  export type Player_storeinboxitemsAvgAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
  }

  export type Player_storeinboxitemsSumAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
  }

  export type Player_storeinboxitemsMinAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
    attributes?: true
  }

  export type Player_storeinboxitemsMaxAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
    attributes?: true
  }

  export type Player_storeinboxitemsCountAggregateInputType = {
    player_id?: true
    sid?: true
    pid?: true
    itemtype?: true
    count?: true
    attributes?: true
    json_data?: true
    _all?: true
  }

  export type Player_storeinboxitemsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which player_storeinboxitems to aggregate.
     */
    where?: player_storeinboxitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_storeinboxitems to fetch.
     */
    orderBy?: Enumerable<player_storeinboxitemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: player_storeinboxitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_storeinboxitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_storeinboxitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned player_storeinboxitems
    **/
    _count?: true | Player_storeinboxitemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Player_storeinboxitemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Player_storeinboxitemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Player_storeinboxitemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Player_storeinboxitemsMaxAggregateInputType
  }

  export type GetPlayer_storeinboxitemsAggregateType<T extends Player_storeinboxitemsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer_storeinboxitems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer_storeinboxitems[P]>
      : GetScalarType<T[P], AggregatePlayer_storeinboxitems[P]>
  }




  export type Player_storeinboxitemsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: player_storeinboxitemsWhereInput
    orderBy?: Enumerable<player_storeinboxitemsOrderByWithAggregationInput>
    by: Player_storeinboxitemsScalarFieldEnum[]
    having?: player_storeinboxitemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Player_storeinboxitemsCountAggregateInputType | true
    _avg?: Player_storeinboxitemsAvgAggregateInputType
    _sum?: Player_storeinboxitemsSumAggregateInputType
    _min?: Player_storeinboxitemsMinAggregateInputType
    _max?: Player_storeinboxitemsMaxAggregateInputType
  }


  export type Player_storeinboxitemsGroupByOutputType = {
    player_id: number
    sid: number
    pid: number
    itemtype: number
    count: number
    attributes: Buffer
    json_data: JsonValue | null
    _count: Player_storeinboxitemsCountAggregateOutputType | null
    _avg: Player_storeinboxitemsAvgAggregateOutputType | null
    _sum: Player_storeinboxitemsSumAggregateOutputType | null
    _min: Player_storeinboxitemsMinAggregateOutputType | null
    _max: Player_storeinboxitemsMaxAggregateOutputType | null
  }

  type GetPlayer_storeinboxitemsGroupByPayload<T extends Player_storeinboxitemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Player_storeinboxitemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Player_storeinboxitemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Player_storeinboxitemsGroupByOutputType[P]>
            : GetScalarType<T[P], Player_storeinboxitemsGroupByOutputType[P]>
        }
      >
    >


  export type player_storeinboxitemsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    player_id?: boolean
    sid?: boolean
    pid?: boolean
    itemtype?: boolean
    count?: boolean
    attributes?: boolean
    json_data?: boolean
    players?: boolean | PlayerArgs<ExtArgs>
  }, ExtArgs["result"]["player_storeinboxitems"]>

  export type player_storeinboxitemsSelectScalar = {
    player_id?: boolean
    sid?: boolean
    pid?: boolean
    itemtype?: boolean
    count?: boolean
    attributes?: boolean
    json_data?: boolean
  }

  export type player_storeinboxitemsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    players?: boolean | PlayerArgs<ExtArgs>
  }


  type player_storeinboxitemsGetPayload<S extends boolean | null | undefined | player_storeinboxitemsArgs> = $Types.GetResult<player_storeinboxitemsPayload, S>

  type player_storeinboxitemsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<player_storeinboxitemsFindManyArgs, 'select' | 'include'> & {
      select?: Player_storeinboxitemsCountAggregateInputType | true
    }

  export interface player_storeinboxitemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['player_storeinboxitems'], meta: { name: 'player_storeinboxitems' } }
    /**
     * Find zero or one Player_storeinboxitems that matches the filter.
     * @param {player_storeinboxitemsFindUniqueArgs} args - Arguments to find a Player_storeinboxitems
     * @example
     * // Get one Player_storeinboxitems
     * const player_storeinboxitems = await prisma.player_storeinboxitems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends player_storeinboxitemsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, player_storeinboxitemsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'player_storeinboxitems'> extends True ? Prisma__player_storeinboxitemsClient<$Types.GetResult<player_storeinboxitemsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__player_storeinboxitemsClient<$Types.GetResult<player_storeinboxitemsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Player_storeinboxitems that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {player_storeinboxitemsFindUniqueOrThrowArgs} args - Arguments to find a Player_storeinboxitems
     * @example
     * // Get one Player_storeinboxitems
     * const player_storeinboxitems = await prisma.player_storeinboxitems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends player_storeinboxitemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, player_storeinboxitemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__player_storeinboxitemsClient<$Types.GetResult<player_storeinboxitemsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Player_storeinboxitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_storeinboxitemsFindFirstArgs} args - Arguments to find a Player_storeinboxitems
     * @example
     * // Get one Player_storeinboxitems
     * const player_storeinboxitems = await prisma.player_storeinboxitems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends player_storeinboxitemsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, player_storeinboxitemsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'player_storeinboxitems'> extends True ? Prisma__player_storeinboxitemsClient<$Types.GetResult<player_storeinboxitemsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__player_storeinboxitemsClient<$Types.GetResult<player_storeinboxitemsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Player_storeinboxitems that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_storeinboxitemsFindFirstOrThrowArgs} args - Arguments to find a Player_storeinboxitems
     * @example
     * // Get one Player_storeinboxitems
     * const player_storeinboxitems = await prisma.player_storeinboxitems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends player_storeinboxitemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, player_storeinboxitemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__player_storeinboxitemsClient<$Types.GetResult<player_storeinboxitemsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Player_storeinboxitems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_storeinboxitemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Player_storeinboxitems
     * const player_storeinboxitems = await prisma.player_storeinboxitems.findMany()
     * 
     * // Get first 10 Player_storeinboxitems
     * const player_storeinboxitems = await prisma.player_storeinboxitems.findMany({ take: 10 })
     * 
     * // Only select the `player_id`
     * const player_storeinboxitemsWithPlayer_idOnly = await prisma.player_storeinboxitems.findMany({ select: { player_id: true } })
     * 
    **/
    findMany<T extends player_storeinboxitemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_storeinboxitemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<player_storeinboxitemsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Player_storeinboxitems.
     * @param {player_storeinboxitemsCreateArgs} args - Arguments to create a Player_storeinboxitems.
     * @example
     * // Create one Player_storeinboxitems
     * const Player_storeinboxitems = await prisma.player_storeinboxitems.create({
     *   data: {
     *     // ... data to create a Player_storeinboxitems
     *   }
     * })
     * 
    **/
    create<T extends player_storeinboxitemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, player_storeinboxitemsCreateArgs<ExtArgs>>
    ): Prisma__player_storeinboxitemsClient<$Types.GetResult<player_storeinboxitemsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Player_storeinboxitems.
     *     @param {player_storeinboxitemsCreateManyArgs} args - Arguments to create many Player_storeinboxitems.
     *     @example
     *     // Create many Player_storeinboxitems
     *     const player_storeinboxitems = await prisma.player_storeinboxitems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends player_storeinboxitemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_storeinboxitemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Player_storeinboxitems.
     * @param {player_storeinboxitemsDeleteArgs} args - Arguments to delete one Player_storeinboxitems.
     * @example
     * // Delete one Player_storeinboxitems
     * const Player_storeinboxitems = await prisma.player_storeinboxitems.delete({
     *   where: {
     *     // ... filter to delete one Player_storeinboxitems
     *   }
     * })
     * 
    **/
    delete<T extends player_storeinboxitemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, player_storeinboxitemsDeleteArgs<ExtArgs>>
    ): Prisma__player_storeinboxitemsClient<$Types.GetResult<player_storeinboxitemsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Player_storeinboxitems.
     * @param {player_storeinboxitemsUpdateArgs} args - Arguments to update one Player_storeinboxitems.
     * @example
     * // Update one Player_storeinboxitems
     * const player_storeinboxitems = await prisma.player_storeinboxitems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends player_storeinboxitemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, player_storeinboxitemsUpdateArgs<ExtArgs>>
    ): Prisma__player_storeinboxitemsClient<$Types.GetResult<player_storeinboxitemsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Player_storeinboxitems.
     * @param {player_storeinboxitemsDeleteManyArgs} args - Arguments to filter Player_storeinboxitems to delete.
     * @example
     * // Delete a few Player_storeinboxitems
     * const { count } = await prisma.player_storeinboxitems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends player_storeinboxitemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, player_storeinboxitemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Player_storeinboxitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_storeinboxitemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Player_storeinboxitems
     * const player_storeinboxitems = await prisma.player_storeinboxitems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends player_storeinboxitemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, player_storeinboxitemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Player_storeinboxitems.
     * @param {player_storeinboxitemsUpsertArgs} args - Arguments to update or create a Player_storeinboxitems.
     * @example
     * // Update or create a Player_storeinboxitems
     * const player_storeinboxitems = await prisma.player_storeinboxitems.upsert({
     *   create: {
     *     // ... data to create a Player_storeinboxitems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player_storeinboxitems we want to update
     *   }
     * })
    **/
    upsert<T extends player_storeinboxitemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, player_storeinboxitemsUpsertArgs<ExtArgs>>
    ): Prisma__player_storeinboxitemsClient<$Types.GetResult<player_storeinboxitemsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Player_storeinboxitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {player_storeinboxitemsCountArgs} args - Arguments to filter Player_storeinboxitems to count.
     * @example
     * // Count the number of Player_storeinboxitems
     * const count = await prisma.player_storeinboxitems.count({
     *   where: {
     *     // ... the filter for the Player_storeinboxitems we want to count
     *   }
     * })
    **/
    count<T extends player_storeinboxitemsCountArgs>(
      args?: Subset<T, player_storeinboxitemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Player_storeinboxitemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player_storeinboxitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Player_storeinboxitemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Player_storeinboxitemsAggregateArgs>(args: Subset<T, Player_storeinboxitemsAggregateArgs>): Prisma.PrismaPromise<GetPlayer_storeinboxitemsAggregateType<T>>

    /**
     * Group by Player_storeinboxitems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Player_storeinboxitemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Player_storeinboxitemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Player_storeinboxitemsGroupByArgs['orderBy'] }
        : { orderBy?: Player_storeinboxitemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Player_storeinboxitemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayer_storeinboxitemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for player_storeinboxitems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__player_storeinboxitemsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    players<T extends PlayerArgs<ExtArgs> = {}>(args?: Subset<T, PlayerArgs<ExtArgs>>): Prisma__PlayerClient<$Types.GetResult<PlayerPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * player_storeinboxitems base type for findUnique actions
   */
  export type player_storeinboxitemsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storeinboxitems
     */
    select?: player_storeinboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storeinboxitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_storeinboxitems to fetch.
     */
    where: player_storeinboxitemsWhereUniqueInput
  }

  /**
   * player_storeinboxitems findUnique
   */
  export interface player_storeinboxitemsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends player_storeinboxitemsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * player_storeinboxitems findUniqueOrThrow
   */
  export type player_storeinboxitemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storeinboxitems
     */
    select?: player_storeinboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storeinboxitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_storeinboxitems to fetch.
     */
    where: player_storeinboxitemsWhereUniqueInput
  }


  /**
   * player_storeinboxitems base type for findFirst actions
   */
  export type player_storeinboxitemsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storeinboxitems
     */
    select?: player_storeinboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storeinboxitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_storeinboxitems to fetch.
     */
    where?: player_storeinboxitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_storeinboxitems to fetch.
     */
    orderBy?: Enumerable<player_storeinboxitemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for player_storeinboxitems.
     */
    cursor?: player_storeinboxitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_storeinboxitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_storeinboxitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of player_storeinboxitems.
     */
    distinct?: Enumerable<Player_storeinboxitemsScalarFieldEnum>
  }

  /**
   * player_storeinboxitems findFirst
   */
  export interface player_storeinboxitemsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends player_storeinboxitemsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * player_storeinboxitems findFirstOrThrow
   */
  export type player_storeinboxitemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storeinboxitems
     */
    select?: player_storeinboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storeinboxitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_storeinboxitems to fetch.
     */
    where?: player_storeinboxitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_storeinboxitems to fetch.
     */
    orderBy?: Enumerable<player_storeinboxitemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for player_storeinboxitems.
     */
    cursor?: player_storeinboxitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_storeinboxitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_storeinboxitems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of player_storeinboxitems.
     */
    distinct?: Enumerable<Player_storeinboxitemsScalarFieldEnum>
  }


  /**
   * player_storeinboxitems findMany
   */
  export type player_storeinboxitemsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storeinboxitems
     */
    select?: player_storeinboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storeinboxitemsInclude<ExtArgs> | null
    /**
     * Filter, which player_storeinboxitems to fetch.
     */
    where?: player_storeinboxitemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of player_storeinboxitems to fetch.
     */
    orderBy?: Enumerable<player_storeinboxitemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing player_storeinboxitems.
     */
    cursor?: player_storeinboxitemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` player_storeinboxitems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` player_storeinboxitems.
     */
    skip?: number
    distinct?: Enumerable<Player_storeinboxitemsScalarFieldEnum>
  }


  /**
   * player_storeinboxitems create
   */
  export type player_storeinboxitemsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storeinboxitems
     */
    select?: player_storeinboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storeinboxitemsInclude<ExtArgs> | null
    /**
     * The data needed to create a player_storeinboxitems.
     */
    data: XOR<player_storeinboxitemsCreateInput, player_storeinboxitemsUncheckedCreateInput>
  }


  /**
   * player_storeinboxitems createMany
   */
  export type player_storeinboxitemsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many player_storeinboxitems.
     */
    data: Enumerable<player_storeinboxitemsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * player_storeinboxitems update
   */
  export type player_storeinboxitemsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storeinboxitems
     */
    select?: player_storeinboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storeinboxitemsInclude<ExtArgs> | null
    /**
     * The data needed to update a player_storeinboxitems.
     */
    data: XOR<player_storeinboxitemsUpdateInput, player_storeinboxitemsUncheckedUpdateInput>
    /**
     * Choose, which player_storeinboxitems to update.
     */
    where: player_storeinboxitemsWhereUniqueInput
  }


  /**
   * player_storeinboxitems updateMany
   */
  export type player_storeinboxitemsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update player_storeinboxitems.
     */
    data: XOR<player_storeinboxitemsUpdateManyMutationInput, player_storeinboxitemsUncheckedUpdateManyInput>
    /**
     * Filter which player_storeinboxitems to update
     */
    where?: player_storeinboxitemsWhereInput
  }


  /**
   * player_storeinboxitems upsert
   */
  export type player_storeinboxitemsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storeinboxitems
     */
    select?: player_storeinboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storeinboxitemsInclude<ExtArgs> | null
    /**
     * The filter to search for the player_storeinboxitems to update in case it exists.
     */
    where: player_storeinboxitemsWhereUniqueInput
    /**
     * In case the player_storeinboxitems found by the `where` argument doesn't exist, create a new player_storeinboxitems with this data.
     */
    create: XOR<player_storeinboxitemsCreateInput, player_storeinboxitemsUncheckedCreateInput>
    /**
     * In case the player_storeinboxitems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<player_storeinboxitemsUpdateInput, player_storeinboxitemsUncheckedUpdateInput>
  }


  /**
   * player_storeinboxitems delete
   */
  export type player_storeinboxitemsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storeinboxitems
     */
    select?: player_storeinboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storeinboxitemsInclude<ExtArgs> | null
    /**
     * Filter which player_storeinboxitems to delete.
     */
    where: player_storeinboxitemsWhereUniqueInput
  }


  /**
   * player_storeinboxitems deleteMany
   */
  export type player_storeinboxitemsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which player_storeinboxitems to delete
     */
    where?: player_storeinboxitemsWhereInput
  }


  /**
   * player_storeinboxitems without action
   */
  export type player_storeinboxitemsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the player_storeinboxitems
     */
    select?: player_storeinboxitemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: player_storeinboxitemsInclude<ExtArgs> | null
  }



  /**
   * Model players_online
   */


  export type AggregatePlayers_online = {
    _count: Players_onlineCountAggregateOutputType | null
    _avg: Players_onlineAvgAggregateOutputType | null
    _sum: Players_onlineSumAggregateOutputType | null
    _min: Players_onlineMinAggregateOutputType | null
    _max: Players_onlineMaxAggregateOutputType | null
  }

  export type Players_onlineAvgAggregateOutputType = {
    player_id: number | null
  }

  export type Players_onlineSumAggregateOutputType = {
    player_id: number | null
  }

  export type Players_onlineMinAggregateOutputType = {
    player_id: number | null
  }

  export type Players_onlineMaxAggregateOutputType = {
    player_id: number | null
  }

  export type Players_onlineCountAggregateOutputType = {
    player_id: number
    _all: number
  }


  export type Players_onlineAvgAggregateInputType = {
    player_id?: true
  }

  export type Players_onlineSumAggregateInputType = {
    player_id?: true
  }

  export type Players_onlineMinAggregateInputType = {
    player_id?: true
  }

  export type Players_onlineMaxAggregateInputType = {
    player_id?: true
  }

  export type Players_onlineCountAggregateInputType = {
    player_id?: true
    _all?: true
  }

  export type Players_onlineAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which players_online to aggregate.
     */
    where?: players_onlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of players_onlines to fetch.
     */
    orderBy?: Enumerable<players_onlineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: players_onlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` players_onlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` players_onlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned players_onlines
    **/
    _count?: true | Players_onlineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Players_onlineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Players_onlineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Players_onlineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Players_onlineMaxAggregateInputType
  }

  export type GetPlayers_onlineAggregateType<T extends Players_onlineAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayers_online]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayers_online[P]>
      : GetScalarType<T[P], AggregatePlayers_online[P]>
  }




  export type Players_onlineGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: players_onlineWhereInput
    orderBy?: Enumerable<players_onlineOrderByWithAggregationInput>
    by: Players_onlineScalarFieldEnum[]
    having?: players_onlineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Players_onlineCountAggregateInputType | true
    _avg?: Players_onlineAvgAggregateInputType
    _sum?: Players_onlineSumAggregateInputType
    _min?: Players_onlineMinAggregateInputType
    _max?: Players_onlineMaxAggregateInputType
  }


  export type Players_onlineGroupByOutputType = {
    player_id: number
    _count: Players_onlineCountAggregateOutputType | null
    _avg: Players_onlineAvgAggregateOutputType | null
    _sum: Players_onlineSumAggregateOutputType | null
    _min: Players_onlineMinAggregateOutputType | null
    _max: Players_onlineMaxAggregateOutputType | null
  }

  type GetPlayers_onlineGroupByPayload<T extends Players_onlineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Players_onlineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Players_onlineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Players_onlineGroupByOutputType[P]>
            : GetScalarType<T[P], Players_onlineGroupByOutputType[P]>
        }
      >
    >


  export type players_onlineSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    player_id?: boolean
  }, ExtArgs["result"]["players_online"]>

  export type players_onlineSelectScalar = {
    player_id?: boolean
  }


  type players_onlineGetPayload<S extends boolean | null | undefined | players_onlineArgs> = $Types.GetResult<players_onlinePayload, S>

  type players_onlineCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<players_onlineFindManyArgs, 'select' | 'include'> & {
      select?: Players_onlineCountAggregateInputType | true
    }

  export interface players_onlineDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['players_online'], meta: { name: 'players_online' } }
    /**
     * Find zero or one Players_online that matches the filter.
     * @param {players_onlineFindUniqueArgs} args - Arguments to find a Players_online
     * @example
     * // Get one Players_online
     * const players_online = await prisma.players_online.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends players_onlineFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, players_onlineFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'players_online'> extends True ? Prisma__players_onlineClient<$Types.GetResult<players_onlinePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__players_onlineClient<$Types.GetResult<players_onlinePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Players_online that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {players_onlineFindUniqueOrThrowArgs} args - Arguments to find a Players_online
     * @example
     * // Get one Players_online
     * const players_online = await prisma.players_online.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends players_onlineFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, players_onlineFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__players_onlineClient<$Types.GetResult<players_onlinePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Players_online that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {players_onlineFindFirstArgs} args - Arguments to find a Players_online
     * @example
     * // Get one Players_online
     * const players_online = await prisma.players_online.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends players_onlineFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, players_onlineFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'players_online'> extends True ? Prisma__players_onlineClient<$Types.GetResult<players_onlinePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__players_onlineClient<$Types.GetResult<players_onlinePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Players_online that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {players_onlineFindFirstOrThrowArgs} args - Arguments to find a Players_online
     * @example
     * // Get one Players_online
     * const players_online = await prisma.players_online.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends players_onlineFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, players_onlineFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__players_onlineClient<$Types.GetResult<players_onlinePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Players_onlines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {players_onlineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players_onlines
     * const players_onlines = await prisma.players_online.findMany()
     * 
     * // Get first 10 Players_onlines
     * const players_onlines = await prisma.players_online.findMany({ take: 10 })
     * 
     * // Only select the `player_id`
     * const players_onlineWithPlayer_idOnly = await prisma.players_online.findMany({ select: { player_id: true } })
     * 
    **/
    findMany<T extends players_onlineFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, players_onlineFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<players_onlinePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Players_online.
     * @param {players_onlineCreateArgs} args - Arguments to create a Players_online.
     * @example
     * // Create one Players_online
     * const Players_online = await prisma.players_online.create({
     *   data: {
     *     // ... data to create a Players_online
     *   }
     * })
     * 
    **/
    create<T extends players_onlineCreateArgs<ExtArgs>>(
      args: SelectSubset<T, players_onlineCreateArgs<ExtArgs>>
    ): Prisma__players_onlineClient<$Types.GetResult<players_onlinePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Players_onlines.
     *     @param {players_onlineCreateManyArgs} args - Arguments to create many Players_onlines.
     *     @example
     *     // Create many Players_onlines
     *     const players_online = await prisma.players_online.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends players_onlineCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, players_onlineCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Players_online.
     * @param {players_onlineDeleteArgs} args - Arguments to delete one Players_online.
     * @example
     * // Delete one Players_online
     * const Players_online = await prisma.players_online.delete({
     *   where: {
     *     // ... filter to delete one Players_online
     *   }
     * })
     * 
    **/
    delete<T extends players_onlineDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, players_onlineDeleteArgs<ExtArgs>>
    ): Prisma__players_onlineClient<$Types.GetResult<players_onlinePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Players_online.
     * @param {players_onlineUpdateArgs} args - Arguments to update one Players_online.
     * @example
     * // Update one Players_online
     * const players_online = await prisma.players_online.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends players_onlineUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, players_onlineUpdateArgs<ExtArgs>>
    ): Prisma__players_onlineClient<$Types.GetResult<players_onlinePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Players_onlines.
     * @param {players_onlineDeleteManyArgs} args - Arguments to filter Players_onlines to delete.
     * @example
     * // Delete a few Players_onlines
     * const { count } = await prisma.players_online.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends players_onlineDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, players_onlineDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players_onlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {players_onlineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players_onlines
     * const players_online = await prisma.players_online.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends players_onlineUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, players_onlineUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Players_online.
     * @param {players_onlineUpsertArgs} args - Arguments to update or create a Players_online.
     * @example
     * // Update or create a Players_online
     * const players_online = await prisma.players_online.upsert({
     *   create: {
     *     // ... data to create a Players_online
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Players_online we want to update
     *   }
     * })
    **/
    upsert<T extends players_onlineUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, players_onlineUpsertArgs<ExtArgs>>
    ): Prisma__players_onlineClient<$Types.GetResult<players_onlinePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Players_onlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {players_onlineCountArgs} args - Arguments to filter Players_onlines to count.
     * @example
     * // Count the number of Players_onlines
     * const count = await prisma.players_online.count({
     *   where: {
     *     // ... the filter for the Players_onlines we want to count
     *   }
     * })
    **/
    count<T extends players_onlineCountArgs>(
      args?: Subset<T, players_onlineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Players_onlineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Players_online.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Players_onlineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Players_onlineAggregateArgs>(args: Subset<T, Players_onlineAggregateArgs>): Prisma.PrismaPromise<GetPlayers_onlineAggregateType<T>>

    /**
     * Group by Players_online.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Players_onlineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Players_onlineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Players_onlineGroupByArgs['orderBy'] }
        : { orderBy?: Players_onlineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Players_onlineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayers_onlineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for players_online.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__players_onlineClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * players_online base type for findUnique actions
   */
  export type players_onlineFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the players_online
     */
    select?: players_onlineSelect<ExtArgs> | null
    /**
     * Filter, which players_online to fetch.
     */
    where: players_onlineWhereUniqueInput
  }

  /**
   * players_online findUnique
   */
  export interface players_onlineFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends players_onlineFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * players_online findUniqueOrThrow
   */
  export type players_onlineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the players_online
     */
    select?: players_onlineSelect<ExtArgs> | null
    /**
     * Filter, which players_online to fetch.
     */
    where: players_onlineWhereUniqueInput
  }


  /**
   * players_online base type for findFirst actions
   */
  export type players_onlineFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the players_online
     */
    select?: players_onlineSelect<ExtArgs> | null
    /**
     * Filter, which players_online to fetch.
     */
    where?: players_onlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of players_onlines to fetch.
     */
    orderBy?: Enumerable<players_onlineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for players_onlines.
     */
    cursor?: players_onlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` players_onlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` players_onlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of players_onlines.
     */
    distinct?: Enumerable<Players_onlineScalarFieldEnum>
  }

  /**
   * players_online findFirst
   */
  export interface players_onlineFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends players_onlineFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * players_online findFirstOrThrow
   */
  export type players_onlineFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the players_online
     */
    select?: players_onlineSelect<ExtArgs> | null
    /**
     * Filter, which players_online to fetch.
     */
    where?: players_onlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of players_onlines to fetch.
     */
    orderBy?: Enumerable<players_onlineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for players_onlines.
     */
    cursor?: players_onlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` players_onlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` players_onlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of players_onlines.
     */
    distinct?: Enumerable<Players_onlineScalarFieldEnum>
  }


  /**
   * players_online findMany
   */
  export type players_onlineFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the players_online
     */
    select?: players_onlineSelect<ExtArgs> | null
    /**
     * Filter, which players_onlines to fetch.
     */
    where?: players_onlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of players_onlines to fetch.
     */
    orderBy?: Enumerable<players_onlineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing players_onlines.
     */
    cursor?: players_onlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` players_onlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` players_onlines.
     */
    skip?: number
    distinct?: Enumerable<Players_onlineScalarFieldEnum>
  }


  /**
   * players_online create
   */
  export type players_onlineCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the players_online
     */
    select?: players_onlineSelect<ExtArgs> | null
    /**
     * The data needed to create a players_online.
     */
    data: XOR<players_onlineCreateInput, players_onlineUncheckedCreateInput>
  }


  /**
   * players_online createMany
   */
  export type players_onlineCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many players_onlines.
     */
    data: Enumerable<players_onlineCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * players_online update
   */
  export type players_onlineUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the players_online
     */
    select?: players_onlineSelect<ExtArgs> | null
    /**
     * The data needed to update a players_online.
     */
    data: XOR<players_onlineUpdateInput, players_onlineUncheckedUpdateInput>
    /**
     * Choose, which players_online to update.
     */
    where: players_onlineWhereUniqueInput
  }


  /**
   * players_online updateMany
   */
  export type players_onlineUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update players_onlines.
     */
    data: XOR<players_onlineUpdateManyMutationInput, players_onlineUncheckedUpdateManyInput>
    /**
     * Filter which players_onlines to update
     */
    where?: players_onlineWhereInput
  }


  /**
   * players_online upsert
   */
  export type players_onlineUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the players_online
     */
    select?: players_onlineSelect<ExtArgs> | null
    /**
     * The filter to search for the players_online to update in case it exists.
     */
    where: players_onlineWhereUniqueInput
    /**
     * In case the players_online found by the `where` argument doesn't exist, create a new players_online with this data.
     */
    create: XOR<players_onlineCreateInput, players_onlineUncheckedCreateInput>
    /**
     * In case the players_online was found with the provided `where` argument, update it with this data.
     */
    update: XOR<players_onlineUpdateInput, players_onlineUncheckedUpdateInput>
  }


  /**
   * players_online delete
   */
  export type players_onlineDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the players_online
     */
    select?: players_onlineSelect<ExtArgs> | null
    /**
     * Filter which players_online to delete.
     */
    where: players_onlineWhereUniqueInput
  }


  /**
   * players_online deleteMany
   */
  export type players_onlineDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which players_onlines to delete
     */
    where?: players_onlineWhereInput
  }


  /**
   * players_online without action
   */
  export type players_onlineArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the players_online
     */
    select?: players_onlineSelect<ExtArgs> | null
  }



  /**
   * Model server_config
   */


  export type AggregateServer_config = {
    _count: Server_configCountAggregateOutputType | null
    _min: Server_configMinAggregateOutputType | null
    _max: Server_configMaxAggregateOutputType | null
  }

  export type Server_configMinAggregateOutputType = {
    config: string | null
    value: string | null
  }

  export type Server_configMaxAggregateOutputType = {
    config: string | null
    value: string | null
  }

  export type Server_configCountAggregateOutputType = {
    config: number
    value: number
    _all: number
  }


  export type Server_configMinAggregateInputType = {
    config?: true
    value?: true
  }

  export type Server_configMaxAggregateInputType = {
    config?: true
    value?: true
  }

  export type Server_configCountAggregateInputType = {
    config?: true
    value?: true
    _all?: true
  }

  export type Server_configAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which server_config to aggregate.
     */
    where?: server_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_configs to fetch.
     */
    orderBy?: Enumerable<server_configOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: server_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned server_configs
    **/
    _count?: true | Server_configCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Server_configMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Server_configMaxAggregateInputType
  }

  export type GetServer_configAggregateType<T extends Server_configAggregateArgs> = {
        [P in keyof T & keyof AggregateServer_config]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServer_config[P]>
      : GetScalarType<T[P], AggregateServer_config[P]>
  }




  export type Server_configGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: server_configWhereInput
    orderBy?: Enumerable<server_configOrderByWithAggregationInput>
    by: Server_configScalarFieldEnum[]
    having?: server_configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Server_configCountAggregateInputType | true
    _min?: Server_configMinAggregateInputType
    _max?: Server_configMaxAggregateInputType
  }


  export type Server_configGroupByOutputType = {
    config: string
    value: string
    _count: Server_configCountAggregateOutputType | null
    _min: Server_configMinAggregateOutputType | null
    _max: Server_configMaxAggregateOutputType | null
  }

  type GetServer_configGroupByPayload<T extends Server_configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Server_configGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Server_configGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Server_configGroupByOutputType[P]>
            : GetScalarType<T[P], Server_configGroupByOutputType[P]>
        }
      >
    >


  export type server_configSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    config?: boolean
    value?: boolean
  }, ExtArgs["result"]["server_config"]>

  export type server_configSelectScalar = {
    config?: boolean
    value?: boolean
  }


  type server_configGetPayload<S extends boolean | null | undefined | server_configArgs> = $Types.GetResult<server_configPayload, S>

  type server_configCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<server_configFindManyArgs, 'select' | 'include'> & {
      select?: Server_configCountAggregateInputType | true
    }

  export interface server_configDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['server_config'], meta: { name: 'server_config' } }
    /**
     * Find zero or one Server_config that matches the filter.
     * @param {server_configFindUniqueArgs} args - Arguments to find a Server_config
     * @example
     * // Get one Server_config
     * const server_config = await prisma.server_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends server_configFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, server_configFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'server_config'> extends True ? Prisma__server_configClient<$Types.GetResult<server_configPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__server_configClient<$Types.GetResult<server_configPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Server_config that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {server_configFindUniqueOrThrowArgs} args - Arguments to find a Server_config
     * @example
     * // Get one Server_config
     * const server_config = await prisma.server_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends server_configFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, server_configFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__server_configClient<$Types.GetResult<server_configPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Server_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_configFindFirstArgs} args - Arguments to find a Server_config
     * @example
     * // Get one Server_config
     * const server_config = await prisma.server_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends server_configFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, server_configFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'server_config'> extends True ? Prisma__server_configClient<$Types.GetResult<server_configPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__server_configClient<$Types.GetResult<server_configPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Server_config that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_configFindFirstOrThrowArgs} args - Arguments to find a Server_config
     * @example
     * // Get one Server_config
     * const server_config = await prisma.server_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends server_configFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, server_configFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__server_configClient<$Types.GetResult<server_configPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Server_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_configFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Server_configs
     * const server_configs = await prisma.server_config.findMany()
     * 
     * // Get first 10 Server_configs
     * const server_configs = await prisma.server_config.findMany({ take: 10 })
     * 
     * // Only select the `config`
     * const server_configWithConfigOnly = await prisma.server_config.findMany({ select: { config: true } })
     * 
    **/
    findMany<T extends server_configFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, server_configFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<server_configPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Server_config.
     * @param {server_configCreateArgs} args - Arguments to create a Server_config.
     * @example
     * // Create one Server_config
     * const Server_config = await prisma.server_config.create({
     *   data: {
     *     // ... data to create a Server_config
     *   }
     * })
     * 
    **/
    create<T extends server_configCreateArgs<ExtArgs>>(
      args: SelectSubset<T, server_configCreateArgs<ExtArgs>>
    ): Prisma__server_configClient<$Types.GetResult<server_configPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Server_configs.
     *     @param {server_configCreateManyArgs} args - Arguments to create many Server_configs.
     *     @example
     *     // Create many Server_configs
     *     const server_config = await prisma.server_config.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends server_configCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, server_configCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Server_config.
     * @param {server_configDeleteArgs} args - Arguments to delete one Server_config.
     * @example
     * // Delete one Server_config
     * const Server_config = await prisma.server_config.delete({
     *   where: {
     *     // ... filter to delete one Server_config
     *   }
     * })
     * 
    **/
    delete<T extends server_configDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, server_configDeleteArgs<ExtArgs>>
    ): Prisma__server_configClient<$Types.GetResult<server_configPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Server_config.
     * @param {server_configUpdateArgs} args - Arguments to update one Server_config.
     * @example
     * // Update one Server_config
     * const server_config = await prisma.server_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends server_configUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, server_configUpdateArgs<ExtArgs>>
    ): Prisma__server_configClient<$Types.GetResult<server_configPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Server_configs.
     * @param {server_configDeleteManyArgs} args - Arguments to filter Server_configs to delete.
     * @example
     * // Delete a few Server_configs
     * const { count } = await prisma.server_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends server_configDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, server_configDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Server_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Server_configs
     * const server_config = await prisma.server_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends server_configUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, server_configUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Server_config.
     * @param {server_configUpsertArgs} args - Arguments to update or create a Server_config.
     * @example
     * // Update or create a Server_config
     * const server_config = await prisma.server_config.upsert({
     *   create: {
     *     // ... data to create a Server_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Server_config we want to update
     *   }
     * })
    **/
    upsert<T extends server_configUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, server_configUpsertArgs<ExtArgs>>
    ): Prisma__server_configClient<$Types.GetResult<server_configPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Server_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {server_configCountArgs} args - Arguments to filter Server_configs to count.
     * @example
     * // Count the number of Server_configs
     * const count = await prisma.server_config.count({
     *   where: {
     *     // ... the filter for the Server_configs we want to count
     *   }
     * })
    **/
    count<T extends server_configCountArgs>(
      args?: Subset<T, server_configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Server_configCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Server_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Server_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Server_configAggregateArgs>(args: Subset<T, Server_configAggregateArgs>): Prisma.PrismaPromise<GetServer_configAggregateType<T>>

    /**
     * Group by Server_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Server_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Server_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Server_configGroupByArgs['orderBy'] }
        : { orderBy?: Server_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Server_configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServer_configGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for server_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__server_configClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * server_config base type for findUnique actions
   */
  export type server_configFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_config
     */
    select?: server_configSelect<ExtArgs> | null
    /**
     * Filter, which server_config to fetch.
     */
    where: server_configWhereUniqueInput
  }

  /**
   * server_config findUnique
   */
  export interface server_configFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends server_configFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * server_config findUniqueOrThrow
   */
  export type server_configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_config
     */
    select?: server_configSelect<ExtArgs> | null
    /**
     * Filter, which server_config to fetch.
     */
    where: server_configWhereUniqueInput
  }


  /**
   * server_config base type for findFirst actions
   */
  export type server_configFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_config
     */
    select?: server_configSelect<ExtArgs> | null
    /**
     * Filter, which server_config to fetch.
     */
    where?: server_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_configs to fetch.
     */
    orderBy?: Enumerable<server_configOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for server_configs.
     */
    cursor?: server_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of server_configs.
     */
    distinct?: Enumerable<Server_configScalarFieldEnum>
  }

  /**
   * server_config findFirst
   */
  export interface server_configFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends server_configFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * server_config findFirstOrThrow
   */
  export type server_configFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_config
     */
    select?: server_configSelect<ExtArgs> | null
    /**
     * Filter, which server_config to fetch.
     */
    where?: server_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_configs to fetch.
     */
    orderBy?: Enumerable<server_configOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for server_configs.
     */
    cursor?: server_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of server_configs.
     */
    distinct?: Enumerable<Server_configScalarFieldEnum>
  }


  /**
   * server_config findMany
   */
  export type server_configFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_config
     */
    select?: server_configSelect<ExtArgs> | null
    /**
     * Filter, which server_configs to fetch.
     */
    where?: server_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of server_configs to fetch.
     */
    orderBy?: Enumerable<server_configOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing server_configs.
     */
    cursor?: server_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` server_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` server_configs.
     */
    skip?: number
    distinct?: Enumerable<Server_configScalarFieldEnum>
  }


  /**
   * server_config create
   */
  export type server_configCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_config
     */
    select?: server_configSelect<ExtArgs> | null
    /**
     * The data needed to create a server_config.
     */
    data: XOR<server_configCreateInput, server_configUncheckedCreateInput>
  }


  /**
   * server_config createMany
   */
  export type server_configCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many server_configs.
     */
    data: Enumerable<server_configCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * server_config update
   */
  export type server_configUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_config
     */
    select?: server_configSelect<ExtArgs> | null
    /**
     * The data needed to update a server_config.
     */
    data: XOR<server_configUpdateInput, server_configUncheckedUpdateInput>
    /**
     * Choose, which server_config to update.
     */
    where: server_configWhereUniqueInput
  }


  /**
   * server_config updateMany
   */
  export type server_configUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update server_configs.
     */
    data: XOR<server_configUpdateManyMutationInput, server_configUncheckedUpdateManyInput>
    /**
     * Filter which server_configs to update
     */
    where?: server_configWhereInput
  }


  /**
   * server_config upsert
   */
  export type server_configUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_config
     */
    select?: server_configSelect<ExtArgs> | null
    /**
     * The filter to search for the server_config to update in case it exists.
     */
    where: server_configWhereUniqueInput
    /**
     * In case the server_config found by the `where` argument doesn't exist, create a new server_config with this data.
     */
    create: XOR<server_configCreateInput, server_configUncheckedCreateInput>
    /**
     * In case the server_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<server_configUpdateInput, server_configUncheckedUpdateInput>
  }


  /**
   * server_config delete
   */
  export type server_configDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_config
     */
    select?: server_configSelect<ExtArgs> | null
    /**
     * Filter which server_config to delete.
     */
    where: server_configWhereUniqueInput
  }


  /**
   * server_config deleteMany
   */
  export type server_configDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which server_configs to delete
     */
    where?: server_configWhereInput
  }


  /**
   * server_config without action
   */
  export type server_configArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the server_config
     */
    select?: server_configSelect<ExtArgs> | null
  }



  /**
   * Model shop_history
   */


  export type AggregateShop_history = {
    _count: Shop_historyCountAggregateOutputType | null
    _avg: Shop_historyAvgAggregateOutputType | null
    _sum: Shop_historySumAggregateOutputType | null
    _min: Shop_historyMinAggregateOutputType | null
    _max: Shop_historyMaxAggregateOutputType | null
  }

  export type Shop_historyAvgAggregateOutputType = {
    id: number | null
    account: number | null
    player: number | null
    cost: number | null
  }

  export type Shop_historySumAggregateOutputType = {
    id: number | null
    account: number | null
    player: number | null
    cost: number | null
  }

  export type Shop_historyMinAggregateOutputType = {
    id: number | null
    account: number | null
    player: number | null
    date: Date | null
    title: string | null
    cost: number | null
    details: string | null
  }

  export type Shop_historyMaxAggregateOutputType = {
    id: number | null
    account: number | null
    player: number | null
    date: Date | null
    title: string | null
    cost: number | null
    details: string | null
  }

  export type Shop_historyCountAggregateOutputType = {
    id: number
    account: number
    player: number
    date: number
    title: number
    cost: number
    details: number
    _all: number
  }


  export type Shop_historyAvgAggregateInputType = {
    id?: true
    account?: true
    player?: true
    cost?: true
  }

  export type Shop_historySumAggregateInputType = {
    id?: true
    account?: true
    player?: true
    cost?: true
  }

  export type Shop_historyMinAggregateInputType = {
    id?: true
    account?: true
    player?: true
    date?: true
    title?: true
    cost?: true
    details?: true
  }

  export type Shop_historyMaxAggregateInputType = {
    id?: true
    account?: true
    player?: true
    date?: true
    title?: true
    cost?: true
    details?: true
  }

  export type Shop_historyCountAggregateInputType = {
    id?: true
    account?: true
    player?: true
    date?: true
    title?: true
    cost?: true
    details?: true
    _all?: true
  }

  export type Shop_historyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which shop_history to aggregate.
     */
    where?: shop_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shop_histories to fetch.
     */
    orderBy?: Enumerable<shop_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shop_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shop_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shop_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shop_histories
    **/
    _count?: true | Shop_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Shop_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Shop_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Shop_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Shop_historyMaxAggregateInputType
  }

  export type GetShop_historyAggregateType<T extends Shop_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateShop_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShop_history[P]>
      : GetScalarType<T[P], AggregateShop_history[P]>
  }




  export type Shop_historyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: shop_historyWhereInput
    orderBy?: Enumerable<shop_historyOrderByWithAggregationInput>
    by: Shop_historyScalarFieldEnum[]
    having?: shop_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Shop_historyCountAggregateInputType | true
    _avg?: Shop_historyAvgAggregateInputType
    _sum?: Shop_historySumAggregateInputType
    _min?: Shop_historyMinAggregateInputType
    _max?: Shop_historyMaxAggregateInputType
  }


  export type Shop_historyGroupByOutputType = {
    id: number
    account: number
    player: number
    date: Date
    title: string
    cost: number
    details: string
    _count: Shop_historyCountAggregateOutputType | null
    _avg: Shop_historyAvgAggregateOutputType | null
    _sum: Shop_historySumAggregateOutputType | null
    _min: Shop_historyMinAggregateOutputType | null
    _max: Shop_historyMaxAggregateOutputType | null
  }

  type GetShop_historyGroupByPayload<T extends Shop_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Shop_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Shop_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Shop_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Shop_historyGroupByOutputType[P]>
        }
      >
    >


  export type shop_historySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account?: boolean
    player?: boolean
    date?: boolean
    title?: boolean
    cost?: boolean
    details?: boolean
  }, ExtArgs["result"]["shop_history"]>

  export type shop_historySelectScalar = {
    id?: boolean
    account?: boolean
    player?: boolean
    date?: boolean
    title?: boolean
    cost?: boolean
    details?: boolean
  }


  type shop_historyGetPayload<S extends boolean | null | undefined | shop_historyArgs> = $Types.GetResult<shop_historyPayload, S>

  type shop_historyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<shop_historyFindManyArgs, 'select' | 'include'> & {
      select?: Shop_historyCountAggregateInputType | true
    }

  export interface shop_historyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shop_history'], meta: { name: 'shop_history' } }
    /**
     * Find zero or one Shop_history that matches the filter.
     * @param {shop_historyFindUniqueArgs} args - Arguments to find a Shop_history
     * @example
     * // Get one Shop_history
     * const shop_history = await prisma.shop_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends shop_historyFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, shop_historyFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'shop_history'> extends True ? Prisma__shop_historyClient<$Types.GetResult<shop_historyPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__shop_historyClient<$Types.GetResult<shop_historyPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Shop_history that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {shop_historyFindUniqueOrThrowArgs} args - Arguments to find a Shop_history
     * @example
     * // Get one Shop_history
     * const shop_history = await prisma.shop_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends shop_historyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, shop_historyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__shop_historyClient<$Types.GetResult<shop_historyPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Shop_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shop_historyFindFirstArgs} args - Arguments to find a Shop_history
     * @example
     * // Get one Shop_history
     * const shop_history = await prisma.shop_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends shop_historyFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, shop_historyFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'shop_history'> extends True ? Prisma__shop_historyClient<$Types.GetResult<shop_historyPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__shop_historyClient<$Types.GetResult<shop_historyPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Shop_history that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shop_historyFindFirstOrThrowArgs} args - Arguments to find a Shop_history
     * @example
     * // Get one Shop_history
     * const shop_history = await prisma.shop_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends shop_historyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, shop_historyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__shop_historyClient<$Types.GetResult<shop_historyPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Shop_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shop_historyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shop_histories
     * const shop_histories = await prisma.shop_history.findMany()
     * 
     * // Get first 10 Shop_histories
     * const shop_histories = await prisma.shop_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shop_historyWithIdOnly = await prisma.shop_history.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends shop_historyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, shop_historyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<shop_historyPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Shop_history.
     * @param {shop_historyCreateArgs} args - Arguments to create a Shop_history.
     * @example
     * // Create one Shop_history
     * const Shop_history = await prisma.shop_history.create({
     *   data: {
     *     // ... data to create a Shop_history
     *   }
     * })
     * 
    **/
    create<T extends shop_historyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, shop_historyCreateArgs<ExtArgs>>
    ): Prisma__shop_historyClient<$Types.GetResult<shop_historyPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Shop_histories.
     *     @param {shop_historyCreateManyArgs} args - Arguments to create many Shop_histories.
     *     @example
     *     // Create many Shop_histories
     *     const shop_history = await prisma.shop_history.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends shop_historyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, shop_historyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shop_history.
     * @param {shop_historyDeleteArgs} args - Arguments to delete one Shop_history.
     * @example
     * // Delete one Shop_history
     * const Shop_history = await prisma.shop_history.delete({
     *   where: {
     *     // ... filter to delete one Shop_history
     *   }
     * })
     * 
    **/
    delete<T extends shop_historyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, shop_historyDeleteArgs<ExtArgs>>
    ): Prisma__shop_historyClient<$Types.GetResult<shop_historyPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Shop_history.
     * @param {shop_historyUpdateArgs} args - Arguments to update one Shop_history.
     * @example
     * // Update one Shop_history
     * const shop_history = await prisma.shop_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends shop_historyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, shop_historyUpdateArgs<ExtArgs>>
    ): Prisma__shop_historyClient<$Types.GetResult<shop_historyPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Shop_histories.
     * @param {shop_historyDeleteManyArgs} args - Arguments to filter Shop_histories to delete.
     * @example
     * // Delete a few Shop_histories
     * const { count } = await prisma.shop_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends shop_historyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, shop_historyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shop_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shop_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shop_histories
     * const shop_history = await prisma.shop_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends shop_historyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, shop_historyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shop_history.
     * @param {shop_historyUpsertArgs} args - Arguments to update or create a Shop_history.
     * @example
     * // Update or create a Shop_history
     * const shop_history = await prisma.shop_history.upsert({
     *   create: {
     *     // ... data to create a Shop_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shop_history we want to update
     *   }
     * })
    **/
    upsert<T extends shop_historyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, shop_historyUpsertArgs<ExtArgs>>
    ): Prisma__shop_historyClient<$Types.GetResult<shop_historyPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Shop_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shop_historyCountArgs} args - Arguments to filter Shop_histories to count.
     * @example
     * // Count the number of Shop_histories
     * const count = await prisma.shop_history.count({
     *   where: {
     *     // ... the filter for the Shop_histories we want to count
     *   }
     * })
    **/
    count<T extends shop_historyCountArgs>(
      args?: Subset<T, shop_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Shop_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shop_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shop_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Shop_historyAggregateArgs>(args: Subset<T, Shop_historyAggregateArgs>): Prisma.PrismaPromise<GetShop_historyAggregateType<T>>

    /**
     * Group by Shop_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shop_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Shop_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Shop_historyGroupByArgs['orderBy'] }
        : { orderBy?: Shop_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Shop_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShop_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for shop_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__shop_historyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * shop_history base type for findUnique actions
   */
  export type shop_historyFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shop_history
     */
    select?: shop_historySelect<ExtArgs> | null
    /**
     * Filter, which shop_history to fetch.
     */
    where: shop_historyWhereUniqueInput
  }

  /**
   * shop_history findUnique
   */
  export interface shop_historyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends shop_historyFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * shop_history findUniqueOrThrow
   */
  export type shop_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shop_history
     */
    select?: shop_historySelect<ExtArgs> | null
    /**
     * Filter, which shop_history to fetch.
     */
    where: shop_historyWhereUniqueInput
  }


  /**
   * shop_history base type for findFirst actions
   */
  export type shop_historyFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shop_history
     */
    select?: shop_historySelect<ExtArgs> | null
    /**
     * Filter, which shop_history to fetch.
     */
    where?: shop_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shop_histories to fetch.
     */
    orderBy?: Enumerable<shop_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shop_histories.
     */
    cursor?: shop_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shop_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shop_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shop_histories.
     */
    distinct?: Enumerable<Shop_historyScalarFieldEnum>
  }

  /**
   * shop_history findFirst
   */
  export interface shop_historyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends shop_historyFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * shop_history findFirstOrThrow
   */
  export type shop_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shop_history
     */
    select?: shop_historySelect<ExtArgs> | null
    /**
     * Filter, which shop_history to fetch.
     */
    where?: shop_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shop_histories to fetch.
     */
    orderBy?: Enumerable<shop_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shop_histories.
     */
    cursor?: shop_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shop_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shop_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shop_histories.
     */
    distinct?: Enumerable<Shop_historyScalarFieldEnum>
  }


  /**
   * shop_history findMany
   */
  export type shop_historyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shop_history
     */
    select?: shop_historySelect<ExtArgs> | null
    /**
     * Filter, which shop_histories to fetch.
     */
    where?: shop_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shop_histories to fetch.
     */
    orderBy?: Enumerable<shop_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shop_histories.
     */
    cursor?: shop_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shop_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shop_histories.
     */
    skip?: number
    distinct?: Enumerable<Shop_historyScalarFieldEnum>
  }


  /**
   * shop_history create
   */
  export type shop_historyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shop_history
     */
    select?: shop_historySelect<ExtArgs> | null
    /**
     * The data needed to create a shop_history.
     */
    data: XOR<shop_historyCreateInput, shop_historyUncheckedCreateInput>
  }


  /**
   * shop_history createMany
   */
  export type shop_historyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many shop_histories.
     */
    data: Enumerable<shop_historyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * shop_history update
   */
  export type shop_historyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shop_history
     */
    select?: shop_historySelect<ExtArgs> | null
    /**
     * The data needed to update a shop_history.
     */
    data: XOR<shop_historyUpdateInput, shop_historyUncheckedUpdateInput>
    /**
     * Choose, which shop_history to update.
     */
    where: shop_historyWhereUniqueInput
  }


  /**
   * shop_history updateMany
   */
  export type shop_historyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update shop_histories.
     */
    data: XOR<shop_historyUpdateManyMutationInput, shop_historyUncheckedUpdateManyInput>
    /**
     * Filter which shop_histories to update
     */
    where?: shop_historyWhereInput
  }


  /**
   * shop_history upsert
   */
  export type shop_historyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shop_history
     */
    select?: shop_historySelect<ExtArgs> | null
    /**
     * The filter to search for the shop_history to update in case it exists.
     */
    where: shop_historyWhereUniqueInput
    /**
     * In case the shop_history found by the `where` argument doesn't exist, create a new shop_history with this data.
     */
    create: XOR<shop_historyCreateInput, shop_historyUncheckedCreateInput>
    /**
     * In case the shop_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shop_historyUpdateInput, shop_historyUncheckedUpdateInput>
  }


  /**
   * shop_history delete
   */
  export type shop_historyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shop_history
     */
    select?: shop_historySelect<ExtArgs> | null
    /**
     * Filter which shop_history to delete.
     */
    where: shop_historyWhereUniqueInput
  }


  /**
   * shop_history deleteMany
   */
  export type shop_historyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which shop_histories to delete
     */
    where?: shop_historyWhereInput
  }


  /**
   * shop_history without action
   */
  export type shop_historyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shop_history
     */
    select?: shop_historySelect<ExtArgs> | null
  }



  /**
   * Model towns
   */


  export type AggregateTowns = {
    _count: TownsCountAggregateOutputType | null
    _avg: TownsAvgAggregateOutputType | null
    _sum: TownsSumAggregateOutputType | null
    _min: TownsMinAggregateOutputType | null
    _max: TownsMaxAggregateOutputType | null
  }

  export type TownsAvgAggregateOutputType = {
    id: number | null
    posx: number | null
    posy: number | null
    posz: number | null
  }

  export type TownsSumAggregateOutputType = {
    id: number | null
    posx: number | null
    posy: number | null
    posz: number | null
  }

  export type TownsMinAggregateOutputType = {
    id: number | null
    name: string | null
    posx: number | null
    posy: number | null
    posz: number | null
  }

  export type TownsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    posx: number | null
    posy: number | null
    posz: number | null
  }

  export type TownsCountAggregateOutputType = {
    id: number
    name: number
    posx: number
    posy: number
    posz: number
    _all: number
  }


  export type TownsAvgAggregateInputType = {
    id?: true
    posx?: true
    posy?: true
    posz?: true
  }

  export type TownsSumAggregateInputType = {
    id?: true
    posx?: true
    posy?: true
    posz?: true
  }

  export type TownsMinAggregateInputType = {
    id?: true
    name?: true
    posx?: true
    posy?: true
    posz?: true
  }

  export type TownsMaxAggregateInputType = {
    id?: true
    name?: true
    posx?: true
    posy?: true
    posz?: true
  }

  export type TownsCountAggregateInputType = {
    id?: true
    name?: true
    posx?: true
    posy?: true
    posz?: true
    _all?: true
  }

  export type TownsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which towns to aggregate.
     */
    where?: townsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of towns to fetch.
     */
    orderBy?: Enumerable<townsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: townsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` towns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` towns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned towns
    **/
    _count?: true | TownsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TownsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TownsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TownsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TownsMaxAggregateInputType
  }

  export type GetTownsAggregateType<T extends TownsAggregateArgs> = {
        [P in keyof T & keyof AggregateTowns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTowns[P]>
      : GetScalarType<T[P], AggregateTowns[P]>
  }




  export type TownsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: townsWhereInput
    orderBy?: Enumerable<townsOrderByWithAggregationInput>
    by: TownsScalarFieldEnum[]
    having?: townsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TownsCountAggregateInputType | true
    _avg?: TownsAvgAggregateInputType
    _sum?: TownsSumAggregateInputType
    _min?: TownsMinAggregateInputType
    _max?: TownsMaxAggregateInputType
  }


  export type TownsGroupByOutputType = {
    id: number
    name: string
    posx: number
    posy: number
    posz: number
    _count: TownsCountAggregateOutputType | null
    _avg: TownsAvgAggregateOutputType | null
    _sum: TownsSumAggregateOutputType | null
    _min: TownsMinAggregateOutputType | null
    _max: TownsMaxAggregateOutputType | null
  }

  type GetTownsGroupByPayload<T extends TownsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TownsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TownsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TownsGroupByOutputType[P]>
            : GetScalarType<T[P], TownsGroupByOutputType[P]>
        }
      >
    >


  export type townsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    posx?: boolean
    posy?: boolean
    posz?: boolean
  }, ExtArgs["result"]["towns"]>

  export type townsSelectScalar = {
    id?: boolean
    name?: boolean
    posx?: boolean
    posy?: boolean
    posz?: boolean
  }


  type townsGetPayload<S extends boolean | null | undefined | townsArgs> = $Types.GetResult<townsPayload, S>

  type townsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<townsFindManyArgs, 'select' | 'include'> & {
      select?: TownsCountAggregateInputType | true
    }

  export interface townsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['towns'], meta: { name: 'towns' } }
    /**
     * Find zero or one Towns that matches the filter.
     * @param {townsFindUniqueArgs} args - Arguments to find a Towns
     * @example
     * // Get one Towns
     * const towns = await prisma.towns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends townsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, townsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'towns'> extends True ? Prisma__townsClient<$Types.GetResult<townsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__townsClient<$Types.GetResult<townsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Towns that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {townsFindUniqueOrThrowArgs} args - Arguments to find a Towns
     * @example
     * // Get one Towns
     * const towns = await prisma.towns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends townsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, townsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__townsClient<$Types.GetResult<townsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Towns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {townsFindFirstArgs} args - Arguments to find a Towns
     * @example
     * // Get one Towns
     * const towns = await prisma.towns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends townsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, townsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'towns'> extends True ? Prisma__townsClient<$Types.GetResult<townsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__townsClient<$Types.GetResult<townsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Towns that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {townsFindFirstOrThrowArgs} args - Arguments to find a Towns
     * @example
     * // Get one Towns
     * const towns = await prisma.towns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends townsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, townsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__townsClient<$Types.GetResult<townsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Towns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {townsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Towns
     * const towns = await prisma.towns.findMany()
     * 
     * // Get first 10 Towns
     * const towns = await prisma.towns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const townsWithIdOnly = await prisma.towns.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends townsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, townsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<townsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Towns.
     * @param {townsCreateArgs} args - Arguments to create a Towns.
     * @example
     * // Create one Towns
     * const Towns = await prisma.towns.create({
     *   data: {
     *     // ... data to create a Towns
     *   }
     * })
     * 
    **/
    create<T extends townsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, townsCreateArgs<ExtArgs>>
    ): Prisma__townsClient<$Types.GetResult<townsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Towns.
     *     @param {townsCreateManyArgs} args - Arguments to create many Towns.
     *     @example
     *     // Create many Towns
     *     const towns = await prisma.towns.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends townsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, townsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Towns.
     * @param {townsDeleteArgs} args - Arguments to delete one Towns.
     * @example
     * // Delete one Towns
     * const Towns = await prisma.towns.delete({
     *   where: {
     *     // ... filter to delete one Towns
     *   }
     * })
     * 
    **/
    delete<T extends townsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, townsDeleteArgs<ExtArgs>>
    ): Prisma__townsClient<$Types.GetResult<townsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Towns.
     * @param {townsUpdateArgs} args - Arguments to update one Towns.
     * @example
     * // Update one Towns
     * const towns = await prisma.towns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends townsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, townsUpdateArgs<ExtArgs>>
    ): Prisma__townsClient<$Types.GetResult<townsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Towns.
     * @param {townsDeleteManyArgs} args - Arguments to filter Towns to delete.
     * @example
     * // Delete a few Towns
     * const { count } = await prisma.towns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends townsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, townsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Towns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {townsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Towns
     * const towns = await prisma.towns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends townsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, townsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Towns.
     * @param {townsUpsertArgs} args - Arguments to update or create a Towns.
     * @example
     * // Update or create a Towns
     * const towns = await prisma.towns.upsert({
     *   create: {
     *     // ... data to create a Towns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Towns we want to update
     *   }
     * })
    **/
    upsert<T extends townsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, townsUpsertArgs<ExtArgs>>
    ): Prisma__townsClient<$Types.GetResult<townsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Towns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {townsCountArgs} args - Arguments to filter Towns to count.
     * @example
     * // Count the number of Towns
     * const count = await prisma.towns.count({
     *   where: {
     *     // ... the filter for the Towns we want to count
     *   }
     * })
    **/
    count<T extends townsCountArgs>(
      args?: Subset<T, townsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TownsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Towns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TownsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TownsAggregateArgs>(args: Subset<T, TownsAggregateArgs>): Prisma.PrismaPromise<GetTownsAggregateType<T>>

    /**
     * Group by Towns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TownsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TownsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TownsGroupByArgs['orderBy'] }
        : { orderBy?: TownsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TownsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTownsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for towns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__townsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * towns base type for findUnique actions
   */
  export type townsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the towns
     */
    select?: townsSelect<ExtArgs> | null
    /**
     * Filter, which towns to fetch.
     */
    where: townsWhereUniqueInput
  }

  /**
   * towns findUnique
   */
  export interface townsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends townsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * towns findUniqueOrThrow
   */
  export type townsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the towns
     */
    select?: townsSelect<ExtArgs> | null
    /**
     * Filter, which towns to fetch.
     */
    where: townsWhereUniqueInput
  }


  /**
   * towns base type for findFirst actions
   */
  export type townsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the towns
     */
    select?: townsSelect<ExtArgs> | null
    /**
     * Filter, which towns to fetch.
     */
    where?: townsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of towns to fetch.
     */
    orderBy?: Enumerable<townsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for towns.
     */
    cursor?: townsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` towns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` towns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of towns.
     */
    distinct?: Enumerable<TownsScalarFieldEnum>
  }

  /**
   * towns findFirst
   */
  export interface townsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends townsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * towns findFirstOrThrow
   */
  export type townsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the towns
     */
    select?: townsSelect<ExtArgs> | null
    /**
     * Filter, which towns to fetch.
     */
    where?: townsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of towns to fetch.
     */
    orderBy?: Enumerable<townsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for towns.
     */
    cursor?: townsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` towns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` towns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of towns.
     */
    distinct?: Enumerable<TownsScalarFieldEnum>
  }


  /**
   * towns findMany
   */
  export type townsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the towns
     */
    select?: townsSelect<ExtArgs> | null
    /**
     * Filter, which towns to fetch.
     */
    where?: townsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of towns to fetch.
     */
    orderBy?: Enumerable<townsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing towns.
     */
    cursor?: townsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` towns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` towns.
     */
    skip?: number
    distinct?: Enumerable<TownsScalarFieldEnum>
  }


  /**
   * towns create
   */
  export type townsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the towns
     */
    select?: townsSelect<ExtArgs> | null
    /**
     * The data needed to create a towns.
     */
    data: XOR<townsCreateInput, townsUncheckedCreateInput>
  }


  /**
   * towns createMany
   */
  export type townsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many towns.
     */
    data: Enumerable<townsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * towns update
   */
  export type townsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the towns
     */
    select?: townsSelect<ExtArgs> | null
    /**
     * The data needed to update a towns.
     */
    data: XOR<townsUpdateInput, townsUncheckedUpdateInput>
    /**
     * Choose, which towns to update.
     */
    where: townsWhereUniqueInput
  }


  /**
   * towns updateMany
   */
  export type townsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update towns.
     */
    data: XOR<townsUpdateManyMutationInput, townsUncheckedUpdateManyInput>
    /**
     * Filter which towns to update
     */
    where?: townsWhereInput
  }


  /**
   * towns upsert
   */
  export type townsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the towns
     */
    select?: townsSelect<ExtArgs> | null
    /**
     * The filter to search for the towns to update in case it exists.
     */
    where: townsWhereUniqueInput
    /**
     * In case the towns found by the `where` argument doesn't exist, create a new towns with this data.
     */
    create: XOR<townsCreateInput, townsUncheckedCreateInput>
    /**
     * In case the towns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<townsUpdateInput, townsUncheckedUpdateInput>
  }


  /**
   * towns delete
   */
  export type townsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the towns
     */
    select?: townsSelect<ExtArgs> | null
    /**
     * Filter which towns to delete.
     */
    where: townsWhereUniqueInput
  }


  /**
   * towns deleteMany
   */
  export type townsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which towns to delete
     */
    where?: townsWhereInput
  }


  /**
   * towns without action
   */
  export type townsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the towns
     */
    select?: townsSelect<ExtArgs> | null
  }



  /**
   * Model znote
   */


  export type AggregateZnote = {
    _count: ZnoteCountAggregateOutputType | null
    _avg: ZnoteAvgAggregateOutputType | null
    _sum: ZnoteSumAggregateOutputType | null
    _min: ZnoteMinAggregateOutputType | null
    _max: ZnoteMaxAggregateOutputType | null
  }

  export type ZnoteAvgAggregateOutputType = {
    id: number | null
    installed: number | null
    cached: number | null
  }

  export type ZnoteSumAggregateOutputType = {
    id: number | null
    installed: number | null
    cached: number | null
  }

  export type ZnoteMinAggregateOutputType = {
    id: number | null
    version: string | null
    installed: number | null
    cached: number | null
  }

  export type ZnoteMaxAggregateOutputType = {
    id: number | null
    version: string | null
    installed: number | null
    cached: number | null
  }

  export type ZnoteCountAggregateOutputType = {
    id: number
    version: number
    installed: number
    cached: number
    _all: number
  }


  export type ZnoteAvgAggregateInputType = {
    id?: true
    installed?: true
    cached?: true
  }

  export type ZnoteSumAggregateInputType = {
    id?: true
    installed?: true
    cached?: true
  }

  export type ZnoteMinAggregateInputType = {
    id?: true
    version?: true
    installed?: true
    cached?: true
  }

  export type ZnoteMaxAggregateInputType = {
    id?: true
    version?: true
    installed?: true
    cached?: true
  }

  export type ZnoteCountAggregateInputType = {
    id?: true
    version?: true
    installed?: true
    cached?: true
    _all?: true
  }

  export type ZnoteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote to aggregate.
     */
    where?: znoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znotes to fetch.
     */
    orderBy?: Enumerable<znoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znotes
    **/
    _count?: true | ZnoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZnoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZnoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZnoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZnoteMaxAggregateInputType
  }

  export type GetZnoteAggregateType<T extends ZnoteAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote[P]>
      : GetScalarType<T[P], AggregateZnote[P]>
  }




  export type ZnoteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znoteWhereInput
    orderBy?: Enumerable<znoteOrderByWithAggregationInput>
    by: ZnoteScalarFieldEnum[]
    having?: znoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZnoteCountAggregateInputType | true
    _avg?: ZnoteAvgAggregateInputType
    _sum?: ZnoteSumAggregateInputType
    _min?: ZnoteMinAggregateInputType
    _max?: ZnoteMaxAggregateInputType
  }


  export type ZnoteGroupByOutputType = {
    id: number
    version: string
    installed: number
    cached: number | null
    _count: ZnoteCountAggregateOutputType | null
    _avg: ZnoteAvgAggregateOutputType | null
    _sum: ZnoteSumAggregateOutputType | null
    _min: ZnoteMinAggregateOutputType | null
    _max: ZnoteMaxAggregateOutputType | null
  }

  type GetZnoteGroupByPayload<T extends ZnoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ZnoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZnoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZnoteGroupByOutputType[P]>
            : GetScalarType<T[P], ZnoteGroupByOutputType[P]>
        }
      >
    >


  export type znoteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    installed?: boolean
    cached?: boolean
  }, ExtArgs["result"]["znote"]>

  export type znoteSelectScalar = {
    id?: boolean
    version?: boolean
    installed?: boolean
    cached?: boolean
  }


  type znoteGetPayload<S extends boolean | null | undefined | znoteArgs> = $Types.GetResult<znotePayload, S>

  type znoteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znoteFindManyArgs, 'select' | 'include'> & {
      select?: ZnoteCountAggregateInputType | true
    }

  export interface znoteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote'], meta: { name: 'znote' } }
    /**
     * Find zero or one Znote that matches the filter.
     * @param {znoteFindUniqueArgs} args - Arguments to find a Znote
     * @example
     * // Get one Znote
     * const znote = await prisma.znote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znoteFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znoteFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote'> extends True ? Prisma__znoteClient<$Types.GetResult<znotePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znoteClient<$Types.GetResult<znotePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znoteFindUniqueOrThrowArgs} args - Arguments to find a Znote
     * @example
     * // Get one Znote
     * const znote = await prisma.znote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znoteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znoteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znoteClient<$Types.GetResult<znotePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znoteFindFirstArgs} args - Arguments to find a Znote
     * @example
     * // Get one Znote
     * const znote = await prisma.znote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znoteFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znoteFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote'> extends True ? Prisma__znoteClient<$Types.GetResult<znotePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znoteClient<$Types.GetResult<znotePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znoteFindFirstOrThrowArgs} args - Arguments to find a Znote
     * @example
     * // Get one Znote
     * const znote = await prisma.znote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znoteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znoteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znoteClient<$Types.GetResult<znotePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znotes
     * const znotes = await prisma.znote.findMany()
     * 
     * // Get first 10 Znotes
     * const znotes = await prisma.znote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znoteWithIdOnly = await prisma.znote.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znoteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znoteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znotePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote.
     * @param {znoteCreateArgs} args - Arguments to create a Znote.
     * @example
     * // Create one Znote
     * const Znote = await prisma.znote.create({
     *   data: {
     *     // ... data to create a Znote
     *   }
     * })
     * 
    **/
    create<T extends znoteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znoteCreateArgs<ExtArgs>>
    ): Prisma__znoteClient<$Types.GetResult<znotePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znotes.
     *     @param {znoteCreateManyArgs} args - Arguments to create many Znotes.
     *     @example
     *     // Create many Znotes
     *     const znote = await prisma.znote.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znoteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znoteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote.
     * @param {znoteDeleteArgs} args - Arguments to delete one Znote.
     * @example
     * // Delete one Znote
     * const Znote = await prisma.znote.delete({
     *   where: {
     *     // ... filter to delete one Znote
     *   }
     * })
     * 
    **/
    delete<T extends znoteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znoteDeleteArgs<ExtArgs>>
    ): Prisma__znoteClient<$Types.GetResult<znotePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote.
     * @param {znoteUpdateArgs} args - Arguments to update one Znote.
     * @example
     * // Update one Znote
     * const znote = await prisma.znote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znoteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znoteUpdateArgs<ExtArgs>>
    ): Prisma__znoteClient<$Types.GetResult<znotePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znotes.
     * @param {znoteDeleteManyArgs} args - Arguments to filter Znotes to delete.
     * @example
     * // Delete a few Znotes
     * const { count } = await prisma.znote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znoteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znoteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znotes
     * const znote = await prisma.znote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znoteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znoteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote.
     * @param {znoteUpsertArgs} args - Arguments to update or create a Znote.
     * @example
     * // Update or create a Znote
     * const znote = await prisma.znote.upsert({
     *   create: {
     *     // ... data to create a Znote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote we want to update
     *   }
     * })
    **/
    upsert<T extends znoteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znoteUpsertArgs<ExtArgs>>
    ): Prisma__znoteClient<$Types.GetResult<znotePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znoteCountArgs} args - Arguments to filter Znotes to count.
     * @example
     * // Count the number of Znotes
     * const count = await prisma.znote.count({
     *   where: {
     *     // ... the filter for the Znotes we want to count
     *   }
     * })
    **/
    count<T extends znoteCountArgs>(
      args?: Subset<T, znoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZnoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZnoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZnoteAggregateArgs>(args: Subset<T, ZnoteAggregateArgs>): Prisma.PrismaPromise<GetZnoteAggregateType<T>>

    /**
     * Group by Znote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZnoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZnoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZnoteGroupByArgs['orderBy'] }
        : { orderBy?: ZnoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZnoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znoteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote base type for findUnique actions
   */
  export type znoteFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote
     */
    select?: znoteSelect<ExtArgs> | null
    /**
     * Filter, which znote to fetch.
     */
    where: znoteWhereUniqueInput
  }

  /**
   * znote findUnique
   */
  export interface znoteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znoteFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote findUniqueOrThrow
   */
  export type znoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote
     */
    select?: znoteSelect<ExtArgs> | null
    /**
     * Filter, which znote to fetch.
     */
    where: znoteWhereUniqueInput
  }


  /**
   * znote base type for findFirst actions
   */
  export type znoteFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote
     */
    select?: znoteSelect<ExtArgs> | null
    /**
     * Filter, which znote to fetch.
     */
    where?: znoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znotes to fetch.
     */
    orderBy?: Enumerable<znoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znotes.
     */
    cursor?: znoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znotes.
     */
    distinct?: Enumerable<ZnoteScalarFieldEnum>
  }

  /**
   * znote findFirst
   */
  export interface znoteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znoteFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote findFirstOrThrow
   */
  export type znoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote
     */
    select?: znoteSelect<ExtArgs> | null
    /**
     * Filter, which znote to fetch.
     */
    where?: znoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znotes to fetch.
     */
    orderBy?: Enumerable<znoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znotes.
     */
    cursor?: znoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znotes.
     */
    distinct?: Enumerable<ZnoteScalarFieldEnum>
  }


  /**
   * znote findMany
   */
  export type znoteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote
     */
    select?: znoteSelect<ExtArgs> | null
    /**
     * Filter, which znotes to fetch.
     */
    where?: znoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znotes to fetch.
     */
    orderBy?: Enumerable<znoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znotes.
     */
    cursor?: znoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znotes.
     */
    skip?: number
    distinct?: Enumerable<ZnoteScalarFieldEnum>
  }


  /**
   * znote create
   */
  export type znoteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote
     */
    select?: znoteSelect<ExtArgs> | null
    /**
     * The data needed to create a znote.
     */
    data: XOR<znoteCreateInput, znoteUncheckedCreateInput>
  }


  /**
   * znote createMany
   */
  export type znoteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znotes.
     */
    data: Enumerable<znoteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote update
   */
  export type znoteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote
     */
    select?: znoteSelect<ExtArgs> | null
    /**
     * The data needed to update a znote.
     */
    data: XOR<znoteUpdateInput, znoteUncheckedUpdateInput>
    /**
     * Choose, which znote to update.
     */
    where: znoteWhereUniqueInput
  }


  /**
   * znote updateMany
   */
  export type znoteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znotes.
     */
    data: XOR<znoteUpdateManyMutationInput, znoteUncheckedUpdateManyInput>
    /**
     * Filter which znotes to update
     */
    where?: znoteWhereInput
  }


  /**
   * znote upsert
   */
  export type znoteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote
     */
    select?: znoteSelect<ExtArgs> | null
    /**
     * The filter to search for the znote to update in case it exists.
     */
    where: znoteWhereUniqueInput
    /**
     * In case the znote found by the `where` argument doesn't exist, create a new znote with this data.
     */
    create: XOR<znoteCreateInput, znoteUncheckedCreateInput>
    /**
     * In case the znote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znoteUpdateInput, znoteUncheckedUpdateInput>
  }


  /**
   * znote delete
   */
  export type znoteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote
     */
    select?: znoteSelect<ExtArgs> | null
    /**
     * Filter which znote to delete.
     */
    where: znoteWhereUniqueInput
  }


  /**
   * znote deleteMany
   */
  export type znoteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znotes to delete
     */
    where?: znoteWhereInput
  }


  /**
   * znote without action
   */
  export type znoteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote
     */
    select?: znoteSelect<ExtArgs> | null
  }



  /**
   * Model znote_accounts
   */


  export type AggregateZnote_accounts = {
    _count: Znote_accountsCountAggregateOutputType | null
    _avg: Znote_accountsAvgAggregateOutputType | null
    _sum: Znote_accountsSumAggregateOutputType | null
    _min: Znote_accountsMinAggregateOutputType | null
    _max: Znote_accountsMaxAggregateOutputType | null
  }

  export type Znote_accountsAvgAggregateOutputType = {
    id: number | null
    account_id: number | null
    ip: number | null
    created: number | null
    points: number | null
    cooldown: number | null
    active: number | null
    active_email: number | null
    activekey: number | null
  }

  export type Znote_accountsSumAggregateOutputType = {
    id: number | null
    account_id: number | null
    ip: bigint | null
    created: number | null
    points: number | null
    cooldown: number | null
    active: number | null
    active_email: number | null
    activekey: number | null
  }

  export type Znote_accountsMinAggregateOutputType = {
    id: number | null
    account_id: number | null
    ip: bigint | null
    created: number | null
    points: number | null
    cooldown: number | null
    active: number | null
    active_email: number | null
    activekey: number | null
    flag: string | null
    secret: string | null
  }

  export type Znote_accountsMaxAggregateOutputType = {
    id: number | null
    account_id: number | null
    ip: bigint | null
    created: number | null
    points: number | null
    cooldown: number | null
    active: number | null
    active_email: number | null
    activekey: number | null
    flag: string | null
    secret: string | null
  }

  export type Znote_accountsCountAggregateOutputType = {
    id: number
    account_id: number
    ip: number
    created: number
    points: number
    cooldown: number
    active: number
    active_email: number
    activekey: number
    flag: number
    secret: number
    _all: number
  }


  export type Znote_accountsAvgAggregateInputType = {
    id?: true
    account_id?: true
    ip?: true
    created?: true
    points?: true
    cooldown?: true
    active?: true
    active_email?: true
    activekey?: true
  }

  export type Znote_accountsSumAggregateInputType = {
    id?: true
    account_id?: true
    ip?: true
    created?: true
    points?: true
    cooldown?: true
    active?: true
    active_email?: true
    activekey?: true
  }

  export type Znote_accountsMinAggregateInputType = {
    id?: true
    account_id?: true
    ip?: true
    created?: true
    points?: true
    cooldown?: true
    active?: true
    active_email?: true
    activekey?: true
    flag?: true
    secret?: true
  }

  export type Znote_accountsMaxAggregateInputType = {
    id?: true
    account_id?: true
    ip?: true
    created?: true
    points?: true
    cooldown?: true
    active?: true
    active_email?: true
    activekey?: true
    flag?: true
    secret?: true
  }

  export type Znote_accountsCountAggregateInputType = {
    id?: true
    account_id?: true
    ip?: true
    created?: true
    points?: true
    cooldown?: true
    active?: true
    active_email?: true
    activekey?: true
    flag?: true
    secret?: true
    _all?: true
  }

  export type Znote_accountsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_accounts to aggregate.
     */
    where?: znote_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_accounts to fetch.
     */
    orderBy?: Enumerable<znote_accountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_accounts
    **/
    _count?: true | Znote_accountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_accountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_accountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_accountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_accountsMaxAggregateInputType
  }

  export type GetZnote_accountsAggregateType<T extends Znote_accountsAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_accounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_accounts[P]>
      : GetScalarType<T[P], AggregateZnote_accounts[P]>
  }




  export type Znote_accountsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_accountsWhereInput
    orderBy?: Enumerable<znote_accountsOrderByWithAggregationInput>
    by: Znote_accountsScalarFieldEnum[]
    having?: znote_accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_accountsCountAggregateInputType | true
    _avg?: Znote_accountsAvgAggregateInputType
    _sum?: Znote_accountsSumAggregateInputType
    _min?: Znote_accountsMinAggregateInputType
    _max?: Znote_accountsMaxAggregateInputType
  }


  export type Znote_accountsGroupByOutputType = {
    id: number
    account_id: number
    ip: bigint
    created: number
    points: number | null
    cooldown: number | null
    active: number
    active_email: number
    activekey: number
    flag: string
    secret: string | null
    _count: Znote_accountsCountAggregateOutputType | null
    _avg: Znote_accountsAvgAggregateOutputType | null
    _sum: Znote_accountsSumAggregateOutputType | null
    _min: Znote_accountsMinAggregateOutputType | null
    _max: Znote_accountsMaxAggregateOutputType | null
  }

  type GetZnote_accountsGroupByPayload<T extends Znote_accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_accountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_accountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_accountsGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_accountsGroupByOutputType[P]>
        }
      >
    >


  export type znote_accountsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    ip?: boolean
    created?: boolean
    points?: boolean
    cooldown?: boolean
    active?: boolean
    active_email?: boolean
    activekey?: boolean
    flag?: boolean
    secret?: boolean
  }, ExtArgs["result"]["znote_accounts"]>

  export type znote_accountsSelectScalar = {
    id?: boolean
    account_id?: boolean
    ip?: boolean
    created?: boolean
    points?: boolean
    cooldown?: boolean
    active?: boolean
    active_email?: boolean
    activekey?: boolean
    flag?: boolean
    secret?: boolean
  }


  type znote_accountsGetPayload<S extends boolean | null | undefined | znote_accountsArgs> = $Types.GetResult<znote_accountsPayload, S>

  type znote_accountsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_accountsFindManyArgs, 'select' | 'include'> & {
      select?: Znote_accountsCountAggregateInputType | true
    }

  export interface znote_accountsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_accounts'], meta: { name: 'znote_accounts' } }
    /**
     * Find zero or one Znote_accounts that matches the filter.
     * @param {znote_accountsFindUniqueArgs} args - Arguments to find a Znote_accounts
     * @example
     * // Get one Znote_accounts
     * const znote_accounts = await prisma.znote_accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_accountsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_accountsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_accounts'> extends True ? Prisma__znote_accountsClient<$Types.GetResult<znote_accountsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_accountsClient<$Types.GetResult<znote_accountsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_accounts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_accountsFindUniqueOrThrowArgs} args - Arguments to find a Znote_accounts
     * @example
     * // Get one Znote_accounts
     * const znote_accounts = await prisma.znote_accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_accountsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_accountsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_accountsClient<$Types.GetResult<znote_accountsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_accountsFindFirstArgs} args - Arguments to find a Znote_accounts
     * @example
     * // Get one Znote_accounts
     * const znote_accounts = await prisma.znote_accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_accountsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_accountsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_accounts'> extends True ? Prisma__znote_accountsClient<$Types.GetResult<znote_accountsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_accountsClient<$Types.GetResult<znote_accountsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_accounts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_accountsFindFirstOrThrowArgs} args - Arguments to find a Znote_accounts
     * @example
     * // Get one Znote_accounts
     * const znote_accounts = await prisma.znote_accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_accountsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_accountsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_accountsClient<$Types.GetResult<znote_accountsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_accountsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_accounts
     * const znote_accounts = await prisma.znote_accounts.findMany()
     * 
     * // Get first 10 Znote_accounts
     * const znote_accounts = await prisma.znote_accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_accountsWithIdOnly = await prisma.znote_accounts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_accountsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_accountsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_accountsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_accounts.
     * @param {znote_accountsCreateArgs} args - Arguments to create a Znote_accounts.
     * @example
     * // Create one Znote_accounts
     * const Znote_accounts = await prisma.znote_accounts.create({
     *   data: {
     *     // ... data to create a Znote_accounts
     *   }
     * })
     * 
    **/
    create<T extends znote_accountsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_accountsCreateArgs<ExtArgs>>
    ): Prisma__znote_accountsClient<$Types.GetResult<znote_accountsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_accounts.
     *     @param {znote_accountsCreateManyArgs} args - Arguments to create many Znote_accounts.
     *     @example
     *     // Create many Znote_accounts
     *     const znote_accounts = await prisma.znote_accounts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_accountsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_accountsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_accounts.
     * @param {znote_accountsDeleteArgs} args - Arguments to delete one Znote_accounts.
     * @example
     * // Delete one Znote_accounts
     * const Znote_accounts = await prisma.znote_accounts.delete({
     *   where: {
     *     // ... filter to delete one Znote_accounts
     *   }
     * })
     * 
    **/
    delete<T extends znote_accountsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_accountsDeleteArgs<ExtArgs>>
    ): Prisma__znote_accountsClient<$Types.GetResult<znote_accountsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_accounts.
     * @param {znote_accountsUpdateArgs} args - Arguments to update one Znote_accounts.
     * @example
     * // Update one Znote_accounts
     * const znote_accounts = await prisma.znote_accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_accountsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_accountsUpdateArgs<ExtArgs>>
    ): Prisma__znote_accountsClient<$Types.GetResult<znote_accountsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_accounts.
     * @param {znote_accountsDeleteManyArgs} args - Arguments to filter Znote_accounts to delete.
     * @example
     * // Delete a few Znote_accounts
     * const { count } = await prisma.znote_accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_accountsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_accountsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_accounts
     * const znote_accounts = await prisma.znote_accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_accountsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_accountsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_accounts.
     * @param {znote_accountsUpsertArgs} args - Arguments to update or create a Znote_accounts.
     * @example
     * // Update or create a Znote_accounts
     * const znote_accounts = await prisma.znote_accounts.upsert({
     *   create: {
     *     // ... data to create a Znote_accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_accounts we want to update
     *   }
     * })
    **/
    upsert<T extends znote_accountsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_accountsUpsertArgs<ExtArgs>>
    ): Prisma__znote_accountsClient<$Types.GetResult<znote_accountsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_accountsCountArgs} args - Arguments to filter Znote_accounts to count.
     * @example
     * // Count the number of Znote_accounts
     * const count = await prisma.znote_accounts.count({
     *   where: {
     *     // ... the filter for the Znote_accounts we want to count
     *   }
     * })
    **/
    count<T extends znote_accountsCountArgs>(
      args?: Subset<T, znote_accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_accountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_accountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_accountsAggregateArgs>(args: Subset<T, Znote_accountsAggregateArgs>): Prisma.PrismaPromise<GetZnote_accountsAggregateType<T>>

    /**
     * Group by Znote_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_accountsGroupByArgs['orderBy'] }
        : { orderBy?: Znote_accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_accountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_accountsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_accounts base type for findUnique actions
   */
  export type znote_accountsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_accounts
     */
    select?: znote_accountsSelect<ExtArgs> | null
    /**
     * Filter, which znote_accounts to fetch.
     */
    where: znote_accountsWhereUniqueInput
  }

  /**
   * znote_accounts findUnique
   */
  export interface znote_accountsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_accountsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_accounts findUniqueOrThrow
   */
  export type znote_accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_accounts
     */
    select?: znote_accountsSelect<ExtArgs> | null
    /**
     * Filter, which znote_accounts to fetch.
     */
    where: znote_accountsWhereUniqueInput
  }


  /**
   * znote_accounts base type for findFirst actions
   */
  export type znote_accountsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_accounts
     */
    select?: znote_accountsSelect<ExtArgs> | null
    /**
     * Filter, which znote_accounts to fetch.
     */
    where?: znote_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_accounts to fetch.
     */
    orderBy?: Enumerable<znote_accountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_accounts.
     */
    cursor?: znote_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_accounts.
     */
    distinct?: Enumerable<Znote_accountsScalarFieldEnum>
  }

  /**
   * znote_accounts findFirst
   */
  export interface znote_accountsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_accountsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_accounts findFirstOrThrow
   */
  export type znote_accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_accounts
     */
    select?: znote_accountsSelect<ExtArgs> | null
    /**
     * Filter, which znote_accounts to fetch.
     */
    where?: znote_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_accounts to fetch.
     */
    orderBy?: Enumerable<znote_accountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_accounts.
     */
    cursor?: znote_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_accounts.
     */
    distinct?: Enumerable<Znote_accountsScalarFieldEnum>
  }


  /**
   * znote_accounts findMany
   */
  export type znote_accountsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_accounts
     */
    select?: znote_accountsSelect<ExtArgs> | null
    /**
     * Filter, which znote_accounts to fetch.
     */
    where?: znote_accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_accounts to fetch.
     */
    orderBy?: Enumerable<znote_accountsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_accounts.
     */
    cursor?: znote_accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_accounts.
     */
    skip?: number
    distinct?: Enumerable<Znote_accountsScalarFieldEnum>
  }


  /**
   * znote_accounts create
   */
  export type znote_accountsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_accounts
     */
    select?: znote_accountsSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_accounts.
     */
    data: XOR<znote_accountsCreateInput, znote_accountsUncheckedCreateInput>
  }


  /**
   * znote_accounts createMany
   */
  export type znote_accountsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_accounts.
     */
    data: Enumerable<znote_accountsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_accounts update
   */
  export type znote_accountsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_accounts
     */
    select?: znote_accountsSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_accounts.
     */
    data: XOR<znote_accountsUpdateInput, znote_accountsUncheckedUpdateInput>
    /**
     * Choose, which znote_accounts to update.
     */
    where: znote_accountsWhereUniqueInput
  }


  /**
   * znote_accounts updateMany
   */
  export type znote_accountsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_accounts.
     */
    data: XOR<znote_accountsUpdateManyMutationInput, znote_accountsUncheckedUpdateManyInput>
    /**
     * Filter which znote_accounts to update
     */
    where?: znote_accountsWhereInput
  }


  /**
   * znote_accounts upsert
   */
  export type znote_accountsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_accounts
     */
    select?: znote_accountsSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_accounts to update in case it exists.
     */
    where: znote_accountsWhereUniqueInput
    /**
     * In case the znote_accounts found by the `where` argument doesn't exist, create a new znote_accounts with this data.
     */
    create: XOR<znote_accountsCreateInput, znote_accountsUncheckedCreateInput>
    /**
     * In case the znote_accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_accountsUpdateInput, znote_accountsUncheckedUpdateInput>
  }


  /**
   * znote_accounts delete
   */
  export type znote_accountsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_accounts
     */
    select?: znote_accountsSelect<ExtArgs> | null
    /**
     * Filter which znote_accounts to delete.
     */
    where: znote_accountsWhereUniqueInput
  }


  /**
   * znote_accounts deleteMany
   */
  export type znote_accountsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_accounts to delete
     */
    where?: znote_accountsWhereInput
  }


  /**
   * znote_accounts without action
   */
  export type znote_accountsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_accounts
     */
    select?: znote_accountsSelect<ExtArgs> | null
  }



  /**
   * Model znote_auction_player
   */


  export type AggregateZnote_auction_player = {
    _count: Znote_auction_playerCountAggregateOutputType | null
    _avg: Znote_auction_playerAvgAggregateOutputType | null
    _sum: Znote_auction_playerSumAggregateOutputType | null
    _min: Znote_auction_playerMinAggregateOutputType | null
    _max: Znote_auction_playerMaxAggregateOutputType | null
  }

  export type Znote_auction_playerAvgAggregateOutputType = {
    id: number | null
    player_id: number | null
    original_account_id: number | null
    bidder_account_id: number | null
    time_begin: number | null
    time_end: number | null
    price: number | null
    bid: number | null
    deposit: number | null
    sold: number | null
    claimed: number | null
  }

  export type Znote_auction_playerSumAggregateOutputType = {
    id: number | null
    player_id: number | null
    original_account_id: number | null
    bidder_account_id: number | null
    time_begin: number | null
    time_end: number | null
    price: number | null
    bid: number | null
    deposit: number | null
    sold: number | null
    claimed: number | null
  }

  export type Znote_auction_playerMinAggregateOutputType = {
    id: number | null
    player_id: number | null
    original_account_id: number | null
    bidder_account_id: number | null
    time_begin: number | null
    time_end: number | null
    price: number | null
    bid: number | null
    deposit: number | null
    sold: number | null
    claimed: number | null
  }

  export type Znote_auction_playerMaxAggregateOutputType = {
    id: number | null
    player_id: number | null
    original_account_id: number | null
    bidder_account_id: number | null
    time_begin: number | null
    time_end: number | null
    price: number | null
    bid: number | null
    deposit: number | null
    sold: number | null
    claimed: number | null
  }

  export type Znote_auction_playerCountAggregateOutputType = {
    id: number
    player_id: number
    original_account_id: number
    bidder_account_id: number
    time_begin: number
    time_end: number
    price: number
    bid: number
    deposit: number
    sold: number
    claimed: number
    _all: number
  }


  export type Znote_auction_playerAvgAggregateInputType = {
    id?: true
    player_id?: true
    original_account_id?: true
    bidder_account_id?: true
    time_begin?: true
    time_end?: true
    price?: true
    bid?: true
    deposit?: true
    sold?: true
    claimed?: true
  }

  export type Znote_auction_playerSumAggregateInputType = {
    id?: true
    player_id?: true
    original_account_id?: true
    bidder_account_id?: true
    time_begin?: true
    time_end?: true
    price?: true
    bid?: true
    deposit?: true
    sold?: true
    claimed?: true
  }

  export type Znote_auction_playerMinAggregateInputType = {
    id?: true
    player_id?: true
    original_account_id?: true
    bidder_account_id?: true
    time_begin?: true
    time_end?: true
    price?: true
    bid?: true
    deposit?: true
    sold?: true
    claimed?: true
  }

  export type Znote_auction_playerMaxAggregateInputType = {
    id?: true
    player_id?: true
    original_account_id?: true
    bidder_account_id?: true
    time_begin?: true
    time_end?: true
    price?: true
    bid?: true
    deposit?: true
    sold?: true
    claimed?: true
  }

  export type Znote_auction_playerCountAggregateInputType = {
    id?: true
    player_id?: true
    original_account_id?: true
    bidder_account_id?: true
    time_begin?: true
    time_end?: true
    price?: true
    bid?: true
    deposit?: true
    sold?: true
    claimed?: true
    _all?: true
  }

  export type Znote_auction_playerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_auction_player to aggregate.
     */
    where?: znote_auction_playerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_auction_players to fetch.
     */
    orderBy?: Enumerable<znote_auction_playerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_auction_playerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_auction_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_auction_players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_auction_players
    **/
    _count?: true | Znote_auction_playerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_auction_playerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_auction_playerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_auction_playerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_auction_playerMaxAggregateInputType
  }

  export type GetZnote_auction_playerAggregateType<T extends Znote_auction_playerAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_auction_player]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_auction_player[P]>
      : GetScalarType<T[P], AggregateZnote_auction_player[P]>
  }




  export type Znote_auction_playerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_auction_playerWhereInput
    orderBy?: Enumerable<znote_auction_playerOrderByWithAggregationInput>
    by: Znote_auction_playerScalarFieldEnum[]
    having?: znote_auction_playerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_auction_playerCountAggregateInputType | true
    _avg?: Znote_auction_playerAvgAggregateInputType
    _sum?: Znote_auction_playerSumAggregateInputType
    _min?: Znote_auction_playerMinAggregateInputType
    _max?: Znote_auction_playerMaxAggregateInputType
  }


  export type Znote_auction_playerGroupByOutputType = {
    id: number
    player_id: number
    original_account_id: number
    bidder_account_id: number
    time_begin: number
    time_end: number
    price: number
    bid: number
    deposit: number
    sold: number
    claimed: number
    _count: Znote_auction_playerCountAggregateOutputType | null
    _avg: Znote_auction_playerAvgAggregateOutputType | null
    _sum: Znote_auction_playerSumAggregateOutputType | null
    _min: Znote_auction_playerMinAggregateOutputType | null
    _max: Znote_auction_playerMaxAggregateOutputType | null
  }

  type GetZnote_auction_playerGroupByPayload<T extends Znote_auction_playerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_auction_playerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_auction_playerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_auction_playerGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_auction_playerGroupByOutputType[P]>
        }
      >
    >


  export type znote_auction_playerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    original_account_id?: boolean
    bidder_account_id?: boolean
    time_begin?: boolean
    time_end?: boolean
    price?: boolean
    bid?: boolean
    deposit?: boolean
    sold?: boolean
    claimed?: boolean
  }, ExtArgs["result"]["znote_auction_player"]>

  export type znote_auction_playerSelectScalar = {
    id?: boolean
    player_id?: boolean
    original_account_id?: boolean
    bidder_account_id?: boolean
    time_begin?: boolean
    time_end?: boolean
    price?: boolean
    bid?: boolean
    deposit?: boolean
    sold?: boolean
    claimed?: boolean
  }


  type znote_auction_playerGetPayload<S extends boolean | null | undefined | znote_auction_playerArgs> = $Types.GetResult<znote_auction_playerPayload, S>

  type znote_auction_playerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_auction_playerFindManyArgs, 'select' | 'include'> & {
      select?: Znote_auction_playerCountAggregateInputType | true
    }

  export interface znote_auction_playerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_auction_player'], meta: { name: 'znote_auction_player' } }
    /**
     * Find zero or one Znote_auction_player that matches the filter.
     * @param {znote_auction_playerFindUniqueArgs} args - Arguments to find a Znote_auction_player
     * @example
     * // Get one Znote_auction_player
     * const znote_auction_player = await prisma.znote_auction_player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_auction_playerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_auction_playerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_auction_player'> extends True ? Prisma__znote_auction_playerClient<$Types.GetResult<znote_auction_playerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_auction_playerClient<$Types.GetResult<znote_auction_playerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_auction_player that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_auction_playerFindUniqueOrThrowArgs} args - Arguments to find a Znote_auction_player
     * @example
     * // Get one Znote_auction_player
     * const znote_auction_player = await prisma.znote_auction_player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_auction_playerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_auction_playerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_auction_playerClient<$Types.GetResult<znote_auction_playerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_auction_player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_auction_playerFindFirstArgs} args - Arguments to find a Znote_auction_player
     * @example
     * // Get one Znote_auction_player
     * const znote_auction_player = await prisma.znote_auction_player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_auction_playerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_auction_playerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_auction_player'> extends True ? Prisma__znote_auction_playerClient<$Types.GetResult<znote_auction_playerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_auction_playerClient<$Types.GetResult<znote_auction_playerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_auction_player that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_auction_playerFindFirstOrThrowArgs} args - Arguments to find a Znote_auction_player
     * @example
     * // Get one Znote_auction_player
     * const znote_auction_player = await prisma.znote_auction_player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_auction_playerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_auction_playerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_auction_playerClient<$Types.GetResult<znote_auction_playerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_auction_players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_auction_playerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_auction_players
     * const znote_auction_players = await prisma.znote_auction_player.findMany()
     * 
     * // Get first 10 Znote_auction_players
     * const znote_auction_players = await prisma.znote_auction_player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_auction_playerWithIdOnly = await prisma.znote_auction_player.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_auction_playerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_auction_playerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_auction_playerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_auction_player.
     * @param {znote_auction_playerCreateArgs} args - Arguments to create a Znote_auction_player.
     * @example
     * // Create one Znote_auction_player
     * const Znote_auction_player = await prisma.znote_auction_player.create({
     *   data: {
     *     // ... data to create a Znote_auction_player
     *   }
     * })
     * 
    **/
    create<T extends znote_auction_playerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_auction_playerCreateArgs<ExtArgs>>
    ): Prisma__znote_auction_playerClient<$Types.GetResult<znote_auction_playerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_auction_players.
     *     @param {znote_auction_playerCreateManyArgs} args - Arguments to create many Znote_auction_players.
     *     @example
     *     // Create many Znote_auction_players
     *     const znote_auction_player = await prisma.znote_auction_player.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_auction_playerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_auction_playerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_auction_player.
     * @param {znote_auction_playerDeleteArgs} args - Arguments to delete one Znote_auction_player.
     * @example
     * // Delete one Znote_auction_player
     * const Znote_auction_player = await prisma.znote_auction_player.delete({
     *   where: {
     *     // ... filter to delete one Znote_auction_player
     *   }
     * })
     * 
    **/
    delete<T extends znote_auction_playerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_auction_playerDeleteArgs<ExtArgs>>
    ): Prisma__znote_auction_playerClient<$Types.GetResult<znote_auction_playerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_auction_player.
     * @param {znote_auction_playerUpdateArgs} args - Arguments to update one Znote_auction_player.
     * @example
     * // Update one Znote_auction_player
     * const znote_auction_player = await prisma.znote_auction_player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_auction_playerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_auction_playerUpdateArgs<ExtArgs>>
    ): Prisma__znote_auction_playerClient<$Types.GetResult<znote_auction_playerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_auction_players.
     * @param {znote_auction_playerDeleteManyArgs} args - Arguments to filter Znote_auction_players to delete.
     * @example
     * // Delete a few Znote_auction_players
     * const { count } = await prisma.znote_auction_player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_auction_playerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_auction_playerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_auction_players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_auction_playerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_auction_players
     * const znote_auction_player = await prisma.znote_auction_player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_auction_playerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_auction_playerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_auction_player.
     * @param {znote_auction_playerUpsertArgs} args - Arguments to update or create a Znote_auction_player.
     * @example
     * // Update or create a Znote_auction_player
     * const znote_auction_player = await prisma.znote_auction_player.upsert({
     *   create: {
     *     // ... data to create a Znote_auction_player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_auction_player we want to update
     *   }
     * })
    **/
    upsert<T extends znote_auction_playerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_auction_playerUpsertArgs<ExtArgs>>
    ): Prisma__znote_auction_playerClient<$Types.GetResult<znote_auction_playerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_auction_players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_auction_playerCountArgs} args - Arguments to filter Znote_auction_players to count.
     * @example
     * // Count the number of Znote_auction_players
     * const count = await prisma.znote_auction_player.count({
     *   where: {
     *     // ... the filter for the Znote_auction_players we want to count
     *   }
     * })
    **/
    count<T extends znote_auction_playerCountArgs>(
      args?: Subset<T, znote_auction_playerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_auction_playerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_auction_player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_auction_playerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_auction_playerAggregateArgs>(args: Subset<T, Znote_auction_playerAggregateArgs>): Prisma.PrismaPromise<GetZnote_auction_playerAggregateType<T>>

    /**
     * Group by Znote_auction_player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_auction_playerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_auction_playerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_auction_playerGroupByArgs['orderBy'] }
        : { orderBy?: Znote_auction_playerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_auction_playerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_auction_playerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_auction_player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_auction_playerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_auction_player base type for findUnique actions
   */
  export type znote_auction_playerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_auction_player
     */
    select?: znote_auction_playerSelect<ExtArgs> | null
    /**
     * Filter, which znote_auction_player to fetch.
     */
    where: znote_auction_playerWhereUniqueInput
  }

  /**
   * znote_auction_player findUnique
   */
  export interface znote_auction_playerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_auction_playerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_auction_player findUniqueOrThrow
   */
  export type znote_auction_playerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_auction_player
     */
    select?: znote_auction_playerSelect<ExtArgs> | null
    /**
     * Filter, which znote_auction_player to fetch.
     */
    where: znote_auction_playerWhereUniqueInput
  }


  /**
   * znote_auction_player base type for findFirst actions
   */
  export type znote_auction_playerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_auction_player
     */
    select?: znote_auction_playerSelect<ExtArgs> | null
    /**
     * Filter, which znote_auction_player to fetch.
     */
    where?: znote_auction_playerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_auction_players to fetch.
     */
    orderBy?: Enumerable<znote_auction_playerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_auction_players.
     */
    cursor?: znote_auction_playerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_auction_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_auction_players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_auction_players.
     */
    distinct?: Enumerable<Znote_auction_playerScalarFieldEnum>
  }

  /**
   * znote_auction_player findFirst
   */
  export interface znote_auction_playerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_auction_playerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_auction_player findFirstOrThrow
   */
  export type znote_auction_playerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_auction_player
     */
    select?: znote_auction_playerSelect<ExtArgs> | null
    /**
     * Filter, which znote_auction_player to fetch.
     */
    where?: znote_auction_playerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_auction_players to fetch.
     */
    orderBy?: Enumerable<znote_auction_playerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_auction_players.
     */
    cursor?: znote_auction_playerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_auction_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_auction_players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_auction_players.
     */
    distinct?: Enumerable<Znote_auction_playerScalarFieldEnum>
  }


  /**
   * znote_auction_player findMany
   */
  export type znote_auction_playerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_auction_player
     */
    select?: znote_auction_playerSelect<ExtArgs> | null
    /**
     * Filter, which znote_auction_players to fetch.
     */
    where?: znote_auction_playerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_auction_players to fetch.
     */
    orderBy?: Enumerable<znote_auction_playerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_auction_players.
     */
    cursor?: znote_auction_playerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_auction_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_auction_players.
     */
    skip?: number
    distinct?: Enumerable<Znote_auction_playerScalarFieldEnum>
  }


  /**
   * znote_auction_player create
   */
  export type znote_auction_playerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_auction_player
     */
    select?: znote_auction_playerSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_auction_player.
     */
    data: XOR<znote_auction_playerCreateInput, znote_auction_playerUncheckedCreateInput>
  }


  /**
   * znote_auction_player createMany
   */
  export type znote_auction_playerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_auction_players.
     */
    data: Enumerable<znote_auction_playerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_auction_player update
   */
  export type znote_auction_playerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_auction_player
     */
    select?: znote_auction_playerSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_auction_player.
     */
    data: XOR<znote_auction_playerUpdateInput, znote_auction_playerUncheckedUpdateInput>
    /**
     * Choose, which znote_auction_player to update.
     */
    where: znote_auction_playerWhereUniqueInput
  }


  /**
   * znote_auction_player updateMany
   */
  export type znote_auction_playerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_auction_players.
     */
    data: XOR<znote_auction_playerUpdateManyMutationInput, znote_auction_playerUncheckedUpdateManyInput>
    /**
     * Filter which znote_auction_players to update
     */
    where?: znote_auction_playerWhereInput
  }


  /**
   * znote_auction_player upsert
   */
  export type znote_auction_playerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_auction_player
     */
    select?: znote_auction_playerSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_auction_player to update in case it exists.
     */
    where: znote_auction_playerWhereUniqueInput
    /**
     * In case the znote_auction_player found by the `where` argument doesn't exist, create a new znote_auction_player with this data.
     */
    create: XOR<znote_auction_playerCreateInput, znote_auction_playerUncheckedCreateInput>
    /**
     * In case the znote_auction_player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_auction_playerUpdateInput, znote_auction_playerUncheckedUpdateInput>
  }


  /**
   * znote_auction_player delete
   */
  export type znote_auction_playerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_auction_player
     */
    select?: znote_auction_playerSelect<ExtArgs> | null
    /**
     * Filter which znote_auction_player to delete.
     */
    where: znote_auction_playerWhereUniqueInput
  }


  /**
   * znote_auction_player deleteMany
   */
  export type znote_auction_playerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_auction_players to delete
     */
    where?: znote_auction_playerWhereInput
  }


  /**
   * znote_auction_player without action
   */
  export type znote_auction_playerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_auction_player
     */
    select?: znote_auction_playerSelect<ExtArgs> | null
  }



  /**
   * Model znote_changelog
   */


  export type AggregateZnote_changelog = {
    _count: Znote_changelogCountAggregateOutputType | null
    _avg: Znote_changelogAvgAggregateOutputType | null
    _sum: Znote_changelogSumAggregateOutputType | null
    _min: Znote_changelogMinAggregateOutputType | null
    _max: Znote_changelogMaxAggregateOutputType | null
  }

  export type Znote_changelogAvgAggregateOutputType = {
    id: number | null
    time: number | null
    report_id: number | null
    status: number | null
  }

  export type Znote_changelogSumAggregateOutputType = {
    id: number | null
    time: number | null
    report_id: number | null
    status: number | null
  }

  export type Znote_changelogMinAggregateOutputType = {
    id: number | null
    text: string | null
    time: number | null
    report_id: number | null
    status: number | null
  }

  export type Znote_changelogMaxAggregateOutputType = {
    id: number | null
    text: string | null
    time: number | null
    report_id: number | null
    status: number | null
  }

  export type Znote_changelogCountAggregateOutputType = {
    id: number
    text: number
    time: number
    report_id: number
    status: number
    _all: number
  }


  export type Znote_changelogAvgAggregateInputType = {
    id?: true
    time?: true
    report_id?: true
    status?: true
  }

  export type Znote_changelogSumAggregateInputType = {
    id?: true
    time?: true
    report_id?: true
    status?: true
  }

  export type Znote_changelogMinAggregateInputType = {
    id?: true
    text?: true
    time?: true
    report_id?: true
    status?: true
  }

  export type Znote_changelogMaxAggregateInputType = {
    id?: true
    text?: true
    time?: true
    report_id?: true
    status?: true
  }

  export type Znote_changelogCountAggregateInputType = {
    id?: true
    text?: true
    time?: true
    report_id?: true
    status?: true
    _all?: true
  }

  export type Znote_changelogAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_changelog to aggregate.
     */
    where?: znote_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_changelogs to fetch.
     */
    orderBy?: Enumerable<znote_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_changelogs
    **/
    _count?: true | Znote_changelogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_changelogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_changelogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_changelogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_changelogMaxAggregateInputType
  }

  export type GetZnote_changelogAggregateType<T extends Znote_changelogAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_changelog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_changelog[P]>
      : GetScalarType<T[P], AggregateZnote_changelog[P]>
  }




  export type Znote_changelogGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_changelogWhereInput
    orderBy?: Enumerable<znote_changelogOrderByWithAggregationInput>
    by: Znote_changelogScalarFieldEnum[]
    having?: znote_changelogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_changelogCountAggregateInputType | true
    _avg?: Znote_changelogAvgAggregateInputType
    _sum?: Znote_changelogSumAggregateInputType
    _min?: Znote_changelogMinAggregateInputType
    _max?: Znote_changelogMaxAggregateInputType
  }


  export type Znote_changelogGroupByOutputType = {
    id: number
    text: string
    time: number
    report_id: number
    status: number
    _count: Znote_changelogCountAggregateOutputType | null
    _avg: Znote_changelogAvgAggregateOutputType | null
    _sum: Znote_changelogSumAggregateOutputType | null
    _min: Znote_changelogMinAggregateOutputType | null
    _max: Znote_changelogMaxAggregateOutputType | null
  }

  type GetZnote_changelogGroupByPayload<T extends Znote_changelogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_changelogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_changelogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_changelogGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_changelogGroupByOutputType[P]>
        }
      >
    >


  export type znote_changelogSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    time?: boolean
    report_id?: boolean
    status?: boolean
  }, ExtArgs["result"]["znote_changelog"]>

  export type znote_changelogSelectScalar = {
    id?: boolean
    text?: boolean
    time?: boolean
    report_id?: boolean
    status?: boolean
  }


  type znote_changelogGetPayload<S extends boolean | null | undefined | znote_changelogArgs> = $Types.GetResult<znote_changelogPayload, S>

  type znote_changelogCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_changelogFindManyArgs, 'select' | 'include'> & {
      select?: Znote_changelogCountAggregateInputType | true
    }

  export interface znote_changelogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_changelog'], meta: { name: 'znote_changelog' } }
    /**
     * Find zero or one Znote_changelog that matches the filter.
     * @param {znote_changelogFindUniqueArgs} args - Arguments to find a Znote_changelog
     * @example
     * // Get one Znote_changelog
     * const znote_changelog = await prisma.znote_changelog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_changelogFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_changelogFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_changelog'> extends True ? Prisma__znote_changelogClient<$Types.GetResult<znote_changelogPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_changelogClient<$Types.GetResult<znote_changelogPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_changelog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_changelogFindUniqueOrThrowArgs} args - Arguments to find a Znote_changelog
     * @example
     * // Get one Znote_changelog
     * const znote_changelog = await prisma.znote_changelog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_changelogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_changelogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_changelogClient<$Types.GetResult<znote_changelogPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_changelog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_changelogFindFirstArgs} args - Arguments to find a Znote_changelog
     * @example
     * // Get one Znote_changelog
     * const znote_changelog = await prisma.znote_changelog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_changelogFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_changelogFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_changelog'> extends True ? Prisma__znote_changelogClient<$Types.GetResult<znote_changelogPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_changelogClient<$Types.GetResult<znote_changelogPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_changelog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_changelogFindFirstOrThrowArgs} args - Arguments to find a Znote_changelog
     * @example
     * // Get one Znote_changelog
     * const znote_changelog = await prisma.znote_changelog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_changelogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_changelogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_changelogClient<$Types.GetResult<znote_changelogPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_changelogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_changelogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_changelogs
     * const znote_changelogs = await prisma.znote_changelog.findMany()
     * 
     * // Get first 10 Znote_changelogs
     * const znote_changelogs = await prisma.znote_changelog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_changelogWithIdOnly = await prisma.znote_changelog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_changelogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_changelogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_changelogPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_changelog.
     * @param {znote_changelogCreateArgs} args - Arguments to create a Znote_changelog.
     * @example
     * // Create one Znote_changelog
     * const Znote_changelog = await prisma.znote_changelog.create({
     *   data: {
     *     // ... data to create a Znote_changelog
     *   }
     * })
     * 
    **/
    create<T extends znote_changelogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_changelogCreateArgs<ExtArgs>>
    ): Prisma__znote_changelogClient<$Types.GetResult<znote_changelogPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_changelogs.
     *     @param {znote_changelogCreateManyArgs} args - Arguments to create many Znote_changelogs.
     *     @example
     *     // Create many Znote_changelogs
     *     const znote_changelog = await prisma.znote_changelog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_changelogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_changelogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_changelog.
     * @param {znote_changelogDeleteArgs} args - Arguments to delete one Znote_changelog.
     * @example
     * // Delete one Znote_changelog
     * const Znote_changelog = await prisma.znote_changelog.delete({
     *   where: {
     *     // ... filter to delete one Znote_changelog
     *   }
     * })
     * 
    **/
    delete<T extends znote_changelogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_changelogDeleteArgs<ExtArgs>>
    ): Prisma__znote_changelogClient<$Types.GetResult<znote_changelogPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_changelog.
     * @param {znote_changelogUpdateArgs} args - Arguments to update one Znote_changelog.
     * @example
     * // Update one Znote_changelog
     * const znote_changelog = await prisma.znote_changelog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_changelogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_changelogUpdateArgs<ExtArgs>>
    ): Prisma__znote_changelogClient<$Types.GetResult<znote_changelogPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_changelogs.
     * @param {znote_changelogDeleteManyArgs} args - Arguments to filter Znote_changelogs to delete.
     * @example
     * // Delete a few Znote_changelogs
     * const { count } = await prisma.znote_changelog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_changelogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_changelogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_changelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_changelogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_changelogs
     * const znote_changelog = await prisma.znote_changelog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_changelogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_changelogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_changelog.
     * @param {znote_changelogUpsertArgs} args - Arguments to update or create a Znote_changelog.
     * @example
     * // Update or create a Znote_changelog
     * const znote_changelog = await prisma.znote_changelog.upsert({
     *   create: {
     *     // ... data to create a Znote_changelog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_changelog we want to update
     *   }
     * })
    **/
    upsert<T extends znote_changelogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_changelogUpsertArgs<ExtArgs>>
    ): Prisma__znote_changelogClient<$Types.GetResult<znote_changelogPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_changelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_changelogCountArgs} args - Arguments to filter Znote_changelogs to count.
     * @example
     * // Count the number of Znote_changelogs
     * const count = await prisma.znote_changelog.count({
     *   where: {
     *     // ... the filter for the Znote_changelogs we want to count
     *   }
     * })
    **/
    count<T extends znote_changelogCountArgs>(
      args?: Subset<T, znote_changelogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_changelogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_changelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_changelogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_changelogAggregateArgs>(args: Subset<T, Znote_changelogAggregateArgs>): Prisma.PrismaPromise<GetZnote_changelogAggregateType<T>>

    /**
     * Group by Znote_changelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_changelogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_changelogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_changelogGroupByArgs['orderBy'] }
        : { orderBy?: Znote_changelogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_changelogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_changelogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_changelog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_changelogClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_changelog base type for findUnique actions
   */
  export type znote_changelogFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_changelog
     */
    select?: znote_changelogSelect<ExtArgs> | null
    /**
     * Filter, which znote_changelog to fetch.
     */
    where: znote_changelogWhereUniqueInput
  }

  /**
   * znote_changelog findUnique
   */
  export interface znote_changelogFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_changelogFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_changelog findUniqueOrThrow
   */
  export type znote_changelogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_changelog
     */
    select?: znote_changelogSelect<ExtArgs> | null
    /**
     * Filter, which znote_changelog to fetch.
     */
    where: znote_changelogWhereUniqueInput
  }


  /**
   * znote_changelog base type for findFirst actions
   */
  export type znote_changelogFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_changelog
     */
    select?: znote_changelogSelect<ExtArgs> | null
    /**
     * Filter, which znote_changelog to fetch.
     */
    where?: znote_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_changelogs to fetch.
     */
    orderBy?: Enumerable<znote_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_changelogs.
     */
    cursor?: znote_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_changelogs.
     */
    distinct?: Enumerable<Znote_changelogScalarFieldEnum>
  }

  /**
   * znote_changelog findFirst
   */
  export interface znote_changelogFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_changelogFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_changelog findFirstOrThrow
   */
  export type znote_changelogFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_changelog
     */
    select?: znote_changelogSelect<ExtArgs> | null
    /**
     * Filter, which znote_changelog to fetch.
     */
    where?: znote_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_changelogs to fetch.
     */
    orderBy?: Enumerable<znote_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_changelogs.
     */
    cursor?: znote_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_changelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_changelogs.
     */
    distinct?: Enumerable<Znote_changelogScalarFieldEnum>
  }


  /**
   * znote_changelog findMany
   */
  export type znote_changelogFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_changelog
     */
    select?: znote_changelogSelect<ExtArgs> | null
    /**
     * Filter, which znote_changelogs to fetch.
     */
    where?: znote_changelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_changelogs to fetch.
     */
    orderBy?: Enumerable<znote_changelogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_changelogs.
     */
    cursor?: znote_changelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_changelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_changelogs.
     */
    skip?: number
    distinct?: Enumerable<Znote_changelogScalarFieldEnum>
  }


  /**
   * znote_changelog create
   */
  export type znote_changelogCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_changelog
     */
    select?: znote_changelogSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_changelog.
     */
    data: XOR<znote_changelogCreateInput, znote_changelogUncheckedCreateInput>
  }


  /**
   * znote_changelog createMany
   */
  export type znote_changelogCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_changelogs.
     */
    data: Enumerable<znote_changelogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_changelog update
   */
  export type znote_changelogUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_changelog
     */
    select?: znote_changelogSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_changelog.
     */
    data: XOR<znote_changelogUpdateInput, znote_changelogUncheckedUpdateInput>
    /**
     * Choose, which znote_changelog to update.
     */
    where: znote_changelogWhereUniqueInput
  }


  /**
   * znote_changelog updateMany
   */
  export type znote_changelogUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_changelogs.
     */
    data: XOR<znote_changelogUpdateManyMutationInput, znote_changelogUncheckedUpdateManyInput>
    /**
     * Filter which znote_changelogs to update
     */
    where?: znote_changelogWhereInput
  }


  /**
   * znote_changelog upsert
   */
  export type znote_changelogUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_changelog
     */
    select?: znote_changelogSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_changelog to update in case it exists.
     */
    where: znote_changelogWhereUniqueInput
    /**
     * In case the znote_changelog found by the `where` argument doesn't exist, create a new znote_changelog with this data.
     */
    create: XOR<znote_changelogCreateInput, znote_changelogUncheckedCreateInput>
    /**
     * In case the znote_changelog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_changelogUpdateInput, znote_changelogUncheckedUpdateInput>
  }


  /**
   * znote_changelog delete
   */
  export type znote_changelogDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_changelog
     */
    select?: znote_changelogSelect<ExtArgs> | null
    /**
     * Filter which znote_changelog to delete.
     */
    where: znote_changelogWhereUniqueInput
  }


  /**
   * znote_changelog deleteMany
   */
  export type znote_changelogDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_changelogs to delete
     */
    where?: znote_changelogWhereInput
  }


  /**
   * znote_changelog without action
   */
  export type znote_changelogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_changelog
     */
    select?: znote_changelogSelect<ExtArgs> | null
  }



  /**
   * Model znote_deleted_characters
   */


  export type AggregateZnote_deleted_characters = {
    _count: Znote_deleted_charactersCountAggregateOutputType | null
    _avg: Znote_deleted_charactersAvgAggregateOutputType | null
    _sum: Znote_deleted_charactersSumAggregateOutputType | null
    _min: Znote_deleted_charactersMinAggregateOutputType | null
    _max: Znote_deleted_charactersMaxAggregateOutputType | null
  }

  export type Znote_deleted_charactersAvgAggregateOutputType = {
    id: number | null
    original_account_id: number | null
    done: number | null
  }

  export type Znote_deleted_charactersSumAggregateOutputType = {
    id: number | null
    original_account_id: number | null
    done: number | null
  }

  export type Znote_deleted_charactersMinAggregateOutputType = {
    id: number | null
    original_account_id: number | null
    character_name: string | null
    time: Date | null
    done: number | null
  }

  export type Znote_deleted_charactersMaxAggregateOutputType = {
    id: number | null
    original_account_id: number | null
    character_name: string | null
    time: Date | null
    done: number | null
  }

  export type Znote_deleted_charactersCountAggregateOutputType = {
    id: number
    original_account_id: number
    character_name: number
    time: number
    done: number
    _all: number
  }


  export type Znote_deleted_charactersAvgAggregateInputType = {
    id?: true
    original_account_id?: true
    done?: true
  }

  export type Znote_deleted_charactersSumAggregateInputType = {
    id?: true
    original_account_id?: true
    done?: true
  }

  export type Znote_deleted_charactersMinAggregateInputType = {
    id?: true
    original_account_id?: true
    character_name?: true
    time?: true
    done?: true
  }

  export type Znote_deleted_charactersMaxAggregateInputType = {
    id?: true
    original_account_id?: true
    character_name?: true
    time?: true
    done?: true
  }

  export type Znote_deleted_charactersCountAggregateInputType = {
    id?: true
    original_account_id?: true
    character_name?: true
    time?: true
    done?: true
    _all?: true
  }

  export type Znote_deleted_charactersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_deleted_characters to aggregate.
     */
    where?: znote_deleted_charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_deleted_characters to fetch.
     */
    orderBy?: Enumerable<znote_deleted_charactersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_deleted_charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_deleted_characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_deleted_characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_deleted_characters
    **/
    _count?: true | Znote_deleted_charactersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_deleted_charactersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_deleted_charactersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_deleted_charactersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_deleted_charactersMaxAggregateInputType
  }

  export type GetZnote_deleted_charactersAggregateType<T extends Znote_deleted_charactersAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_deleted_characters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_deleted_characters[P]>
      : GetScalarType<T[P], AggregateZnote_deleted_characters[P]>
  }




  export type Znote_deleted_charactersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_deleted_charactersWhereInput
    orderBy?: Enumerable<znote_deleted_charactersOrderByWithAggregationInput>
    by: Znote_deleted_charactersScalarFieldEnum[]
    having?: znote_deleted_charactersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_deleted_charactersCountAggregateInputType | true
    _avg?: Znote_deleted_charactersAvgAggregateInputType
    _sum?: Znote_deleted_charactersSumAggregateInputType
    _min?: Znote_deleted_charactersMinAggregateInputType
    _max?: Znote_deleted_charactersMaxAggregateInputType
  }


  export type Znote_deleted_charactersGroupByOutputType = {
    id: number
    original_account_id: number
    character_name: string
    time: Date
    done: number
    _count: Znote_deleted_charactersCountAggregateOutputType | null
    _avg: Znote_deleted_charactersAvgAggregateOutputType | null
    _sum: Znote_deleted_charactersSumAggregateOutputType | null
    _min: Znote_deleted_charactersMinAggregateOutputType | null
    _max: Znote_deleted_charactersMaxAggregateOutputType | null
  }

  type GetZnote_deleted_charactersGroupByPayload<T extends Znote_deleted_charactersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_deleted_charactersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_deleted_charactersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_deleted_charactersGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_deleted_charactersGroupByOutputType[P]>
        }
      >
    >


  export type znote_deleted_charactersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    original_account_id?: boolean
    character_name?: boolean
    time?: boolean
    done?: boolean
  }, ExtArgs["result"]["znote_deleted_characters"]>

  export type znote_deleted_charactersSelectScalar = {
    id?: boolean
    original_account_id?: boolean
    character_name?: boolean
    time?: boolean
    done?: boolean
  }


  type znote_deleted_charactersGetPayload<S extends boolean | null | undefined | znote_deleted_charactersArgs> = $Types.GetResult<znote_deleted_charactersPayload, S>

  type znote_deleted_charactersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_deleted_charactersFindManyArgs, 'select' | 'include'> & {
      select?: Znote_deleted_charactersCountAggregateInputType | true
    }

  export interface znote_deleted_charactersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_deleted_characters'], meta: { name: 'znote_deleted_characters' } }
    /**
     * Find zero or one Znote_deleted_characters that matches the filter.
     * @param {znote_deleted_charactersFindUniqueArgs} args - Arguments to find a Znote_deleted_characters
     * @example
     * // Get one Znote_deleted_characters
     * const znote_deleted_characters = await prisma.znote_deleted_characters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_deleted_charactersFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_deleted_charactersFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_deleted_characters'> extends True ? Prisma__znote_deleted_charactersClient<$Types.GetResult<znote_deleted_charactersPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_deleted_charactersClient<$Types.GetResult<znote_deleted_charactersPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_deleted_characters that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_deleted_charactersFindUniqueOrThrowArgs} args - Arguments to find a Znote_deleted_characters
     * @example
     * // Get one Znote_deleted_characters
     * const znote_deleted_characters = await prisma.znote_deleted_characters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_deleted_charactersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_deleted_charactersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_deleted_charactersClient<$Types.GetResult<znote_deleted_charactersPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_deleted_characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_deleted_charactersFindFirstArgs} args - Arguments to find a Znote_deleted_characters
     * @example
     * // Get one Znote_deleted_characters
     * const znote_deleted_characters = await prisma.znote_deleted_characters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_deleted_charactersFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_deleted_charactersFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_deleted_characters'> extends True ? Prisma__znote_deleted_charactersClient<$Types.GetResult<znote_deleted_charactersPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_deleted_charactersClient<$Types.GetResult<znote_deleted_charactersPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_deleted_characters that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_deleted_charactersFindFirstOrThrowArgs} args - Arguments to find a Znote_deleted_characters
     * @example
     * // Get one Znote_deleted_characters
     * const znote_deleted_characters = await prisma.znote_deleted_characters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_deleted_charactersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_deleted_charactersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_deleted_charactersClient<$Types.GetResult<znote_deleted_charactersPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_deleted_characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_deleted_charactersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_deleted_characters
     * const znote_deleted_characters = await prisma.znote_deleted_characters.findMany()
     * 
     * // Get first 10 Znote_deleted_characters
     * const znote_deleted_characters = await prisma.znote_deleted_characters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_deleted_charactersWithIdOnly = await prisma.znote_deleted_characters.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_deleted_charactersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_deleted_charactersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_deleted_charactersPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_deleted_characters.
     * @param {znote_deleted_charactersCreateArgs} args - Arguments to create a Znote_deleted_characters.
     * @example
     * // Create one Znote_deleted_characters
     * const Znote_deleted_characters = await prisma.znote_deleted_characters.create({
     *   data: {
     *     // ... data to create a Znote_deleted_characters
     *   }
     * })
     * 
    **/
    create<T extends znote_deleted_charactersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_deleted_charactersCreateArgs<ExtArgs>>
    ): Prisma__znote_deleted_charactersClient<$Types.GetResult<znote_deleted_charactersPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_deleted_characters.
     *     @param {znote_deleted_charactersCreateManyArgs} args - Arguments to create many Znote_deleted_characters.
     *     @example
     *     // Create many Znote_deleted_characters
     *     const znote_deleted_characters = await prisma.znote_deleted_characters.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_deleted_charactersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_deleted_charactersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_deleted_characters.
     * @param {znote_deleted_charactersDeleteArgs} args - Arguments to delete one Znote_deleted_characters.
     * @example
     * // Delete one Znote_deleted_characters
     * const Znote_deleted_characters = await prisma.znote_deleted_characters.delete({
     *   where: {
     *     // ... filter to delete one Znote_deleted_characters
     *   }
     * })
     * 
    **/
    delete<T extends znote_deleted_charactersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_deleted_charactersDeleteArgs<ExtArgs>>
    ): Prisma__znote_deleted_charactersClient<$Types.GetResult<znote_deleted_charactersPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_deleted_characters.
     * @param {znote_deleted_charactersUpdateArgs} args - Arguments to update one Znote_deleted_characters.
     * @example
     * // Update one Znote_deleted_characters
     * const znote_deleted_characters = await prisma.znote_deleted_characters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_deleted_charactersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_deleted_charactersUpdateArgs<ExtArgs>>
    ): Prisma__znote_deleted_charactersClient<$Types.GetResult<znote_deleted_charactersPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_deleted_characters.
     * @param {znote_deleted_charactersDeleteManyArgs} args - Arguments to filter Znote_deleted_characters to delete.
     * @example
     * // Delete a few Znote_deleted_characters
     * const { count } = await prisma.znote_deleted_characters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_deleted_charactersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_deleted_charactersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_deleted_characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_deleted_charactersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_deleted_characters
     * const znote_deleted_characters = await prisma.znote_deleted_characters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_deleted_charactersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_deleted_charactersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_deleted_characters.
     * @param {znote_deleted_charactersUpsertArgs} args - Arguments to update or create a Znote_deleted_characters.
     * @example
     * // Update or create a Znote_deleted_characters
     * const znote_deleted_characters = await prisma.znote_deleted_characters.upsert({
     *   create: {
     *     // ... data to create a Znote_deleted_characters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_deleted_characters we want to update
     *   }
     * })
    **/
    upsert<T extends znote_deleted_charactersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_deleted_charactersUpsertArgs<ExtArgs>>
    ): Prisma__znote_deleted_charactersClient<$Types.GetResult<znote_deleted_charactersPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_deleted_characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_deleted_charactersCountArgs} args - Arguments to filter Znote_deleted_characters to count.
     * @example
     * // Count the number of Znote_deleted_characters
     * const count = await prisma.znote_deleted_characters.count({
     *   where: {
     *     // ... the filter for the Znote_deleted_characters we want to count
     *   }
     * })
    **/
    count<T extends znote_deleted_charactersCountArgs>(
      args?: Subset<T, znote_deleted_charactersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_deleted_charactersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_deleted_characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_deleted_charactersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_deleted_charactersAggregateArgs>(args: Subset<T, Znote_deleted_charactersAggregateArgs>): Prisma.PrismaPromise<GetZnote_deleted_charactersAggregateType<T>>

    /**
     * Group by Znote_deleted_characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_deleted_charactersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_deleted_charactersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_deleted_charactersGroupByArgs['orderBy'] }
        : { orderBy?: Znote_deleted_charactersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_deleted_charactersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_deleted_charactersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_deleted_characters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_deleted_charactersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_deleted_characters base type for findUnique actions
   */
  export type znote_deleted_charactersFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_deleted_characters
     */
    select?: znote_deleted_charactersSelect<ExtArgs> | null
    /**
     * Filter, which znote_deleted_characters to fetch.
     */
    where: znote_deleted_charactersWhereUniqueInput
  }

  /**
   * znote_deleted_characters findUnique
   */
  export interface znote_deleted_charactersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_deleted_charactersFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_deleted_characters findUniqueOrThrow
   */
  export type znote_deleted_charactersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_deleted_characters
     */
    select?: znote_deleted_charactersSelect<ExtArgs> | null
    /**
     * Filter, which znote_deleted_characters to fetch.
     */
    where: znote_deleted_charactersWhereUniqueInput
  }


  /**
   * znote_deleted_characters base type for findFirst actions
   */
  export type znote_deleted_charactersFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_deleted_characters
     */
    select?: znote_deleted_charactersSelect<ExtArgs> | null
    /**
     * Filter, which znote_deleted_characters to fetch.
     */
    where?: znote_deleted_charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_deleted_characters to fetch.
     */
    orderBy?: Enumerable<znote_deleted_charactersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_deleted_characters.
     */
    cursor?: znote_deleted_charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_deleted_characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_deleted_characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_deleted_characters.
     */
    distinct?: Enumerable<Znote_deleted_charactersScalarFieldEnum>
  }

  /**
   * znote_deleted_characters findFirst
   */
  export interface znote_deleted_charactersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_deleted_charactersFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_deleted_characters findFirstOrThrow
   */
  export type znote_deleted_charactersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_deleted_characters
     */
    select?: znote_deleted_charactersSelect<ExtArgs> | null
    /**
     * Filter, which znote_deleted_characters to fetch.
     */
    where?: znote_deleted_charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_deleted_characters to fetch.
     */
    orderBy?: Enumerable<znote_deleted_charactersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_deleted_characters.
     */
    cursor?: znote_deleted_charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_deleted_characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_deleted_characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_deleted_characters.
     */
    distinct?: Enumerable<Znote_deleted_charactersScalarFieldEnum>
  }


  /**
   * znote_deleted_characters findMany
   */
  export type znote_deleted_charactersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_deleted_characters
     */
    select?: znote_deleted_charactersSelect<ExtArgs> | null
    /**
     * Filter, which znote_deleted_characters to fetch.
     */
    where?: znote_deleted_charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_deleted_characters to fetch.
     */
    orderBy?: Enumerable<znote_deleted_charactersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_deleted_characters.
     */
    cursor?: znote_deleted_charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_deleted_characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_deleted_characters.
     */
    skip?: number
    distinct?: Enumerable<Znote_deleted_charactersScalarFieldEnum>
  }


  /**
   * znote_deleted_characters create
   */
  export type znote_deleted_charactersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_deleted_characters
     */
    select?: znote_deleted_charactersSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_deleted_characters.
     */
    data: XOR<znote_deleted_charactersCreateInput, znote_deleted_charactersUncheckedCreateInput>
  }


  /**
   * znote_deleted_characters createMany
   */
  export type znote_deleted_charactersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_deleted_characters.
     */
    data: Enumerable<znote_deleted_charactersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_deleted_characters update
   */
  export type znote_deleted_charactersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_deleted_characters
     */
    select?: znote_deleted_charactersSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_deleted_characters.
     */
    data: XOR<znote_deleted_charactersUpdateInput, znote_deleted_charactersUncheckedUpdateInput>
    /**
     * Choose, which znote_deleted_characters to update.
     */
    where: znote_deleted_charactersWhereUniqueInput
  }


  /**
   * znote_deleted_characters updateMany
   */
  export type znote_deleted_charactersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_deleted_characters.
     */
    data: XOR<znote_deleted_charactersUpdateManyMutationInput, znote_deleted_charactersUncheckedUpdateManyInput>
    /**
     * Filter which znote_deleted_characters to update
     */
    where?: znote_deleted_charactersWhereInput
  }


  /**
   * znote_deleted_characters upsert
   */
  export type znote_deleted_charactersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_deleted_characters
     */
    select?: znote_deleted_charactersSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_deleted_characters to update in case it exists.
     */
    where: znote_deleted_charactersWhereUniqueInput
    /**
     * In case the znote_deleted_characters found by the `where` argument doesn't exist, create a new znote_deleted_characters with this data.
     */
    create: XOR<znote_deleted_charactersCreateInput, znote_deleted_charactersUncheckedCreateInput>
    /**
     * In case the znote_deleted_characters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_deleted_charactersUpdateInput, znote_deleted_charactersUncheckedUpdateInput>
  }


  /**
   * znote_deleted_characters delete
   */
  export type znote_deleted_charactersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_deleted_characters
     */
    select?: znote_deleted_charactersSelect<ExtArgs> | null
    /**
     * Filter which znote_deleted_characters to delete.
     */
    where: znote_deleted_charactersWhereUniqueInput
  }


  /**
   * znote_deleted_characters deleteMany
   */
  export type znote_deleted_charactersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_deleted_characters to delete
     */
    where?: znote_deleted_charactersWhereInput
  }


  /**
   * znote_deleted_characters without action
   */
  export type znote_deleted_charactersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_deleted_characters
     */
    select?: znote_deleted_charactersSelect<ExtArgs> | null
  }



  /**
   * Model znote_forum
   */


  export type AggregateZnote_forum = {
    _count: Znote_forumCountAggregateOutputType | null
    _avg: Znote_forumAvgAggregateOutputType | null
    _sum: Znote_forumSumAggregateOutputType | null
    _min: Znote_forumMinAggregateOutputType | null
    _max: Znote_forumMaxAggregateOutputType | null
  }

  export type Znote_forumAvgAggregateOutputType = {
    id: number | null
    access: number | null
    closed: number | null
    hidden: number | null
    guild_id: number | null
  }

  export type Znote_forumSumAggregateOutputType = {
    id: number | null
    access: number | null
    closed: number | null
    hidden: number | null
    guild_id: number | null
  }

  export type Znote_forumMinAggregateOutputType = {
    id: number | null
    name: string | null
    access: number | null
    closed: number | null
    hidden: number | null
    guild_id: number | null
  }

  export type Znote_forumMaxAggregateOutputType = {
    id: number | null
    name: string | null
    access: number | null
    closed: number | null
    hidden: number | null
    guild_id: number | null
  }

  export type Znote_forumCountAggregateOutputType = {
    id: number
    name: number
    access: number
    closed: number
    hidden: number
    guild_id: number
    _all: number
  }


  export type Znote_forumAvgAggregateInputType = {
    id?: true
    access?: true
    closed?: true
    hidden?: true
    guild_id?: true
  }

  export type Znote_forumSumAggregateInputType = {
    id?: true
    access?: true
    closed?: true
    hidden?: true
    guild_id?: true
  }

  export type Znote_forumMinAggregateInputType = {
    id?: true
    name?: true
    access?: true
    closed?: true
    hidden?: true
    guild_id?: true
  }

  export type Znote_forumMaxAggregateInputType = {
    id?: true
    name?: true
    access?: true
    closed?: true
    hidden?: true
    guild_id?: true
  }

  export type Znote_forumCountAggregateInputType = {
    id?: true
    name?: true
    access?: true
    closed?: true
    hidden?: true
    guild_id?: true
    _all?: true
  }

  export type Znote_forumAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_forum to aggregate.
     */
    where?: znote_forumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_forums to fetch.
     */
    orderBy?: Enumerable<znote_forumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_forumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_forums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_forums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_forums
    **/
    _count?: true | Znote_forumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_forumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_forumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_forumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_forumMaxAggregateInputType
  }

  export type GetZnote_forumAggregateType<T extends Znote_forumAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_forum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_forum[P]>
      : GetScalarType<T[P], AggregateZnote_forum[P]>
  }




  export type Znote_forumGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_forumWhereInput
    orderBy?: Enumerable<znote_forumOrderByWithAggregationInput>
    by: Znote_forumScalarFieldEnum[]
    having?: znote_forumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_forumCountAggregateInputType | true
    _avg?: Znote_forumAvgAggregateInputType
    _sum?: Znote_forumSumAggregateInputType
    _min?: Znote_forumMinAggregateInputType
    _max?: Znote_forumMaxAggregateInputType
  }


  export type Znote_forumGroupByOutputType = {
    id: number
    name: string
    access: number
    closed: number
    hidden: number
    guild_id: number
    _count: Znote_forumCountAggregateOutputType | null
    _avg: Znote_forumAvgAggregateOutputType | null
    _sum: Znote_forumSumAggregateOutputType | null
    _min: Znote_forumMinAggregateOutputType | null
    _max: Znote_forumMaxAggregateOutputType | null
  }

  type GetZnote_forumGroupByPayload<T extends Znote_forumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_forumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_forumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_forumGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_forumGroupByOutputType[P]>
        }
      >
    >


  export type znote_forumSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    access?: boolean
    closed?: boolean
    hidden?: boolean
    guild_id?: boolean
  }, ExtArgs["result"]["znote_forum"]>

  export type znote_forumSelectScalar = {
    id?: boolean
    name?: boolean
    access?: boolean
    closed?: boolean
    hidden?: boolean
    guild_id?: boolean
  }


  type znote_forumGetPayload<S extends boolean | null | undefined | znote_forumArgs> = $Types.GetResult<znote_forumPayload, S>

  type znote_forumCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_forumFindManyArgs, 'select' | 'include'> & {
      select?: Znote_forumCountAggregateInputType | true
    }

  export interface znote_forumDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_forum'], meta: { name: 'znote_forum' } }
    /**
     * Find zero or one Znote_forum that matches the filter.
     * @param {znote_forumFindUniqueArgs} args - Arguments to find a Znote_forum
     * @example
     * // Get one Znote_forum
     * const znote_forum = await prisma.znote_forum.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_forumFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_forumFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_forum'> extends True ? Prisma__znote_forumClient<$Types.GetResult<znote_forumPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_forumClient<$Types.GetResult<znote_forumPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_forum that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_forumFindUniqueOrThrowArgs} args - Arguments to find a Znote_forum
     * @example
     * // Get one Znote_forum
     * const znote_forum = await prisma.znote_forum.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_forumFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forumFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_forumClient<$Types.GetResult<znote_forumPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_forum that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forumFindFirstArgs} args - Arguments to find a Znote_forum
     * @example
     * // Get one Znote_forum
     * const znote_forum = await prisma.znote_forum.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_forumFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_forumFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_forum'> extends True ? Prisma__znote_forumClient<$Types.GetResult<znote_forumPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_forumClient<$Types.GetResult<znote_forumPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_forum that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forumFindFirstOrThrowArgs} args - Arguments to find a Znote_forum
     * @example
     * // Get one Znote_forum
     * const znote_forum = await prisma.znote_forum.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_forumFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forumFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_forumClient<$Types.GetResult<znote_forumPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_forums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forumFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_forums
     * const znote_forums = await prisma.znote_forum.findMany()
     * 
     * // Get first 10 Znote_forums
     * const znote_forums = await prisma.znote_forum.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_forumWithIdOnly = await prisma.znote_forum.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_forumFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forumFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_forumPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_forum.
     * @param {znote_forumCreateArgs} args - Arguments to create a Znote_forum.
     * @example
     * // Create one Znote_forum
     * const Znote_forum = await prisma.znote_forum.create({
     *   data: {
     *     // ... data to create a Znote_forum
     *   }
     * })
     * 
    **/
    create<T extends znote_forumCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forumCreateArgs<ExtArgs>>
    ): Prisma__znote_forumClient<$Types.GetResult<znote_forumPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_forums.
     *     @param {znote_forumCreateManyArgs} args - Arguments to create many Znote_forums.
     *     @example
     *     // Create many Znote_forums
     *     const znote_forum = await prisma.znote_forum.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_forumCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forumCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_forum.
     * @param {znote_forumDeleteArgs} args - Arguments to delete one Znote_forum.
     * @example
     * // Delete one Znote_forum
     * const Znote_forum = await prisma.znote_forum.delete({
     *   where: {
     *     // ... filter to delete one Znote_forum
     *   }
     * })
     * 
    **/
    delete<T extends znote_forumDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forumDeleteArgs<ExtArgs>>
    ): Prisma__znote_forumClient<$Types.GetResult<znote_forumPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_forum.
     * @param {znote_forumUpdateArgs} args - Arguments to update one Znote_forum.
     * @example
     * // Update one Znote_forum
     * const znote_forum = await prisma.znote_forum.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_forumUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forumUpdateArgs<ExtArgs>>
    ): Prisma__znote_forumClient<$Types.GetResult<znote_forumPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_forums.
     * @param {znote_forumDeleteManyArgs} args - Arguments to filter Znote_forums to delete.
     * @example
     * // Delete a few Znote_forums
     * const { count } = await prisma.znote_forum.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_forumDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forumDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_forums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_forums
     * const znote_forum = await prisma.znote_forum.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_forumUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forumUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_forum.
     * @param {znote_forumUpsertArgs} args - Arguments to update or create a Znote_forum.
     * @example
     * // Update or create a Znote_forum
     * const znote_forum = await prisma.znote_forum.upsert({
     *   create: {
     *     // ... data to create a Znote_forum
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_forum we want to update
     *   }
     * })
    **/
    upsert<T extends znote_forumUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forumUpsertArgs<ExtArgs>>
    ): Prisma__znote_forumClient<$Types.GetResult<znote_forumPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_forums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forumCountArgs} args - Arguments to filter Znote_forums to count.
     * @example
     * // Count the number of Znote_forums
     * const count = await prisma.znote_forum.count({
     *   where: {
     *     // ... the filter for the Znote_forums we want to count
     *   }
     * })
    **/
    count<T extends znote_forumCountArgs>(
      args?: Subset<T, znote_forumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_forumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_forum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_forumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_forumAggregateArgs>(args: Subset<T, Znote_forumAggregateArgs>): Prisma.PrismaPromise<GetZnote_forumAggregateType<T>>

    /**
     * Group by Znote_forum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_forumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_forumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_forumGroupByArgs['orderBy'] }
        : { orderBy?: Znote_forumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_forumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_forumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_forum.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_forumClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_forum base type for findUnique actions
   */
  export type znote_forumFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum
     */
    select?: znote_forumSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum to fetch.
     */
    where: znote_forumWhereUniqueInput
  }

  /**
   * znote_forum findUnique
   */
  export interface znote_forumFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_forumFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_forum findUniqueOrThrow
   */
  export type znote_forumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum
     */
    select?: znote_forumSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum to fetch.
     */
    where: znote_forumWhereUniqueInput
  }


  /**
   * znote_forum base type for findFirst actions
   */
  export type znote_forumFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum
     */
    select?: znote_forumSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum to fetch.
     */
    where?: znote_forumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_forums to fetch.
     */
    orderBy?: Enumerable<znote_forumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_forums.
     */
    cursor?: znote_forumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_forums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_forums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_forums.
     */
    distinct?: Enumerable<Znote_forumScalarFieldEnum>
  }

  /**
   * znote_forum findFirst
   */
  export interface znote_forumFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_forumFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_forum findFirstOrThrow
   */
  export type znote_forumFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum
     */
    select?: znote_forumSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum to fetch.
     */
    where?: znote_forumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_forums to fetch.
     */
    orderBy?: Enumerable<znote_forumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_forums.
     */
    cursor?: znote_forumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_forums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_forums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_forums.
     */
    distinct?: Enumerable<Znote_forumScalarFieldEnum>
  }


  /**
   * znote_forum findMany
   */
  export type znote_forumFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum
     */
    select?: znote_forumSelect<ExtArgs> | null
    /**
     * Filter, which znote_forums to fetch.
     */
    where?: znote_forumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_forums to fetch.
     */
    orderBy?: Enumerable<znote_forumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_forums.
     */
    cursor?: znote_forumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_forums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_forums.
     */
    skip?: number
    distinct?: Enumerable<Znote_forumScalarFieldEnum>
  }


  /**
   * znote_forum create
   */
  export type znote_forumCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum
     */
    select?: znote_forumSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_forum.
     */
    data: XOR<znote_forumCreateInput, znote_forumUncheckedCreateInput>
  }


  /**
   * znote_forum createMany
   */
  export type znote_forumCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_forums.
     */
    data: Enumerable<znote_forumCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_forum update
   */
  export type znote_forumUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum
     */
    select?: znote_forumSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_forum.
     */
    data: XOR<znote_forumUpdateInput, znote_forumUncheckedUpdateInput>
    /**
     * Choose, which znote_forum to update.
     */
    where: znote_forumWhereUniqueInput
  }


  /**
   * znote_forum updateMany
   */
  export type znote_forumUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_forums.
     */
    data: XOR<znote_forumUpdateManyMutationInput, znote_forumUncheckedUpdateManyInput>
    /**
     * Filter which znote_forums to update
     */
    where?: znote_forumWhereInput
  }


  /**
   * znote_forum upsert
   */
  export type znote_forumUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum
     */
    select?: znote_forumSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_forum to update in case it exists.
     */
    where: znote_forumWhereUniqueInput
    /**
     * In case the znote_forum found by the `where` argument doesn't exist, create a new znote_forum with this data.
     */
    create: XOR<znote_forumCreateInput, znote_forumUncheckedCreateInput>
    /**
     * In case the znote_forum was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_forumUpdateInput, znote_forumUncheckedUpdateInput>
  }


  /**
   * znote_forum delete
   */
  export type znote_forumDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum
     */
    select?: znote_forumSelect<ExtArgs> | null
    /**
     * Filter which znote_forum to delete.
     */
    where: znote_forumWhereUniqueInput
  }


  /**
   * znote_forum deleteMany
   */
  export type znote_forumDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_forums to delete
     */
    where?: znote_forumWhereInput
  }


  /**
   * znote_forum without action
   */
  export type znote_forumArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum
     */
    select?: znote_forumSelect<ExtArgs> | null
  }



  /**
   * Model znote_forum_posts
   */


  export type AggregateZnote_forum_posts = {
    _count: Znote_forum_postsCountAggregateOutputType | null
    _avg: Znote_forum_postsAvgAggregateOutputType | null
    _sum: Znote_forum_postsSumAggregateOutputType | null
    _min: Znote_forum_postsMinAggregateOutputType | null
    _max: Znote_forum_postsMaxAggregateOutputType | null
  }

  export type Znote_forum_postsAvgAggregateOutputType = {
    id: number | null
    thread_id: number | null
    player_id: number | null
    created: number | null
    updated: number | null
  }

  export type Znote_forum_postsSumAggregateOutputType = {
    id: number | null
    thread_id: number | null
    player_id: number | null
    created: number | null
    updated: number | null
  }

  export type Znote_forum_postsMinAggregateOutputType = {
    id: number | null
    thread_id: number | null
    player_id: number | null
    player_name: string | null
    text: string | null
    created: number | null
    updated: number | null
  }

  export type Znote_forum_postsMaxAggregateOutputType = {
    id: number | null
    thread_id: number | null
    player_id: number | null
    player_name: string | null
    text: string | null
    created: number | null
    updated: number | null
  }

  export type Znote_forum_postsCountAggregateOutputType = {
    id: number
    thread_id: number
    player_id: number
    player_name: number
    text: number
    created: number
    updated: number
    _all: number
  }


  export type Znote_forum_postsAvgAggregateInputType = {
    id?: true
    thread_id?: true
    player_id?: true
    created?: true
    updated?: true
  }

  export type Znote_forum_postsSumAggregateInputType = {
    id?: true
    thread_id?: true
    player_id?: true
    created?: true
    updated?: true
  }

  export type Znote_forum_postsMinAggregateInputType = {
    id?: true
    thread_id?: true
    player_id?: true
    player_name?: true
    text?: true
    created?: true
    updated?: true
  }

  export type Znote_forum_postsMaxAggregateInputType = {
    id?: true
    thread_id?: true
    player_id?: true
    player_name?: true
    text?: true
    created?: true
    updated?: true
  }

  export type Znote_forum_postsCountAggregateInputType = {
    id?: true
    thread_id?: true
    player_id?: true
    player_name?: true
    text?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type Znote_forum_postsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_forum_posts to aggregate.
     */
    where?: znote_forum_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_forum_posts to fetch.
     */
    orderBy?: Enumerable<znote_forum_postsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_forum_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_forum_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_forum_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_forum_posts
    **/
    _count?: true | Znote_forum_postsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_forum_postsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_forum_postsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_forum_postsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_forum_postsMaxAggregateInputType
  }

  export type GetZnote_forum_postsAggregateType<T extends Znote_forum_postsAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_forum_posts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_forum_posts[P]>
      : GetScalarType<T[P], AggregateZnote_forum_posts[P]>
  }




  export type Znote_forum_postsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_forum_postsWhereInput
    orderBy?: Enumerable<znote_forum_postsOrderByWithAggregationInput>
    by: Znote_forum_postsScalarFieldEnum[]
    having?: znote_forum_postsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_forum_postsCountAggregateInputType | true
    _avg?: Znote_forum_postsAvgAggregateInputType
    _sum?: Znote_forum_postsSumAggregateInputType
    _min?: Znote_forum_postsMinAggregateInputType
    _max?: Znote_forum_postsMaxAggregateInputType
  }


  export type Znote_forum_postsGroupByOutputType = {
    id: number
    thread_id: number
    player_id: number
    player_name: string
    text: string
    created: number
    updated: number
    _count: Znote_forum_postsCountAggregateOutputType | null
    _avg: Znote_forum_postsAvgAggregateOutputType | null
    _sum: Znote_forum_postsSumAggregateOutputType | null
    _min: Znote_forum_postsMinAggregateOutputType | null
    _max: Znote_forum_postsMaxAggregateOutputType | null
  }

  type GetZnote_forum_postsGroupByPayload<T extends Znote_forum_postsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_forum_postsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_forum_postsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_forum_postsGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_forum_postsGroupByOutputType[P]>
        }
      >
    >


  export type znote_forum_postsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    thread_id?: boolean
    player_id?: boolean
    player_name?: boolean
    text?: boolean
    created?: boolean
    updated?: boolean
  }, ExtArgs["result"]["znote_forum_posts"]>

  export type znote_forum_postsSelectScalar = {
    id?: boolean
    thread_id?: boolean
    player_id?: boolean
    player_name?: boolean
    text?: boolean
    created?: boolean
    updated?: boolean
  }


  type znote_forum_postsGetPayload<S extends boolean | null | undefined | znote_forum_postsArgs> = $Types.GetResult<znote_forum_postsPayload, S>

  type znote_forum_postsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_forum_postsFindManyArgs, 'select' | 'include'> & {
      select?: Znote_forum_postsCountAggregateInputType | true
    }

  export interface znote_forum_postsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_forum_posts'], meta: { name: 'znote_forum_posts' } }
    /**
     * Find zero or one Znote_forum_posts that matches the filter.
     * @param {znote_forum_postsFindUniqueArgs} args - Arguments to find a Znote_forum_posts
     * @example
     * // Get one Znote_forum_posts
     * const znote_forum_posts = await prisma.znote_forum_posts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_forum_postsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_forum_postsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_forum_posts'> extends True ? Prisma__znote_forum_postsClient<$Types.GetResult<znote_forum_postsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_forum_postsClient<$Types.GetResult<znote_forum_postsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_forum_posts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_forum_postsFindUniqueOrThrowArgs} args - Arguments to find a Znote_forum_posts
     * @example
     * // Get one Znote_forum_posts
     * const znote_forum_posts = await prisma.znote_forum_posts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_forum_postsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forum_postsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_forum_postsClient<$Types.GetResult<znote_forum_postsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_forum_posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forum_postsFindFirstArgs} args - Arguments to find a Znote_forum_posts
     * @example
     * // Get one Znote_forum_posts
     * const znote_forum_posts = await prisma.znote_forum_posts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_forum_postsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_forum_postsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_forum_posts'> extends True ? Prisma__znote_forum_postsClient<$Types.GetResult<znote_forum_postsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_forum_postsClient<$Types.GetResult<znote_forum_postsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_forum_posts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forum_postsFindFirstOrThrowArgs} args - Arguments to find a Znote_forum_posts
     * @example
     * // Get one Znote_forum_posts
     * const znote_forum_posts = await prisma.znote_forum_posts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_forum_postsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forum_postsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_forum_postsClient<$Types.GetResult<znote_forum_postsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_forum_posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forum_postsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_forum_posts
     * const znote_forum_posts = await prisma.znote_forum_posts.findMany()
     * 
     * // Get first 10 Znote_forum_posts
     * const znote_forum_posts = await prisma.znote_forum_posts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_forum_postsWithIdOnly = await prisma.znote_forum_posts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_forum_postsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forum_postsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_forum_postsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_forum_posts.
     * @param {znote_forum_postsCreateArgs} args - Arguments to create a Znote_forum_posts.
     * @example
     * // Create one Znote_forum_posts
     * const Znote_forum_posts = await prisma.znote_forum_posts.create({
     *   data: {
     *     // ... data to create a Znote_forum_posts
     *   }
     * })
     * 
    **/
    create<T extends znote_forum_postsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forum_postsCreateArgs<ExtArgs>>
    ): Prisma__znote_forum_postsClient<$Types.GetResult<znote_forum_postsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_forum_posts.
     *     @param {znote_forum_postsCreateManyArgs} args - Arguments to create many Znote_forum_posts.
     *     @example
     *     // Create many Znote_forum_posts
     *     const znote_forum_posts = await prisma.znote_forum_posts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_forum_postsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forum_postsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_forum_posts.
     * @param {znote_forum_postsDeleteArgs} args - Arguments to delete one Znote_forum_posts.
     * @example
     * // Delete one Znote_forum_posts
     * const Znote_forum_posts = await prisma.znote_forum_posts.delete({
     *   where: {
     *     // ... filter to delete one Znote_forum_posts
     *   }
     * })
     * 
    **/
    delete<T extends znote_forum_postsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forum_postsDeleteArgs<ExtArgs>>
    ): Prisma__znote_forum_postsClient<$Types.GetResult<znote_forum_postsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_forum_posts.
     * @param {znote_forum_postsUpdateArgs} args - Arguments to update one Znote_forum_posts.
     * @example
     * // Update one Znote_forum_posts
     * const znote_forum_posts = await prisma.znote_forum_posts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_forum_postsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forum_postsUpdateArgs<ExtArgs>>
    ): Prisma__znote_forum_postsClient<$Types.GetResult<znote_forum_postsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_forum_posts.
     * @param {znote_forum_postsDeleteManyArgs} args - Arguments to filter Znote_forum_posts to delete.
     * @example
     * // Delete a few Znote_forum_posts
     * const { count } = await prisma.znote_forum_posts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_forum_postsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forum_postsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_forum_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forum_postsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_forum_posts
     * const znote_forum_posts = await prisma.znote_forum_posts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_forum_postsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forum_postsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_forum_posts.
     * @param {znote_forum_postsUpsertArgs} args - Arguments to update or create a Znote_forum_posts.
     * @example
     * // Update or create a Znote_forum_posts
     * const znote_forum_posts = await prisma.znote_forum_posts.upsert({
     *   create: {
     *     // ... data to create a Znote_forum_posts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_forum_posts we want to update
     *   }
     * })
    **/
    upsert<T extends znote_forum_postsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forum_postsUpsertArgs<ExtArgs>>
    ): Prisma__znote_forum_postsClient<$Types.GetResult<znote_forum_postsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_forum_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forum_postsCountArgs} args - Arguments to filter Znote_forum_posts to count.
     * @example
     * // Count the number of Znote_forum_posts
     * const count = await prisma.znote_forum_posts.count({
     *   where: {
     *     // ... the filter for the Znote_forum_posts we want to count
     *   }
     * })
    **/
    count<T extends znote_forum_postsCountArgs>(
      args?: Subset<T, znote_forum_postsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_forum_postsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_forum_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_forum_postsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_forum_postsAggregateArgs>(args: Subset<T, Znote_forum_postsAggregateArgs>): Prisma.PrismaPromise<GetZnote_forum_postsAggregateType<T>>

    /**
     * Group by Znote_forum_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_forum_postsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_forum_postsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_forum_postsGroupByArgs['orderBy'] }
        : { orderBy?: Znote_forum_postsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_forum_postsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_forum_postsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_forum_posts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_forum_postsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_forum_posts base type for findUnique actions
   */
  export type znote_forum_postsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_posts
     */
    select?: znote_forum_postsSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum_posts to fetch.
     */
    where: znote_forum_postsWhereUniqueInput
  }

  /**
   * znote_forum_posts findUnique
   */
  export interface znote_forum_postsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_forum_postsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_forum_posts findUniqueOrThrow
   */
  export type znote_forum_postsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_posts
     */
    select?: znote_forum_postsSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum_posts to fetch.
     */
    where: znote_forum_postsWhereUniqueInput
  }


  /**
   * znote_forum_posts base type for findFirst actions
   */
  export type znote_forum_postsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_posts
     */
    select?: znote_forum_postsSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum_posts to fetch.
     */
    where?: znote_forum_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_forum_posts to fetch.
     */
    orderBy?: Enumerable<znote_forum_postsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_forum_posts.
     */
    cursor?: znote_forum_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_forum_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_forum_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_forum_posts.
     */
    distinct?: Enumerable<Znote_forum_postsScalarFieldEnum>
  }

  /**
   * znote_forum_posts findFirst
   */
  export interface znote_forum_postsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_forum_postsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_forum_posts findFirstOrThrow
   */
  export type znote_forum_postsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_posts
     */
    select?: znote_forum_postsSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum_posts to fetch.
     */
    where?: znote_forum_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_forum_posts to fetch.
     */
    orderBy?: Enumerable<znote_forum_postsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_forum_posts.
     */
    cursor?: znote_forum_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_forum_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_forum_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_forum_posts.
     */
    distinct?: Enumerable<Znote_forum_postsScalarFieldEnum>
  }


  /**
   * znote_forum_posts findMany
   */
  export type znote_forum_postsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_posts
     */
    select?: znote_forum_postsSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum_posts to fetch.
     */
    where?: znote_forum_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_forum_posts to fetch.
     */
    orderBy?: Enumerable<znote_forum_postsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_forum_posts.
     */
    cursor?: znote_forum_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_forum_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_forum_posts.
     */
    skip?: number
    distinct?: Enumerable<Znote_forum_postsScalarFieldEnum>
  }


  /**
   * znote_forum_posts create
   */
  export type znote_forum_postsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_posts
     */
    select?: znote_forum_postsSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_forum_posts.
     */
    data: XOR<znote_forum_postsCreateInput, znote_forum_postsUncheckedCreateInput>
  }


  /**
   * znote_forum_posts createMany
   */
  export type znote_forum_postsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_forum_posts.
     */
    data: Enumerable<znote_forum_postsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_forum_posts update
   */
  export type znote_forum_postsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_posts
     */
    select?: znote_forum_postsSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_forum_posts.
     */
    data: XOR<znote_forum_postsUpdateInput, znote_forum_postsUncheckedUpdateInput>
    /**
     * Choose, which znote_forum_posts to update.
     */
    where: znote_forum_postsWhereUniqueInput
  }


  /**
   * znote_forum_posts updateMany
   */
  export type znote_forum_postsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_forum_posts.
     */
    data: XOR<znote_forum_postsUpdateManyMutationInput, znote_forum_postsUncheckedUpdateManyInput>
    /**
     * Filter which znote_forum_posts to update
     */
    where?: znote_forum_postsWhereInput
  }


  /**
   * znote_forum_posts upsert
   */
  export type znote_forum_postsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_posts
     */
    select?: znote_forum_postsSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_forum_posts to update in case it exists.
     */
    where: znote_forum_postsWhereUniqueInput
    /**
     * In case the znote_forum_posts found by the `where` argument doesn't exist, create a new znote_forum_posts with this data.
     */
    create: XOR<znote_forum_postsCreateInput, znote_forum_postsUncheckedCreateInput>
    /**
     * In case the znote_forum_posts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_forum_postsUpdateInput, znote_forum_postsUncheckedUpdateInput>
  }


  /**
   * znote_forum_posts delete
   */
  export type znote_forum_postsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_posts
     */
    select?: znote_forum_postsSelect<ExtArgs> | null
    /**
     * Filter which znote_forum_posts to delete.
     */
    where: znote_forum_postsWhereUniqueInput
  }


  /**
   * znote_forum_posts deleteMany
   */
  export type znote_forum_postsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_forum_posts to delete
     */
    where?: znote_forum_postsWhereInput
  }


  /**
   * znote_forum_posts without action
   */
  export type znote_forum_postsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_posts
     */
    select?: znote_forum_postsSelect<ExtArgs> | null
  }



  /**
   * Model znote_forum_threads
   */


  export type AggregateZnote_forum_threads = {
    _count: Znote_forum_threadsCountAggregateOutputType | null
    _avg: Znote_forum_threadsAvgAggregateOutputType | null
    _sum: Znote_forum_threadsSumAggregateOutputType | null
    _min: Znote_forum_threadsMinAggregateOutputType | null
    _max: Znote_forum_threadsMaxAggregateOutputType | null
  }

  export type Znote_forum_threadsAvgAggregateOutputType = {
    id: number | null
    forum_id: number | null
    player_id: number | null
    created: number | null
    updated: number | null
    sticky: number | null
    hidden: number | null
    closed: number | null
  }

  export type Znote_forum_threadsSumAggregateOutputType = {
    id: number | null
    forum_id: number | null
    player_id: number | null
    created: number | null
    updated: number | null
    sticky: number | null
    hidden: number | null
    closed: number | null
  }

  export type Znote_forum_threadsMinAggregateOutputType = {
    id: number | null
    forum_id: number | null
    player_id: number | null
    player_name: string | null
    title: string | null
    text: string | null
    created: number | null
    updated: number | null
    sticky: number | null
    hidden: number | null
    closed: number | null
  }

  export type Znote_forum_threadsMaxAggregateOutputType = {
    id: number | null
    forum_id: number | null
    player_id: number | null
    player_name: string | null
    title: string | null
    text: string | null
    created: number | null
    updated: number | null
    sticky: number | null
    hidden: number | null
    closed: number | null
  }

  export type Znote_forum_threadsCountAggregateOutputType = {
    id: number
    forum_id: number
    player_id: number
    player_name: number
    title: number
    text: number
    created: number
    updated: number
    sticky: number
    hidden: number
    closed: number
    _all: number
  }


  export type Znote_forum_threadsAvgAggregateInputType = {
    id?: true
    forum_id?: true
    player_id?: true
    created?: true
    updated?: true
    sticky?: true
    hidden?: true
    closed?: true
  }

  export type Znote_forum_threadsSumAggregateInputType = {
    id?: true
    forum_id?: true
    player_id?: true
    created?: true
    updated?: true
    sticky?: true
    hidden?: true
    closed?: true
  }

  export type Znote_forum_threadsMinAggregateInputType = {
    id?: true
    forum_id?: true
    player_id?: true
    player_name?: true
    title?: true
    text?: true
    created?: true
    updated?: true
    sticky?: true
    hidden?: true
    closed?: true
  }

  export type Znote_forum_threadsMaxAggregateInputType = {
    id?: true
    forum_id?: true
    player_id?: true
    player_name?: true
    title?: true
    text?: true
    created?: true
    updated?: true
    sticky?: true
    hidden?: true
    closed?: true
  }

  export type Znote_forum_threadsCountAggregateInputType = {
    id?: true
    forum_id?: true
    player_id?: true
    player_name?: true
    title?: true
    text?: true
    created?: true
    updated?: true
    sticky?: true
    hidden?: true
    closed?: true
    _all?: true
  }

  export type Znote_forum_threadsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_forum_threads to aggregate.
     */
    where?: znote_forum_threadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_forum_threads to fetch.
     */
    orderBy?: Enumerable<znote_forum_threadsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_forum_threadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_forum_threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_forum_threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_forum_threads
    **/
    _count?: true | Znote_forum_threadsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_forum_threadsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_forum_threadsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_forum_threadsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_forum_threadsMaxAggregateInputType
  }

  export type GetZnote_forum_threadsAggregateType<T extends Znote_forum_threadsAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_forum_threads]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_forum_threads[P]>
      : GetScalarType<T[P], AggregateZnote_forum_threads[P]>
  }




  export type Znote_forum_threadsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_forum_threadsWhereInput
    orderBy?: Enumerable<znote_forum_threadsOrderByWithAggregationInput>
    by: Znote_forum_threadsScalarFieldEnum[]
    having?: znote_forum_threadsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_forum_threadsCountAggregateInputType | true
    _avg?: Znote_forum_threadsAvgAggregateInputType
    _sum?: Znote_forum_threadsSumAggregateInputType
    _min?: Znote_forum_threadsMinAggregateInputType
    _max?: Znote_forum_threadsMaxAggregateInputType
  }


  export type Znote_forum_threadsGroupByOutputType = {
    id: number
    forum_id: number
    player_id: number
    player_name: string
    title: string
    text: string
    created: number
    updated: number
    sticky: number
    hidden: number
    closed: number
    _count: Znote_forum_threadsCountAggregateOutputType | null
    _avg: Znote_forum_threadsAvgAggregateOutputType | null
    _sum: Znote_forum_threadsSumAggregateOutputType | null
    _min: Znote_forum_threadsMinAggregateOutputType | null
    _max: Znote_forum_threadsMaxAggregateOutputType | null
  }

  type GetZnote_forum_threadsGroupByPayload<T extends Znote_forum_threadsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_forum_threadsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_forum_threadsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_forum_threadsGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_forum_threadsGroupByOutputType[P]>
        }
      >
    >


  export type znote_forum_threadsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    forum_id?: boolean
    player_id?: boolean
    player_name?: boolean
    title?: boolean
    text?: boolean
    created?: boolean
    updated?: boolean
    sticky?: boolean
    hidden?: boolean
    closed?: boolean
  }, ExtArgs["result"]["znote_forum_threads"]>

  export type znote_forum_threadsSelectScalar = {
    id?: boolean
    forum_id?: boolean
    player_id?: boolean
    player_name?: boolean
    title?: boolean
    text?: boolean
    created?: boolean
    updated?: boolean
    sticky?: boolean
    hidden?: boolean
    closed?: boolean
  }


  type znote_forum_threadsGetPayload<S extends boolean | null | undefined | znote_forum_threadsArgs> = $Types.GetResult<znote_forum_threadsPayload, S>

  type znote_forum_threadsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_forum_threadsFindManyArgs, 'select' | 'include'> & {
      select?: Znote_forum_threadsCountAggregateInputType | true
    }

  export interface znote_forum_threadsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_forum_threads'], meta: { name: 'znote_forum_threads' } }
    /**
     * Find zero or one Znote_forum_threads that matches the filter.
     * @param {znote_forum_threadsFindUniqueArgs} args - Arguments to find a Znote_forum_threads
     * @example
     * // Get one Znote_forum_threads
     * const znote_forum_threads = await prisma.znote_forum_threads.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_forum_threadsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_forum_threadsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_forum_threads'> extends True ? Prisma__znote_forum_threadsClient<$Types.GetResult<znote_forum_threadsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_forum_threadsClient<$Types.GetResult<znote_forum_threadsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_forum_threads that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_forum_threadsFindUniqueOrThrowArgs} args - Arguments to find a Znote_forum_threads
     * @example
     * // Get one Znote_forum_threads
     * const znote_forum_threads = await prisma.znote_forum_threads.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_forum_threadsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forum_threadsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_forum_threadsClient<$Types.GetResult<znote_forum_threadsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_forum_threads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forum_threadsFindFirstArgs} args - Arguments to find a Znote_forum_threads
     * @example
     * // Get one Znote_forum_threads
     * const znote_forum_threads = await prisma.znote_forum_threads.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_forum_threadsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_forum_threadsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_forum_threads'> extends True ? Prisma__znote_forum_threadsClient<$Types.GetResult<znote_forum_threadsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_forum_threadsClient<$Types.GetResult<znote_forum_threadsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_forum_threads that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forum_threadsFindFirstOrThrowArgs} args - Arguments to find a Znote_forum_threads
     * @example
     * // Get one Znote_forum_threads
     * const znote_forum_threads = await prisma.znote_forum_threads.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_forum_threadsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forum_threadsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_forum_threadsClient<$Types.GetResult<znote_forum_threadsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_forum_threads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forum_threadsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_forum_threads
     * const znote_forum_threads = await prisma.znote_forum_threads.findMany()
     * 
     * // Get first 10 Znote_forum_threads
     * const znote_forum_threads = await prisma.znote_forum_threads.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_forum_threadsWithIdOnly = await prisma.znote_forum_threads.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_forum_threadsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forum_threadsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_forum_threadsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_forum_threads.
     * @param {znote_forum_threadsCreateArgs} args - Arguments to create a Znote_forum_threads.
     * @example
     * // Create one Znote_forum_threads
     * const Znote_forum_threads = await prisma.znote_forum_threads.create({
     *   data: {
     *     // ... data to create a Znote_forum_threads
     *   }
     * })
     * 
    **/
    create<T extends znote_forum_threadsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forum_threadsCreateArgs<ExtArgs>>
    ): Prisma__znote_forum_threadsClient<$Types.GetResult<znote_forum_threadsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_forum_threads.
     *     @param {znote_forum_threadsCreateManyArgs} args - Arguments to create many Znote_forum_threads.
     *     @example
     *     // Create many Znote_forum_threads
     *     const znote_forum_threads = await prisma.znote_forum_threads.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_forum_threadsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forum_threadsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_forum_threads.
     * @param {znote_forum_threadsDeleteArgs} args - Arguments to delete one Znote_forum_threads.
     * @example
     * // Delete one Znote_forum_threads
     * const Znote_forum_threads = await prisma.znote_forum_threads.delete({
     *   where: {
     *     // ... filter to delete one Znote_forum_threads
     *   }
     * })
     * 
    **/
    delete<T extends znote_forum_threadsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forum_threadsDeleteArgs<ExtArgs>>
    ): Prisma__znote_forum_threadsClient<$Types.GetResult<znote_forum_threadsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_forum_threads.
     * @param {znote_forum_threadsUpdateArgs} args - Arguments to update one Znote_forum_threads.
     * @example
     * // Update one Znote_forum_threads
     * const znote_forum_threads = await prisma.znote_forum_threads.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_forum_threadsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forum_threadsUpdateArgs<ExtArgs>>
    ): Prisma__znote_forum_threadsClient<$Types.GetResult<znote_forum_threadsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_forum_threads.
     * @param {znote_forum_threadsDeleteManyArgs} args - Arguments to filter Znote_forum_threads to delete.
     * @example
     * // Delete a few Znote_forum_threads
     * const { count } = await prisma.znote_forum_threads.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_forum_threadsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_forum_threadsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_forum_threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forum_threadsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_forum_threads
     * const znote_forum_threads = await prisma.znote_forum_threads.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_forum_threadsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forum_threadsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_forum_threads.
     * @param {znote_forum_threadsUpsertArgs} args - Arguments to update or create a Znote_forum_threads.
     * @example
     * // Update or create a Znote_forum_threads
     * const znote_forum_threads = await prisma.znote_forum_threads.upsert({
     *   create: {
     *     // ... data to create a Znote_forum_threads
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_forum_threads we want to update
     *   }
     * })
    **/
    upsert<T extends znote_forum_threadsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_forum_threadsUpsertArgs<ExtArgs>>
    ): Prisma__znote_forum_threadsClient<$Types.GetResult<znote_forum_threadsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_forum_threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_forum_threadsCountArgs} args - Arguments to filter Znote_forum_threads to count.
     * @example
     * // Count the number of Znote_forum_threads
     * const count = await prisma.znote_forum_threads.count({
     *   where: {
     *     // ... the filter for the Znote_forum_threads we want to count
     *   }
     * })
    **/
    count<T extends znote_forum_threadsCountArgs>(
      args?: Subset<T, znote_forum_threadsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_forum_threadsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_forum_threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_forum_threadsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_forum_threadsAggregateArgs>(args: Subset<T, Znote_forum_threadsAggregateArgs>): Prisma.PrismaPromise<GetZnote_forum_threadsAggregateType<T>>

    /**
     * Group by Znote_forum_threads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_forum_threadsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_forum_threadsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_forum_threadsGroupByArgs['orderBy'] }
        : { orderBy?: Znote_forum_threadsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_forum_threadsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_forum_threadsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_forum_threads.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_forum_threadsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_forum_threads base type for findUnique actions
   */
  export type znote_forum_threadsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_threads
     */
    select?: znote_forum_threadsSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum_threads to fetch.
     */
    where: znote_forum_threadsWhereUniqueInput
  }

  /**
   * znote_forum_threads findUnique
   */
  export interface znote_forum_threadsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_forum_threadsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_forum_threads findUniqueOrThrow
   */
  export type znote_forum_threadsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_threads
     */
    select?: znote_forum_threadsSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum_threads to fetch.
     */
    where: znote_forum_threadsWhereUniqueInput
  }


  /**
   * znote_forum_threads base type for findFirst actions
   */
  export type znote_forum_threadsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_threads
     */
    select?: znote_forum_threadsSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum_threads to fetch.
     */
    where?: znote_forum_threadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_forum_threads to fetch.
     */
    orderBy?: Enumerable<znote_forum_threadsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_forum_threads.
     */
    cursor?: znote_forum_threadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_forum_threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_forum_threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_forum_threads.
     */
    distinct?: Enumerable<Znote_forum_threadsScalarFieldEnum>
  }

  /**
   * znote_forum_threads findFirst
   */
  export interface znote_forum_threadsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_forum_threadsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_forum_threads findFirstOrThrow
   */
  export type znote_forum_threadsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_threads
     */
    select?: znote_forum_threadsSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum_threads to fetch.
     */
    where?: znote_forum_threadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_forum_threads to fetch.
     */
    orderBy?: Enumerable<znote_forum_threadsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_forum_threads.
     */
    cursor?: znote_forum_threadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_forum_threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_forum_threads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_forum_threads.
     */
    distinct?: Enumerable<Znote_forum_threadsScalarFieldEnum>
  }


  /**
   * znote_forum_threads findMany
   */
  export type znote_forum_threadsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_threads
     */
    select?: znote_forum_threadsSelect<ExtArgs> | null
    /**
     * Filter, which znote_forum_threads to fetch.
     */
    where?: znote_forum_threadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_forum_threads to fetch.
     */
    orderBy?: Enumerable<znote_forum_threadsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_forum_threads.
     */
    cursor?: znote_forum_threadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_forum_threads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_forum_threads.
     */
    skip?: number
    distinct?: Enumerable<Znote_forum_threadsScalarFieldEnum>
  }


  /**
   * znote_forum_threads create
   */
  export type znote_forum_threadsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_threads
     */
    select?: znote_forum_threadsSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_forum_threads.
     */
    data: XOR<znote_forum_threadsCreateInput, znote_forum_threadsUncheckedCreateInput>
  }


  /**
   * znote_forum_threads createMany
   */
  export type znote_forum_threadsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_forum_threads.
     */
    data: Enumerable<znote_forum_threadsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_forum_threads update
   */
  export type znote_forum_threadsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_threads
     */
    select?: znote_forum_threadsSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_forum_threads.
     */
    data: XOR<znote_forum_threadsUpdateInput, znote_forum_threadsUncheckedUpdateInput>
    /**
     * Choose, which znote_forum_threads to update.
     */
    where: znote_forum_threadsWhereUniqueInput
  }


  /**
   * znote_forum_threads updateMany
   */
  export type znote_forum_threadsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_forum_threads.
     */
    data: XOR<znote_forum_threadsUpdateManyMutationInput, znote_forum_threadsUncheckedUpdateManyInput>
    /**
     * Filter which znote_forum_threads to update
     */
    where?: znote_forum_threadsWhereInput
  }


  /**
   * znote_forum_threads upsert
   */
  export type znote_forum_threadsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_threads
     */
    select?: znote_forum_threadsSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_forum_threads to update in case it exists.
     */
    where: znote_forum_threadsWhereUniqueInput
    /**
     * In case the znote_forum_threads found by the `where` argument doesn't exist, create a new znote_forum_threads with this data.
     */
    create: XOR<znote_forum_threadsCreateInput, znote_forum_threadsUncheckedCreateInput>
    /**
     * In case the znote_forum_threads was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_forum_threadsUpdateInput, znote_forum_threadsUncheckedUpdateInput>
  }


  /**
   * znote_forum_threads delete
   */
  export type znote_forum_threadsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_threads
     */
    select?: znote_forum_threadsSelect<ExtArgs> | null
    /**
     * Filter which znote_forum_threads to delete.
     */
    where: znote_forum_threadsWhereUniqueInput
  }


  /**
   * znote_forum_threads deleteMany
   */
  export type znote_forum_threadsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_forum_threads to delete
     */
    where?: znote_forum_threadsWhereInput
  }


  /**
   * znote_forum_threads without action
   */
  export type znote_forum_threadsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_forum_threads
     */
    select?: znote_forum_threadsSelect<ExtArgs> | null
  }



  /**
   * Model znote_global_storage
   */


  export type AggregateZnote_global_storage = {
    _count: Znote_global_storageCountAggregateOutputType | null
    _min: Znote_global_storageMinAggregateOutputType | null
    _max: Znote_global_storageMaxAggregateOutputType | null
  }

  export type Znote_global_storageMinAggregateOutputType = {
    key: string | null
    value: string | null
  }

  export type Znote_global_storageMaxAggregateOutputType = {
    key: string | null
    value: string | null
  }

  export type Znote_global_storageCountAggregateOutputType = {
    key: number
    value: number
    _all: number
  }


  export type Znote_global_storageMinAggregateInputType = {
    key?: true
    value?: true
  }

  export type Znote_global_storageMaxAggregateInputType = {
    key?: true
    value?: true
  }

  export type Znote_global_storageCountAggregateInputType = {
    key?: true
    value?: true
    _all?: true
  }

  export type Znote_global_storageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_global_storage to aggregate.
     */
    where?: znote_global_storageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_global_storages to fetch.
     */
    orderBy?: Enumerable<znote_global_storageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_global_storageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_global_storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_global_storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_global_storages
    **/
    _count?: true | Znote_global_storageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_global_storageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_global_storageMaxAggregateInputType
  }

  export type GetZnote_global_storageAggregateType<T extends Znote_global_storageAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_global_storage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_global_storage[P]>
      : GetScalarType<T[P], AggregateZnote_global_storage[P]>
  }




  export type Znote_global_storageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_global_storageWhereInput
    orderBy?: Enumerable<znote_global_storageOrderByWithAggregationInput>
    by: Znote_global_storageScalarFieldEnum[]
    having?: znote_global_storageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_global_storageCountAggregateInputType | true
    _min?: Znote_global_storageMinAggregateInputType
    _max?: Znote_global_storageMaxAggregateInputType
  }


  export type Znote_global_storageGroupByOutputType = {
    key: string
    value: string
    _count: Znote_global_storageCountAggregateOutputType | null
    _min: Znote_global_storageMinAggregateOutputType | null
    _max: Znote_global_storageMaxAggregateOutputType | null
  }

  type GetZnote_global_storageGroupByPayload<T extends Znote_global_storageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_global_storageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_global_storageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_global_storageGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_global_storageGroupByOutputType[P]>
        }
      >
    >


  export type znote_global_storageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["znote_global_storage"]>

  export type znote_global_storageSelectScalar = {
    key?: boolean
    value?: boolean
  }


  type znote_global_storageGetPayload<S extends boolean | null | undefined | znote_global_storageArgs> = $Types.GetResult<znote_global_storagePayload, S>

  type znote_global_storageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_global_storageFindManyArgs, 'select' | 'include'> & {
      select?: Znote_global_storageCountAggregateInputType | true
    }

  export interface znote_global_storageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_global_storage'], meta: { name: 'znote_global_storage' } }
    /**
     * Find zero or one Znote_global_storage that matches the filter.
     * @param {znote_global_storageFindUniqueArgs} args - Arguments to find a Znote_global_storage
     * @example
     * // Get one Znote_global_storage
     * const znote_global_storage = await prisma.znote_global_storage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_global_storageFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_global_storageFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_global_storage'> extends True ? Prisma__znote_global_storageClient<$Types.GetResult<znote_global_storagePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_global_storageClient<$Types.GetResult<znote_global_storagePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_global_storage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_global_storageFindUniqueOrThrowArgs} args - Arguments to find a Znote_global_storage
     * @example
     * // Get one Znote_global_storage
     * const znote_global_storage = await prisma.znote_global_storage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_global_storageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_global_storageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_global_storageClient<$Types.GetResult<znote_global_storagePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_global_storage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_global_storageFindFirstArgs} args - Arguments to find a Znote_global_storage
     * @example
     * // Get one Znote_global_storage
     * const znote_global_storage = await prisma.znote_global_storage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_global_storageFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_global_storageFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_global_storage'> extends True ? Prisma__znote_global_storageClient<$Types.GetResult<znote_global_storagePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_global_storageClient<$Types.GetResult<znote_global_storagePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_global_storage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_global_storageFindFirstOrThrowArgs} args - Arguments to find a Znote_global_storage
     * @example
     * // Get one Znote_global_storage
     * const znote_global_storage = await prisma.znote_global_storage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_global_storageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_global_storageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_global_storageClient<$Types.GetResult<znote_global_storagePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_global_storages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_global_storageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_global_storages
     * const znote_global_storages = await prisma.znote_global_storage.findMany()
     * 
     * // Get first 10 Znote_global_storages
     * const znote_global_storages = await prisma.znote_global_storage.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const znote_global_storageWithKeyOnly = await prisma.znote_global_storage.findMany({ select: { key: true } })
     * 
    **/
    findMany<T extends znote_global_storageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_global_storageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_global_storagePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_global_storage.
     * @param {znote_global_storageCreateArgs} args - Arguments to create a Znote_global_storage.
     * @example
     * // Create one Znote_global_storage
     * const Znote_global_storage = await prisma.znote_global_storage.create({
     *   data: {
     *     // ... data to create a Znote_global_storage
     *   }
     * })
     * 
    **/
    create<T extends znote_global_storageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_global_storageCreateArgs<ExtArgs>>
    ): Prisma__znote_global_storageClient<$Types.GetResult<znote_global_storagePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_global_storages.
     *     @param {znote_global_storageCreateManyArgs} args - Arguments to create many Znote_global_storages.
     *     @example
     *     // Create many Znote_global_storages
     *     const znote_global_storage = await prisma.znote_global_storage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_global_storageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_global_storageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_global_storage.
     * @param {znote_global_storageDeleteArgs} args - Arguments to delete one Znote_global_storage.
     * @example
     * // Delete one Znote_global_storage
     * const Znote_global_storage = await prisma.znote_global_storage.delete({
     *   where: {
     *     // ... filter to delete one Znote_global_storage
     *   }
     * })
     * 
    **/
    delete<T extends znote_global_storageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_global_storageDeleteArgs<ExtArgs>>
    ): Prisma__znote_global_storageClient<$Types.GetResult<znote_global_storagePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_global_storage.
     * @param {znote_global_storageUpdateArgs} args - Arguments to update one Znote_global_storage.
     * @example
     * // Update one Znote_global_storage
     * const znote_global_storage = await prisma.znote_global_storage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_global_storageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_global_storageUpdateArgs<ExtArgs>>
    ): Prisma__znote_global_storageClient<$Types.GetResult<znote_global_storagePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_global_storages.
     * @param {znote_global_storageDeleteManyArgs} args - Arguments to filter Znote_global_storages to delete.
     * @example
     * // Delete a few Znote_global_storages
     * const { count } = await prisma.znote_global_storage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_global_storageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_global_storageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_global_storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_global_storageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_global_storages
     * const znote_global_storage = await prisma.znote_global_storage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_global_storageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_global_storageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_global_storage.
     * @param {znote_global_storageUpsertArgs} args - Arguments to update or create a Znote_global_storage.
     * @example
     * // Update or create a Znote_global_storage
     * const znote_global_storage = await prisma.znote_global_storage.upsert({
     *   create: {
     *     // ... data to create a Znote_global_storage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_global_storage we want to update
     *   }
     * })
    **/
    upsert<T extends znote_global_storageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_global_storageUpsertArgs<ExtArgs>>
    ): Prisma__znote_global_storageClient<$Types.GetResult<znote_global_storagePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_global_storages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_global_storageCountArgs} args - Arguments to filter Znote_global_storages to count.
     * @example
     * // Count the number of Znote_global_storages
     * const count = await prisma.znote_global_storage.count({
     *   where: {
     *     // ... the filter for the Znote_global_storages we want to count
     *   }
     * })
    **/
    count<T extends znote_global_storageCountArgs>(
      args?: Subset<T, znote_global_storageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_global_storageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_global_storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_global_storageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_global_storageAggregateArgs>(args: Subset<T, Znote_global_storageAggregateArgs>): Prisma.PrismaPromise<GetZnote_global_storageAggregateType<T>>

    /**
     * Group by Znote_global_storage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_global_storageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_global_storageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_global_storageGroupByArgs['orderBy'] }
        : { orderBy?: Znote_global_storageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_global_storageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_global_storageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_global_storage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_global_storageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_global_storage base type for findUnique actions
   */
  export type znote_global_storageFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_global_storage
     */
    select?: znote_global_storageSelect<ExtArgs> | null
    /**
     * Filter, which znote_global_storage to fetch.
     */
    where: znote_global_storageWhereUniqueInput
  }

  /**
   * znote_global_storage findUnique
   */
  export interface znote_global_storageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_global_storageFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_global_storage findUniqueOrThrow
   */
  export type znote_global_storageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_global_storage
     */
    select?: znote_global_storageSelect<ExtArgs> | null
    /**
     * Filter, which znote_global_storage to fetch.
     */
    where: znote_global_storageWhereUniqueInput
  }


  /**
   * znote_global_storage base type for findFirst actions
   */
  export type znote_global_storageFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_global_storage
     */
    select?: znote_global_storageSelect<ExtArgs> | null
    /**
     * Filter, which znote_global_storage to fetch.
     */
    where?: znote_global_storageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_global_storages to fetch.
     */
    orderBy?: Enumerable<znote_global_storageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_global_storages.
     */
    cursor?: znote_global_storageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_global_storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_global_storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_global_storages.
     */
    distinct?: Enumerable<Znote_global_storageScalarFieldEnum>
  }

  /**
   * znote_global_storage findFirst
   */
  export interface znote_global_storageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_global_storageFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_global_storage findFirstOrThrow
   */
  export type znote_global_storageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_global_storage
     */
    select?: znote_global_storageSelect<ExtArgs> | null
    /**
     * Filter, which znote_global_storage to fetch.
     */
    where?: znote_global_storageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_global_storages to fetch.
     */
    orderBy?: Enumerable<znote_global_storageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_global_storages.
     */
    cursor?: znote_global_storageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_global_storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_global_storages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_global_storages.
     */
    distinct?: Enumerable<Znote_global_storageScalarFieldEnum>
  }


  /**
   * znote_global_storage findMany
   */
  export type znote_global_storageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_global_storage
     */
    select?: znote_global_storageSelect<ExtArgs> | null
    /**
     * Filter, which znote_global_storages to fetch.
     */
    where?: znote_global_storageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_global_storages to fetch.
     */
    orderBy?: Enumerable<znote_global_storageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_global_storages.
     */
    cursor?: znote_global_storageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_global_storages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_global_storages.
     */
    skip?: number
    distinct?: Enumerable<Znote_global_storageScalarFieldEnum>
  }


  /**
   * znote_global_storage create
   */
  export type znote_global_storageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_global_storage
     */
    select?: znote_global_storageSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_global_storage.
     */
    data: XOR<znote_global_storageCreateInput, znote_global_storageUncheckedCreateInput>
  }


  /**
   * znote_global_storage createMany
   */
  export type znote_global_storageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_global_storages.
     */
    data: Enumerable<znote_global_storageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_global_storage update
   */
  export type znote_global_storageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_global_storage
     */
    select?: znote_global_storageSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_global_storage.
     */
    data: XOR<znote_global_storageUpdateInput, znote_global_storageUncheckedUpdateInput>
    /**
     * Choose, which znote_global_storage to update.
     */
    where: znote_global_storageWhereUniqueInput
  }


  /**
   * znote_global_storage updateMany
   */
  export type znote_global_storageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_global_storages.
     */
    data: XOR<znote_global_storageUpdateManyMutationInput, znote_global_storageUncheckedUpdateManyInput>
    /**
     * Filter which znote_global_storages to update
     */
    where?: znote_global_storageWhereInput
  }


  /**
   * znote_global_storage upsert
   */
  export type znote_global_storageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_global_storage
     */
    select?: znote_global_storageSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_global_storage to update in case it exists.
     */
    where: znote_global_storageWhereUniqueInput
    /**
     * In case the znote_global_storage found by the `where` argument doesn't exist, create a new znote_global_storage with this data.
     */
    create: XOR<znote_global_storageCreateInput, znote_global_storageUncheckedCreateInput>
    /**
     * In case the znote_global_storage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_global_storageUpdateInput, znote_global_storageUncheckedUpdateInput>
  }


  /**
   * znote_global_storage delete
   */
  export type znote_global_storageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_global_storage
     */
    select?: znote_global_storageSelect<ExtArgs> | null
    /**
     * Filter which znote_global_storage to delete.
     */
    where: znote_global_storageWhereUniqueInput
  }


  /**
   * znote_global_storage deleteMany
   */
  export type znote_global_storageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_global_storages to delete
     */
    where?: znote_global_storageWhereInput
  }


  /**
   * znote_global_storage without action
   */
  export type znote_global_storageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_global_storage
     */
    select?: znote_global_storageSelect<ExtArgs> | null
  }



  /**
   * Model znote_guild_wars
   */


  export type AggregateZnote_guild_wars = {
    _count: Znote_guild_warsCountAggregateOutputType | null
    _avg: Znote_guild_warsAvgAggregateOutputType | null
    _sum: Znote_guild_warsSumAggregateOutputType | null
    _min: Znote_guild_warsMinAggregateOutputType | null
    _max: Znote_guild_warsMaxAggregateOutputType | null
  }

  export type Znote_guild_warsAvgAggregateOutputType = {
    id: number | null
    limit: number | null
  }

  export type Znote_guild_warsSumAggregateOutputType = {
    id: number | null
    limit: number | null
  }

  export type Znote_guild_warsMinAggregateOutputType = {
    id: number | null
    limit: number | null
  }

  export type Znote_guild_warsMaxAggregateOutputType = {
    id: number | null
    limit: number | null
  }

  export type Znote_guild_warsCountAggregateOutputType = {
    id: number
    limit: number
    _all: number
  }


  export type Znote_guild_warsAvgAggregateInputType = {
    id?: true
    limit?: true
  }

  export type Znote_guild_warsSumAggregateInputType = {
    id?: true
    limit?: true
  }

  export type Znote_guild_warsMinAggregateInputType = {
    id?: true
    limit?: true
  }

  export type Znote_guild_warsMaxAggregateInputType = {
    id?: true
    limit?: true
  }

  export type Znote_guild_warsCountAggregateInputType = {
    id?: true
    limit?: true
    _all?: true
  }

  export type Znote_guild_warsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_guild_wars to aggregate.
     */
    where?: znote_guild_warsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_guild_wars to fetch.
     */
    orderBy?: Enumerable<znote_guild_warsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_guild_warsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_guild_wars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_guild_wars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_guild_wars
    **/
    _count?: true | Znote_guild_warsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_guild_warsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_guild_warsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_guild_warsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_guild_warsMaxAggregateInputType
  }

  export type GetZnote_guild_warsAggregateType<T extends Znote_guild_warsAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_guild_wars]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_guild_wars[P]>
      : GetScalarType<T[P], AggregateZnote_guild_wars[P]>
  }




  export type Znote_guild_warsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_guild_warsWhereInput
    orderBy?: Enumerable<znote_guild_warsOrderByWithAggregationInput>
    by: Znote_guild_warsScalarFieldEnum[]
    having?: znote_guild_warsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_guild_warsCountAggregateInputType | true
    _avg?: Znote_guild_warsAvgAggregateInputType
    _sum?: Znote_guild_warsSumAggregateInputType
    _min?: Znote_guild_warsMinAggregateInputType
    _max?: Znote_guild_warsMaxAggregateInputType
  }


  export type Znote_guild_warsGroupByOutputType = {
    id: number
    limit: number
    _count: Znote_guild_warsCountAggregateOutputType | null
    _avg: Znote_guild_warsAvgAggregateOutputType | null
    _sum: Znote_guild_warsSumAggregateOutputType | null
    _min: Znote_guild_warsMinAggregateOutputType | null
    _max: Znote_guild_warsMaxAggregateOutputType | null
  }

  type GetZnote_guild_warsGroupByPayload<T extends Znote_guild_warsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_guild_warsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_guild_warsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_guild_warsGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_guild_warsGroupByOutputType[P]>
        }
      >
    >


  export type znote_guild_warsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    limit?: boolean
  }, ExtArgs["result"]["znote_guild_wars"]>

  export type znote_guild_warsSelectScalar = {
    id?: boolean
    limit?: boolean
  }


  type znote_guild_warsGetPayload<S extends boolean | null | undefined | znote_guild_warsArgs> = $Types.GetResult<znote_guild_warsPayload, S>

  type znote_guild_warsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_guild_warsFindManyArgs, 'select' | 'include'> & {
      select?: Znote_guild_warsCountAggregateInputType | true
    }

  export interface znote_guild_warsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_guild_wars'], meta: { name: 'znote_guild_wars' } }
    /**
     * Find zero or one Znote_guild_wars that matches the filter.
     * @param {znote_guild_warsFindUniqueArgs} args - Arguments to find a Znote_guild_wars
     * @example
     * // Get one Znote_guild_wars
     * const znote_guild_wars = await prisma.znote_guild_wars.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_guild_warsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_guild_warsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_guild_wars'> extends True ? Prisma__znote_guild_warsClient<$Types.GetResult<znote_guild_warsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_guild_warsClient<$Types.GetResult<znote_guild_warsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_guild_wars that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_guild_warsFindUniqueOrThrowArgs} args - Arguments to find a Znote_guild_wars
     * @example
     * // Get one Znote_guild_wars
     * const znote_guild_wars = await prisma.znote_guild_wars.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_guild_warsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_guild_warsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_guild_warsClient<$Types.GetResult<znote_guild_warsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_guild_wars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_guild_warsFindFirstArgs} args - Arguments to find a Znote_guild_wars
     * @example
     * // Get one Znote_guild_wars
     * const znote_guild_wars = await prisma.znote_guild_wars.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_guild_warsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_guild_warsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_guild_wars'> extends True ? Prisma__znote_guild_warsClient<$Types.GetResult<znote_guild_warsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_guild_warsClient<$Types.GetResult<znote_guild_warsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_guild_wars that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_guild_warsFindFirstOrThrowArgs} args - Arguments to find a Znote_guild_wars
     * @example
     * // Get one Znote_guild_wars
     * const znote_guild_wars = await prisma.znote_guild_wars.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_guild_warsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_guild_warsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_guild_warsClient<$Types.GetResult<znote_guild_warsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_guild_wars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_guild_warsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_guild_wars
     * const znote_guild_wars = await prisma.znote_guild_wars.findMany()
     * 
     * // Get first 10 Znote_guild_wars
     * const znote_guild_wars = await prisma.znote_guild_wars.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_guild_warsWithIdOnly = await prisma.znote_guild_wars.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_guild_warsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_guild_warsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_guild_warsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_guild_wars.
     * @param {znote_guild_warsCreateArgs} args - Arguments to create a Znote_guild_wars.
     * @example
     * // Create one Znote_guild_wars
     * const Znote_guild_wars = await prisma.znote_guild_wars.create({
     *   data: {
     *     // ... data to create a Znote_guild_wars
     *   }
     * })
     * 
    **/
    create<T extends znote_guild_warsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_guild_warsCreateArgs<ExtArgs>>
    ): Prisma__znote_guild_warsClient<$Types.GetResult<znote_guild_warsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_guild_wars.
     *     @param {znote_guild_warsCreateManyArgs} args - Arguments to create many Znote_guild_wars.
     *     @example
     *     // Create many Znote_guild_wars
     *     const znote_guild_wars = await prisma.znote_guild_wars.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_guild_warsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_guild_warsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_guild_wars.
     * @param {znote_guild_warsDeleteArgs} args - Arguments to delete one Znote_guild_wars.
     * @example
     * // Delete one Znote_guild_wars
     * const Znote_guild_wars = await prisma.znote_guild_wars.delete({
     *   where: {
     *     // ... filter to delete one Znote_guild_wars
     *   }
     * })
     * 
    **/
    delete<T extends znote_guild_warsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_guild_warsDeleteArgs<ExtArgs>>
    ): Prisma__znote_guild_warsClient<$Types.GetResult<znote_guild_warsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_guild_wars.
     * @param {znote_guild_warsUpdateArgs} args - Arguments to update one Znote_guild_wars.
     * @example
     * // Update one Znote_guild_wars
     * const znote_guild_wars = await prisma.znote_guild_wars.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_guild_warsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_guild_warsUpdateArgs<ExtArgs>>
    ): Prisma__znote_guild_warsClient<$Types.GetResult<znote_guild_warsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_guild_wars.
     * @param {znote_guild_warsDeleteManyArgs} args - Arguments to filter Znote_guild_wars to delete.
     * @example
     * // Delete a few Znote_guild_wars
     * const { count } = await prisma.znote_guild_wars.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_guild_warsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_guild_warsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_guild_wars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_guild_warsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_guild_wars
     * const znote_guild_wars = await prisma.znote_guild_wars.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_guild_warsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_guild_warsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_guild_wars.
     * @param {znote_guild_warsUpsertArgs} args - Arguments to update or create a Znote_guild_wars.
     * @example
     * // Update or create a Znote_guild_wars
     * const znote_guild_wars = await prisma.znote_guild_wars.upsert({
     *   create: {
     *     // ... data to create a Znote_guild_wars
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_guild_wars we want to update
     *   }
     * })
    **/
    upsert<T extends znote_guild_warsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_guild_warsUpsertArgs<ExtArgs>>
    ): Prisma__znote_guild_warsClient<$Types.GetResult<znote_guild_warsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_guild_wars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_guild_warsCountArgs} args - Arguments to filter Znote_guild_wars to count.
     * @example
     * // Count the number of Znote_guild_wars
     * const count = await prisma.znote_guild_wars.count({
     *   where: {
     *     // ... the filter for the Znote_guild_wars we want to count
     *   }
     * })
    **/
    count<T extends znote_guild_warsCountArgs>(
      args?: Subset<T, znote_guild_warsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_guild_warsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_guild_wars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_guild_warsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_guild_warsAggregateArgs>(args: Subset<T, Znote_guild_warsAggregateArgs>): Prisma.PrismaPromise<GetZnote_guild_warsAggregateType<T>>

    /**
     * Group by Znote_guild_wars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_guild_warsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_guild_warsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_guild_warsGroupByArgs['orderBy'] }
        : { orderBy?: Znote_guild_warsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_guild_warsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_guild_warsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_guild_wars.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_guild_warsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_guild_wars base type for findUnique actions
   */
  export type znote_guild_warsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_guild_wars
     */
    select?: znote_guild_warsSelect<ExtArgs> | null
    /**
     * Filter, which znote_guild_wars to fetch.
     */
    where: znote_guild_warsWhereUniqueInput
  }

  /**
   * znote_guild_wars findUnique
   */
  export interface znote_guild_warsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_guild_warsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_guild_wars findUniqueOrThrow
   */
  export type znote_guild_warsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_guild_wars
     */
    select?: znote_guild_warsSelect<ExtArgs> | null
    /**
     * Filter, which znote_guild_wars to fetch.
     */
    where: znote_guild_warsWhereUniqueInput
  }


  /**
   * znote_guild_wars base type for findFirst actions
   */
  export type znote_guild_warsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_guild_wars
     */
    select?: znote_guild_warsSelect<ExtArgs> | null
    /**
     * Filter, which znote_guild_wars to fetch.
     */
    where?: znote_guild_warsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_guild_wars to fetch.
     */
    orderBy?: Enumerable<znote_guild_warsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_guild_wars.
     */
    cursor?: znote_guild_warsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_guild_wars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_guild_wars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_guild_wars.
     */
    distinct?: Enumerable<Znote_guild_warsScalarFieldEnum>
  }

  /**
   * znote_guild_wars findFirst
   */
  export interface znote_guild_warsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_guild_warsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_guild_wars findFirstOrThrow
   */
  export type znote_guild_warsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_guild_wars
     */
    select?: znote_guild_warsSelect<ExtArgs> | null
    /**
     * Filter, which znote_guild_wars to fetch.
     */
    where?: znote_guild_warsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_guild_wars to fetch.
     */
    orderBy?: Enumerable<znote_guild_warsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_guild_wars.
     */
    cursor?: znote_guild_warsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_guild_wars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_guild_wars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_guild_wars.
     */
    distinct?: Enumerable<Znote_guild_warsScalarFieldEnum>
  }


  /**
   * znote_guild_wars findMany
   */
  export type znote_guild_warsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_guild_wars
     */
    select?: znote_guild_warsSelect<ExtArgs> | null
    /**
     * Filter, which znote_guild_wars to fetch.
     */
    where?: znote_guild_warsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_guild_wars to fetch.
     */
    orderBy?: Enumerable<znote_guild_warsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_guild_wars.
     */
    cursor?: znote_guild_warsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_guild_wars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_guild_wars.
     */
    skip?: number
    distinct?: Enumerable<Znote_guild_warsScalarFieldEnum>
  }


  /**
   * znote_guild_wars create
   */
  export type znote_guild_warsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_guild_wars
     */
    select?: znote_guild_warsSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_guild_wars.
     */
    data?: XOR<znote_guild_warsCreateInput, znote_guild_warsUncheckedCreateInput>
  }


  /**
   * znote_guild_wars createMany
   */
  export type znote_guild_warsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_guild_wars.
     */
    data: Enumerable<znote_guild_warsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_guild_wars update
   */
  export type znote_guild_warsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_guild_wars
     */
    select?: znote_guild_warsSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_guild_wars.
     */
    data: XOR<znote_guild_warsUpdateInput, znote_guild_warsUncheckedUpdateInput>
    /**
     * Choose, which znote_guild_wars to update.
     */
    where: znote_guild_warsWhereUniqueInput
  }


  /**
   * znote_guild_wars updateMany
   */
  export type znote_guild_warsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_guild_wars.
     */
    data: XOR<znote_guild_warsUpdateManyMutationInput, znote_guild_warsUncheckedUpdateManyInput>
    /**
     * Filter which znote_guild_wars to update
     */
    where?: znote_guild_warsWhereInput
  }


  /**
   * znote_guild_wars upsert
   */
  export type znote_guild_warsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_guild_wars
     */
    select?: znote_guild_warsSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_guild_wars to update in case it exists.
     */
    where: znote_guild_warsWhereUniqueInput
    /**
     * In case the znote_guild_wars found by the `where` argument doesn't exist, create a new znote_guild_wars with this data.
     */
    create: XOR<znote_guild_warsCreateInput, znote_guild_warsUncheckedCreateInput>
    /**
     * In case the znote_guild_wars was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_guild_warsUpdateInput, znote_guild_warsUncheckedUpdateInput>
  }


  /**
   * znote_guild_wars delete
   */
  export type znote_guild_warsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_guild_wars
     */
    select?: znote_guild_warsSelect<ExtArgs> | null
    /**
     * Filter which znote_guild_wars to delete.
     */
    where: znote_guild_warsWhereUniqueInput
  }


  /**
   * znote_guild_wars deleteMany
   */
  export type znote_guild_warsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_guild_wars to delete
     */
    where?: znote_guild_warsWhereInput
  }


  /**
   * znote_guild_wars without action
   */
  export type znote_guild_warsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_guild_wars
     */
    select?: znote_guild_warsSelect<ExtArgs> | null
  }



  /**
   * Model znote_images
   */


  export type AggregateZnote_images = {
    _count: Znote_imagesCountAggregateOutputType | null
    _avg: Znote_imagesAvgAggregateOutputType | null
    _sum: Znote_imagesSumAggregateOutputType | null
    _min: Znote_imagesMinAggregateOutputType | null
    _max: Znote_imagesMaxAggregateOutputType | null
  }

  export type Znote_imagesAvgAggregateOutputType = {
    id: number | null
    date: number | null
    status: number | null
    account_id: number | null
  }

  export type Znote_imagesSumAggregateOutputType = {
    id: number | null
    date: number | null
    status: number | null
    account_id: number | null
  }

  export type Znote_imagesMinAggregateOutputType = {
    id: number | null
    title: string | null
    desc: string | null
    date: number | null
    status: number | null
    image: string | null
    delhash: string | null
    account_id: number | null
  }

  export type Znote_imagesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    desc: string | null
    date: number | null
    status: number | null
    image: string | null
    delhash: string | null
    account_id: number | null
  }

  export type Znote_imagesCountAggregateOutputType = {
    id: number
    title: number
    desc: number
    date: number
    status: number
    image: number
    delhash: number
    account_id: number
    _all: number
  }


  export type Znote_imagesAvgAggregateInputType = {
    id?: true
    date?: true
    status?: true
    account_id?: true
  }

  export type Znote_imagesSumAggregateInputType = {
    id?: true
    date?: true
    status?: true
    account_id?: true
  }

  export type Znote_imagesMinAggregateInputType = {
    id?: true
    title?: true
    desc?: true
    date?: true
    status?: true
    image?: true
    delhash?: true
    account_id?: true
  }

  export type Znote_imagesMaxAggregateInputType = {
    id?: true
    title?: true
    desc?: true
    date?: true
    status?: true
    image?: true
    delhash?: true
    account_id?: true
  }

  export type Znote_imagesCountAggregateInputType = {
    id?: true
    title?: true
    desc?: true
    date?: true
    status?: true
    image?: true
    delhash?: true
    account_id?: true
    _all?: true
  }

  export type Znote_imagesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_images to aggregate.
     */
    where?: znote_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_images to fetch.
     */
    orderBy?: Enumerable<znote_imagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_images
    **/
    _count?: true | Znote_imagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_imagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_imagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_imagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_imagesMaxAggregateInputType
  }

  export type GetZnote_imagesAggregateType<T extends Znote_imagesAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_images]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_images[P]>
      : GetScalarType<T[P], AggregateZnote_images[P]>
  }




  export type Znote_imagesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_imagesWhereInput
    orderBy?: Enumerable<znote_imagesOrderByWithAggregationInput>
    by: Znote_imagesScalarFieldEnum[]
    having?: znote_imagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_imagesCountAggregateInputType | true
    _avg?: Znote_imagesAvgAggregateInputType
    _sum?: Znote_imagesSumAggregateInputType
    _min?: Znote_imagesMinAggregateInputType
    _max?: Znote_imagesMaxAggregateInputType
  }


  export type Znote_imagesGroupByOutputType = {
    id: number
    title: string
    desc: string
    date: number
    status: number
    image: string
    delhash: string
    account_id: number
    _count: Znote_imagesCountAggregateOutputType | null
    _avg: Znote_imagesAvgAggregateOutputType | null
    _sum: Znote_imagesSumAggregateOutputType | null
    _min: Znote_imagesMinAggregateOutputType | null
    _max: Znote_imagesMaxAggregateOutputType | null
  }

  type GetZnote_imagesGroupByPayload<T extends Znote_imagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_imagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_imagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_imagesGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_imagesGroupByOutputType[P]>
        }
      >
    >


  export type znote_imagesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    desc?: boolean
    date?: boolean
    status?: boolean
    image?: boolean
    delhash?: boolean
    account_id?: boolean
  }, ExtArgs["result"]["znote_images"]>

  export type znote_imagesSelectScalar = {
    id?: boolean
    title?: boolean
    desc?: boolean
    date?: boolean
    status?: boolean
    image?: boolean
    delhash?: boolean
    account_id?: boolean
  }


  type znote_imagesGetPayload<S extends boolean | null | undefined | znote_imagesArgs> = $Types.GetResult<znote_imagesPayload, S>

  type znote_imagesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_imagesFindManyArgs, 'select' | 'include'> & {
      select?: Znote_imagesCountAggregateInputType | true
    }

  export interface znote_imagesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_images'], meta: { name: 'znote_images' } }
    /**
     * Find zero or one Znote_images that matches the filter.
     * @param {znote_imagesFindUniqueArgs} args - Arguments to find a Znote_images
     * @example
     * // Get one Znote_images
     * const znote_images = await prisma.znote_images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_imagesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_imagesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_images'> extends True ? Prisma__znote_imagesClient<$Types.GetResult<znote_imagesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_imagesClient<$Types.GetResult<znote_imagesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_images that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_imagesFindUniqueOrThrowArgs} args - Arguments to find a Znote_images
     * @example
     * // Get one Znote_images
     * const znote_images = await prisma.znote_images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_imagesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_imagesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_imagesClient<$Types.GetResult<znote_imagesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_imagesFindFirstArgs} args - Arguments to find a Znote_images
     * @example
     * // Get one Znote_images
     * const znote_images = await prisma.znote_images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_imagesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_imagesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_images'> extends True ? Prisma__znote_imagesClient<$Types.GetResult<znote_imagesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_imagesClient<$Types.GetResult<znote_imagesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_images that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_imagesFindFirstOrThrowArgs} args - Arguments to find a Znote_images
     * @example
     * // Get one Znote_images
     * const znote_images = await prisma.znote_images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_imagesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_imagesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_imagesClient<$Types.GetResult<znote_imagesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_imagesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_images
     * const znote_images = await prisma.znote_images.findMany()
     * 
     * // Get first 10 Znote_images
     * const znote_images = await prisma.znote_images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_imagesWithIdOnly = await prisma.znote_images.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_imagesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_imagesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_imagesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_images.
     * @param {znote_imagesCreateArgs} args - Arguments to create a Znote_images.
     * @example
     * // Create one Znote_images
     * const Znote_images = await prisma.znote_images.create({
     *   data: {
     *     // ... data to create a Znote_images
     *   }
     * })
     * 
    **/
    create<T extends znote_imagesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_imagesCreateArgs<ExtArgs>>
    ): Prisma__znote_imagesClient<$Types.GetResult<znote_imagesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_images.
     *     @param {znote_imagesCreateManyArgs} args - Arguments to create many Znote_images.
     *     @example
     *     // Create many Znote_images
     *     const znote_images = await prisma.znote_images.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_imagesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_imagesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_images.
     * @param {znote_imagesDeleteArgs} args - Arguments to delete one Znote_images.
     * @example
     * // Delete one Znote_images
     * const Znote_images = await prisma.znote_images.delete({
     *   where: {
     *     // ... filter to delete one Znote_images
     *   }
     * })
     * 
    **/
    delete<T extends znote_imagesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_imagesDeleteArgs<ExtArgs>>
    ): Prisma__znote_imagesClient<$Types.GetResult<znote_imagesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_images.
     * @param {znote_imagesUpdateArgs} args - Arguments to update one Znote_images.
     * @example
     * // Update one Znote_images
     * const znote_images = await prisma.znote_images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_imagesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_imagesUpdateArgs<ExtArgs>>
    ): Prisma__znote_imagesClient<$Types.GetResult<znote_imagesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_images.
     * @param {znote_imagesDeleteManyArgs} args - Arguments to filter Znote_images to delete.
     * @example
     * // Delete a few Znote_images
     * const { count } = await prisma.znote_images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_imagesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_imagesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_images
     * const znote_images = await prisma.znote_images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_imagesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_imagesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_images.
     * @param {znote_imagesUpsertArgs} args - Arguments to update or create a Znote_images.
     * @example
     * // Update or create a Znote_images
     * const znote_images = await prisma.znote_images.upsert({
     *   create: {
     *     // ... data to create a Znote_images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_images we want to update
     *   }
     * })
    **/
    upsert<T extends znote_imagesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_imagesUpsertArgs<ExtArgs>>
    ): Prisma__znote_imagesClient<$Types.GetResult<znote_imagesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_imagesCountArgs} args - Arguments to filter Znote_images to count.
     * @example
     * // Count the number of Znote_images
     * const count = await prisma.znote_images.count({
     *   where: {
     *     // ... the filter for the Znote_images we want to count
     *   }
     * })
    **/
    count<T extends znote_imagesCountArgs>(
      args?: Subset<T, znote_imagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_imagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_imagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_imagesAggregateArgs>(args: Subset<T, Znote_imagesAggregateArgs>): Prisma.PrismaPromise<GetZnote_imagesAggregateType<T>>

    /**
     * Group by Znote_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_imagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_imagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_imagesGroupByArgs['orderBy'] }
        : { orderBy?: Znote_imagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_imagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_imagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_imagesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_images base type for findUnique actions
   */
  export type znote_imagesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_images
     */
    select?: znote_imagesSelect<ExtArgs> | null
    /**
     * Filter, which znote_images to fetch.
     */
    where: znote_imagesWhereUniqueInput
  }

  /**
   * znote_images findUnique
   */
  export interface znote_imagesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_imagesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_images findUniqueOrThrow
   */
  export type znote_imagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_images
     */
    select?: znote_imagesSelect<ExtArgs> | null
    /**
     * Filter, which znote_images to fetch.
     */
    where: znote_imagesWhereUniqueInput
  }


  /**
   * znote_images base type for findFirst actions
   */
  export type znote_imagesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_images
     */
    select?: znote_imagesSelect<ExtArgs> | null
    /**
     * Filter, which znote_images to fetch.
     */
    where?: znote_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_images to fetch.
     */
    orderBy?: Enumerable<znote_imagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_images.
     */
    cursor?: znote_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_images.
     */
    distinct?: Enumerable<Znote_imagesScalarFieldEnum>
  }

  /**
   * znote_images findFirst
   */
  export interface znote_imagesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_imagesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_images findFirstOrThrow
   */
  export type znote_imagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_images
     */
    select?: znote_imagesSelect<ExtArgs> | null
    /**
     * Filter, which znote_images to fetch.
     */
    where?: znote_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_images to fetch.
     */
    orderBy?: Enumerable<znote_imagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_images.
     */
    cursor?: znote_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_images.
     */
    distinct?: Enumerable<Znote_imagesScalarFieldEnum>
  }


  /**
   * znote_images findMany
   */
  export type znote_imagesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_images
     */
    select?: znote_imagesSelect<ExtArgs> | null
    /**
     * Filter, which znote_images to fetch.
     */
    where?: znote_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_images to fetch.
     */
    orderBy?: Enumerable<znote_imagesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_images.
     */
    cursor?: znote_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_images.
     */
    skip?: number
    distinct?: Enumerable<Znote_imagesScalarFieldEnum>
  }


  /**
   * znote_images create
   */
  export type znote_imagesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_images
     */
    select?: znote_imagesSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_images.
     */
    data: XOR<znote_imagesCreateInput, znote_imagesUncheckedCreateInput>
  }


  /**
   * znote_images createMany
   */
  export type znote_imagesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_images.
     */
    data: Enumerable<znote_imagesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_images update
   */
  export type znote_imagesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_images
     */
    select?: znote_imagesSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_images.
     */
    data: XOR<znote_imagesUpdateInput, znote_imagesUncheckedUpdateInput>
    /**
     * Choose, which znote_images to update.
     */
    where: znote_imagesWhereUniqueInput
  }


  /**
   * znote_images updateMany
   */
  export type znote_imagesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_images.
     */
    data: XOR<znote_imagesUpdateManyMutationInput, znote_imagesUncheckedUpdateManyInput>
    /**
     * Filter which znote_images to update
     */
    where?: znote_imagesWhereInput
  }


  /**
   * znote_images upsert
   */
  export type znote_imagesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_images
     */
    select?: znote_imagesSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_images to update in case it exists.
     */
    where: znote_imagesWhereUniqueInput
    /**
     * In case the znote_images found by the `where` argument doesn't exist, create a new znote_images with this data.
     */
    create: XOR<znote_imagesCreateInput, znote_imagesUncheckedCreateInput>
    /**
     * In case the znote_images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_imagesUpdateInput, znote_imagesUncheckedUpdateInput>
  }


  /**
   * znote_images delete
   */
  export type znote_imagesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_images
     */
    select?: znote_imagesSelect<ExtArgs> | null
    /**
     * Filter which znote_images to delete.
     */
    where: znote_imagesWhereUniqueInput
  }


  /**
   * znote_images deleteMany
   */
  export type znote_imagesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_images to delete
     */
    where?: znote_imagesWhereInput
  }


  /**
   * znote_images without action
   */
  export type znote_imagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_images
     */
    select?: znote_imagesSelect<ExtArgs> | null
  }



  /**
   * Model znote_news
   */


  export type AggregateZnote_news = {
    _count: Znote_newsCountAggregateOutputType | null
    _avg: Znote_newsAvgAggregateOutputType | null
    _sum: Znote_newsSumAggregateOutputType | null
    _min: Znote_newsMinAggregateOutputType | null
    _max: Znote_newsMaxAggregateOutputType | null
  }

  export type Znote_newsAvgAggregateOutputType = {
    id: number | null
    date: number | null
    pid: number | null
  }

  export type Znote_newsSumAggregateOutputType = {
    id: number | null
    date: number | null
    pid: number | null
  }

  export type Znote_newsMinAggregateOutputType = {
    id: number | null
    title: string | null
    text: string | null
    date: number | null
    pid: number | null
  }

  export type Znote_newsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    text: string | null
    date: number | null
    pid: number | null
  }

  export type Znote_newsCountAggregateOutputType = {
    id: number
    title: number
    text: number
    date: number
    pid: number
    _all: number
  }


  export type Znote_newsAvgAggregateInputType = {
    id?: true
    date?: true
    pid?: true
  }

  export type Znote_newsSumAggregateInputType = {
    id?: true
    date?: true
    pid?: true
  }

  export type Znote_newsMinAggregateInputType = {
    id?: true
    title?: true
    text?: true
    date?: true
    pid?: true
  }

  export type Znote_newsMaxAggregateInputType = {
    id?: true
    title?: true
    text?: true
    date?: true
    pid?: true
  }

  export type Znote_newsCountAggregateInputType = {
    id?: true
    title?: true
    text?: true
    date?: true
    pid?: true
    _all?: true
  }

  export type Znote_newsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_news to aggregate.
     */
    where?: znote_newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_news to fetch.
     */
    orderBy?: Enumerable<znote_newsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_news
    **/
    _count?: true | Znote_newsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_newsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_newsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_newsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_newsMaxAggregateInputType
  }

  export type GetZnote_newsAggregateType<T extends Znote_newsAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_news]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_news[P]>
      : GetScalarType<T[P], AggregateZnote_news[P]>
  }




  export type Znote_newsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_newsWhereInput
    orderBy?: Enumerable<znote_newsOrderByWithAggregationInput>
    by: Znote_newsScalarFieldEnum[]
    having?: znote_newsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_newsCountAggregateInputType | true
    _avg?: Znote_newsAvgAggregateInputType
    _sum?: Znote_newsSumAggregateInputType
    _min?: Znote_newsMinAggregateInputType
    _max?: Znote_newsMaxAggregateInputType
  }


  export type Znote_newsGroupByOutputType = {
    id: number
    title: string
    text: string
    date: number
    pid: number
    _count: Znote_newsCountAggregateOutputType | null
    _avg: Znote_newsAvgAggregateOutputType | null
    _sum: Znote_newsSumAggregateOutputType | null
    _min: Znote_newsMinAggregateOutputType | null
    _max: Znote_newsMaxAggregateOutputType | null
  }

  type GetZnote_newsGroupByPayload<T extends Znote_newsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_newsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_newsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_newsGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_newsGroupByOutputType[P]>
        }
      >
    >


  export type znote_newsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    text?: boolean
    date?: boolean
    pid?: boolean
  }, ExtArgs["result"]["znote_news"]>

  export type znote_newsSelectScalar = {
    id?: boolean
    title?: boolean
    text?: boolean
    date?: boolean
    pid?: boolean
  }


  type znote_newsGetPayload<S extends boolean | null | undefined | znote_newsArgs> = $Types.GetResult<znote_newsPayload, S>

  type znote_newsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_newsFindManyArgs, 'select' | 'include'> & {
      select?: Znote_newsCountAggregateInputType | true
    }

  export interface znote_newsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_news'], meta: { name: 'znote_news' } }
    /**
     * Find zero or one Znote_news that matches the filter.
     * @param {znote_newsFindUniqueArgs} args - Arguments to find a Znote_news
     * @example
     * // Get one Znote_news
     * const znote_news = await prisma.znote_news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_newsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_newsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_news'> extends True ? Prisma__znote_newsClient<$Types.GetResult<znote_newsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_newsClient<$Types.GetResult<znote_newsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_news that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_newsFindUniqueOrThrowArgs} args - Arguments to find a Znote_news
     * @example
     * // Get one Znote_news
     * const znote_news = await prisma.znote_news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_newsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_newsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_newsClient<$Types.GetResult<znote_newsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_news that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_newsFindFirstArgs} args - Arguments to find a Znote_news
     * @example
     * // Get one Znote_news
     * const znote_news = await prisma.znote_news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_newsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_newsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_news'> extends True ? Prisma__znote_newsClient<$Types.GetResult<znote_newsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_newsClient<$Types.GetResult<znote_newsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_news that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_newsFindFirstOrThrowArgs} args - Arguments to find a Znote_news
     * @example
     * // Get one Znote_news
     * const znote_news = await prisma.znote_news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_newsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_newsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_newsClient<$Types.GetResult<znote_newsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_news that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_newsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_news
     * const znote_news = await prisma.znote_news.findMany()
     * 
     * // Get first 10 Znote_news
     * const znote_news = await prisma.znote_news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_newsWithIdOnly = await prisma.znote_news.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_newsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_newsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_newsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_news.
     * @param {znote_newsCreateArgs} args - Arguments to create a Znote_news.
     * @example
     * // Create one Znote_news
     * const Znote_news = await prisma.znote_news.create({
     *   data: {
     *     // ... data to create a Znote_news
     *   }
     * })
     * 
    **/
    create<T extends znote_newsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_newsCreateArgs<ExtArgs>>
    ): Prisma__znote_newsClient<$Types.GetResult<znote_newsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_news.
     *     @param {znote_newsCreateManyArgs} args - Arguments to create many Znote_news.
     *     @example
     *     // Create many Znote_news
     *     const znote_news = await prisma.znote_news.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_newsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_newsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_news.
     * @param {znote_newsDeleteArgs} args - Arguments to delete one Znote_news.
     * @example
     * // Delete one Znote_news
     * const Znote_news = await prisma.znote_news.delete({
     *   where: {
     *     // ... filter to delete one Znote_news
     *   }
     * })
     * 
    **/
    delete<T extends znote_newsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_newsDeleteArgs<ExtArgs>>
    ): Prisma__znote_newsClient<$Types.GetResult<znote_newsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_news.
     * @param {znote_newsUpdateArgs} args - Arguments to update one Znote_news.
     * @example
     * // Update one Znote_news
     * const znote_news = await prisma.znote_news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_newsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_newsUpdateArgs<ExtArgs>>
    ): Prisma__znote_newsClient<$Types.GetResult<znote_newsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_news.
     * @param {znote_newsDeleteManyArgs} args - Arguments to filter Znote_news to delete.
     * @example
     * // Delete a few Znote_news
     * const { count } = await prisma.znote_news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_newsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_newsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_newsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_news
     * const znote_news = await prisma.znote_news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_newsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_newsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_news.
     * @param {znote_newsUpsertArgs} args - Arguments to update or create a Znote_news.
     * @example
     * // Update or create a Znote_news
     * const znote_news = await prisma.znote_news.upsert({
     *   create: {
     *     // ... data to create a Znote_news
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_news we want to update
     *   }
     * })
    **/
    upsert<T extends znote_newsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_newsUpsertArgs<ExtArgs>>
    ): Prisma__znote_newsClient<$Types.GetResult<znote_newsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_newsCountArgs} args - Arguments to filter Znote_news to count.
     * @example
     * // Count the number of Znote_news
     * const count = await prisma.znote_news.count({
     *   where: {
     *     // ... the filter for the Znote_news we want to count
     *   }
     * })
    **/
    count<T extends znote_newsCountArgs>(
      args?: Subset<T, znote_newsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_newsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_newsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_newsAggregateArgs>(args: Subset<T, Znote_newsAggregateArgs>): Prisma.PrismaPromise<GetZnote_newsAggregateType<T>>

    /**
     * Group by Znote_news.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_newsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_newsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_newsGroupByArgs['orderBy'] }
        : { orderBy?: Znote_newsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_newsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_newsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_news.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_newsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_news base type for findUnique actions
   */
  export type znote_newsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_news
     */
    select?: znote_newsSelect<ExtArgs> | null
    /**
     * Filter, which znote_news to fetch.
     */
    where: znote_newsWhereUniqueInput
  }

  /**
   * znote_news findUnique
   */
  export interface znote_newsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_newsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_news findUniqueOrThrow
   */
  export type znote_newsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_news
     */
    select?: znote_newsSelect<ExtArgs> | null
    /**
     * Filter, which znote_news to fetch.
     */
    where: znote_newsWhereUniqueInput
  }


  /**
   * znote_news base type for findFirst actions
   */
  export type znote_newsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_news
     */
    select?: znote_newsSelect<ExtArgs> | null
    /**
     * Filter, which znote_news to fetch.
     */
    where?: znote_newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_news to fetch.
     */
    orderBy?: Enumerable<znote_newsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_news.
     */
    cursor?: znote_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_news.
     */
    distinct?: Enumerable<Znote_newsScalarFieldEnum>
  }

  /**
   * znote_news findFirst
   */
  export interface znote_newsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_newsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_news findFirstOrThrow
   */
  export type znote_newsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_news
     */
    select?: znote_newsSelect<ExtArgs> | null
    /**
     * Filter, which znote_news to fetch.
     */
    where?: znote_newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_news to fetch.
     */
    orderBy?: Enumerable<znote_newsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_news.
     */
    cursor?: znote_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_news.
     */
    distinct?: Enumerable<Znote_newsScalarFieldEnum>
  }


  /**
   * znote_news findMany
   */
  export type znote_newsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_news
     */
    select?: znote_newsSelect<ExtArgs> | null
    /**
     * Filter, which znote_news to fetch.
     */
    where?: znote_newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_news to fetch.
     */
    orderBy?: Enumerable<znote_newsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_news.
     */
    cursor?: znote_newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_news.
     */
    skip?: number
    distinct?: Enumerable<Znote_newsScalarFieldEnum>
  }


  /**
   * znote_news create
   */
  export type znote_newsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_news
     */
    select?: znote_newsSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_news.
     */
    data: XOR<znote_newsCreateInput, znote_newsUncheckedCreateInput>
  }


  /**
   * znote_news createMany
   */
  export type znote_newsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_news.
     */
    data: Enumerable<znote_newsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_news update
   */
  export type znote_newsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_news
     */
    select?: znote_newsSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_news.
     */
    data: XOR<znote_newsUpdateInput, znote_newsUncheckedUpdateInput>
    /**
     * Choose, which znote_news to update.
     */
    where: znote_newsWhereUniqueInput
  }


  /**
   * znote_news updateMany
   */
  export type znote_newsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_news.
     */
    data: XOR<znote_newsUpdateManyMutationInput, znote_newsUncheckedUpdateManyInput>
    /**
     * Filter which znote_news to update
     */
    where?: znote_newsWhereInput
  }


  /**
   * znote_news upsert
   */
  export type znote_newsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_news
     */
    select?: znote_newsSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_news to update in case it exists.
     */
    where: znote_newsWhereUniqueInput
    /**
     * In case the znote_news found by the `where` argument doesn't exist, create a new znote_news with this data.
     */
    create: XOR<znote_newsCreateInput, znote_newsUncheckedCreateInput>
    /**
     * In case the znote_news was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_newsUpdateInput, znote_newsUncheckedUpdateInput>
  }


  /**
   * znote_news delete
   */
  export type znote_newsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_news
     */
    select?: znote_newsSelect<ExtArgs> | null
    /**
     * Filter which znote_news to delete.
     */
    where: znote_newsWhereUniqueInput
  }


  /**
   * znote_news deleteMany
   */
  export type znote_newsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_news to delete
     */
    where?: znote_newsWhereInput
  }


  /**
   * znote_news without action
   */
  export type znote_newsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_news
     */
    select?: znote_newsSelect<ExtArgs> | null
  }



  /**
   * Model znote_paygol
   */


  export type AggregateZnote_paygol = {
    _count: Znote_paygolCountAggregateOutputType | null
    _avg: Znote_paygolAvgAggregateOutputType | null
    _sum: Znote_paygolSumAggregateOutputType | null
    _min: Znote_paygolMinAggregateOutputType | null
    _max: Znote_paygolMaxAggregateOutputType | null
  }

  export type Znote_paygolAvgAggregateOutputType = {
    id: number | null
    account_id: number | null
    price: number | null
    points: number | null
  }

  export type Znote_paygolSumAggregateOutputType = {
    id: number | null
    account_id: number | null
    price: number | null
    points: number | null
  }

  export type Znote_paygolMinAggregateOutputType = {
    id: number | null
    account_id: number | null
    price: number | null
    points: number | null
    message_id: string | null
    service_id: string | null
    shortcode: string | null
    keyword: string | null
    message: string | null
    sender: string | null
    operator: string | null
    country: string | null
    currency: string | null
  }

  export type Znote_paygolMaxAggregateOutputType = {
    id: number | null
    account_id: number | null
    price: number | null
    points: number | null
    message_id: string | null
    service_id: string | null
    shortcode: string | null
    keyword: string | null
    message: string | null
    sender: string | null
    operator: string | null
    country: string | null
    currency: string | null
  }

  export type Znote_paygolCountAggregateOutputType = {
    id: number
    account_id: number
    price: number
    points: number
    message_id: number
    service_id: number
    shortcode: number
    keyword: number
    message: number
    sender: number
    operator: number
    country: number
    currency: number
    _all: number
  }


  export type Znote_paygolAvgAggregateInputType = {
    id?: true
    account_id?: true
    price?: true
    points?: true
  }

  export type Znote_paygolSumAggregateInputType = {
    id?: true
    account_id?: true
    price?: true
    points?: true
  }

  export type Znote_paygolMinAggregateInputType = {
    id?: true
    account_id?: true
    price?: true
    points?: true
    message_id?: true
    service_id?: true
    shortcode?: true
    keyword?: true
    message?: true
    sender?: true
    operator?: true
    country?: true
    currency?: true
  }

  export type Znote_paygolMaxAggregateInputType = {
    id?: true
    account_id?: true
    price?: true
    points?: true
    message_id?: true
    service_id?: true
    shortcode?: true
    keyword?: true
    message?: true
    sender?: true
    operator?: true
    country?: true
    currency?: true
  }

  export type Znote_paygolCountAggregateInputType = {
    id?: true
    account_id?: true
    price?: true
    points?: true
    message_id?: true
    service_id?: true
    shortcode?: true
    keyword?: true
    message?: true
    sender?: true
    operator?: true
    country?: true
    currency?: true
    _all?: true
  }

  export type Znote_paygolAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_paygol to aggregate.
     */
    where?: znote_paygolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_paygols to fetch.
     */
    orderBy?: Enumerable<znote_paygolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_paygolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_paygols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_paygols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_paygols
    **/
    _count?: true | Znote_paygolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_paygolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_paygolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_paygolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_paygolMaxAggregateInputType
  }

  export type GetZnote_paygolAggregateType<T extends Znote_paygolAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_paygol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_paygol[P]>
      : GetScalarType<T[P], AggregateZnote_paygol[P]>
  }




  export type Znote_paygolGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_paygolWhereInput
    orderBy?: Enumerable<znote_paygolOrderByWithAggregationInput>
    by: Znote_paygolScalarFieldEnum[]
    having?: znote_paygolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_paygolCountAggregateInputType | true
    _avg?: Znote_paygolAvgAggregateInputType
    _sum?: Znote_paygolSumAggregateInputType
    _min?: Znote_paygolMinAggregateInputType
    _max?: Znote_paygolMaxAggregateInputType
  }


  export type Znote_paygolGroupByOutputType = {
    id: number
    account_id: number
    price: number
    points: number
    message_id: string
    service_id: string
    shortcode: string
    keyword: string
    message: string
    sender: string
    operator: string
    country: string
    currency: string
    _count: Znote_paygolCountAggregateOutputType | null
    _avg: Znote_paygolAvgAggregateOutputType | null
    _sum: Znote_paygolSumAggregateOutputType | null
    _min: Znote_paygolMinAggregateOutputType | null
    _max: Znote_paygolMaxAggregateOutputType | null
  }

  type GetZnote_paygolGroupByPayload<T extends Znote_paygolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_paygolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_paygolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_paygolGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_paygolGroupByOutputType[P]>
        }
      >
    >


  export type znote_paygolSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    price?: boolean
    points?: boolean
    message_id?: boolean
    service_id?: boolean
    shortcode?: boolean
    keyword?: boolean
    message?: boolean
    sender?: boolean
    operator?: boolean
    country?: boolean
    currency?: boolean
  }, ExtArgs["result"]["znote_paygol"]>

  export type znote_paygolSelectScalar = {
    id?: boolean
    account_id?: boolean
    price?: boolean
    points?: boolean
    message_id?: boolean
    service_id?: boolean
    shortcode?: boolean
    keyword?: boolean
    message?: boolean
    sender?: boolean
    operator?: boolean
    country?: boolean
    currency?: boolean
  }


  type znote_paygolGetPayload<S extends boolean | null | undefined | znote_paygolArgs> = $Types.GetResult<znote_paygolPayload, S>

  type znote_paygolCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_paygolFindManyArgs, 'select' | 'include'> & {
      select?: Znote_paygolCountAggregateInputType | true
    }

  export interface znote_paygolDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_paygol'], meta: { name: 'znote_paygol' } }
    /**
     * Find zero or one Znote_paygol that matches the filter.
     * @param {znote_paygolFindUniqueArgs} args - Arguments to find a Znote_paygol
     * @example
     * // Get one Znote_paygol
     * const znote_paygol = await prisma.znote_paygol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_paygolFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_paygolFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_paygol'> extends True ? Prisma__znote_paygolClient<$Types.GetResult<znote_paygolPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_paygolClient<$Types.GetResult<znote_paygolPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_paygol that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_paygolFindUniqueOrThrowArgs} args - Arguments to find a Znote_paygol
     * @example
     * // Get one Znote_paygol
     * const znote_paygol = await prisma.znote_paygol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_paygolFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_paygolFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_paygolClient<$Types.GetResult<znote_paygolPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_paygol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_paygolFindFirstArgs} args - Arguments to find a Znote_paygol
     * @example
     * // Get one Znote_paygol
     * const znote_paygol = await prisma.znote_paygol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_paygolFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_paygolFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_paygol'> extends True ? Prisma__znote_paygolClient<$Types.GetResult<znote_paygolPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_paygolClient<$Types.GetResult<znote_paygolPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_paygol that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_paygolFindFirstOrThrowArgs} args - Arguments to find a Znote_paygol
     * @example
     * // Get one Znote_paygol
     * const znote_paygol = await prisma.znote_paygol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_paygolFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_paygolFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_paygolClient<$Types.GetResult<znote_paygolPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_paygols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_paygolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_paygols
     * const znote_paygols = await prisma.znote_paygol.findMany()
     * 
     * // Get first 10 Znote_paygols
     * const znote_paygols = await prisma.znote_paygol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_paygolWithIdOnly = await prisma.znote_paygol.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_paygolFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_paygolFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_paygolPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_paygol.
     * @param {znote_paygolCreateArgs} args - Arguments to create a Znote_paygol.
     * @example
     * // Create one Znote_paygol
     * const Znote_paygol = await prisma.znote_paygol.create({
     *   data: {
     *     // ... data to create a Znote_paygol
     *   }
     * })
     * 
    **/
    create<T extends znote_paygolCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_paygolCreateArgs<ExtArgs>>
    ): Prisma__znote_paygolClient<$Types.GetResult<znote_paygolPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_paygols.
     *     @param {znote_paygolCreateManyArgs} args - Arguments to create many Znote_paygols.
     *     @example
     *     // Create many Znote_paygols
     *     const znote_paygol = await prisma.znote_paygol.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_paygolCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_paygolCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_paygol.
     * @param {znote_paygolDeleteArgs} args - Arguments to delete one Znote_paygol.
     * @example
     * // Delete one Znote_paygol
     * const Znote_paygol = await prisma.znote_paygol.delete({
     *   where: {
     *     // ... filter to delete one Znote_paygol
     *   }
     * })
     * 
    **/
    delete<T extends znote_paygolDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_paygolDeleteArgs<ExtArgs>>
    ): Prisma__znote_paygolClient<$Types.GetResult<znote_paygolPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_paygol.
     * @param {znote_paygolUpdateArgs} args - Arguments to update one Znote_paygol.
     * @example
     * // Update one Znote_paygol
     * const znote_paygol = await prisma.znote_paygol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_paygolUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_paygolUpdateArgs<ExtArgs>>
    ): Prisma__znote_paygolClient<$Types.GetResult<znote_paygolPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_paygols.
     * @param {znote_paygolDeleteManyArgs} args - Arguments to filter Znote_paygols to delete.
     * @example
     * // Delete a few Znote_paygols
     * const { count } = await prisma.znote_paygol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_paygolDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_paygolDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_paygols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_paygolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_paygols
     * const znote_paygol = await prisma.znote_paygol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_paygolUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_paygolUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_paygol.
     * @param {znote_paygolUpsertArgs} args - Arguments to update or create a Znote_paygol.
     * @example
     * // Update or create a Znote_paygol
     * const znote_paygol = await prisma.znote_paygol.upsert({
     *   create: {
     *     // ... data to create a Znote_paygol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_paygol we want to update
     *   }
     * })
    **/
    upsert<T extends znote_paygolUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_paygolUpsertArgs<ExtArgs>>
    ): Prisma__znote_paygolClient<$Types.GetResult<znote_paygolPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_paygols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_paygolCountArgs} args - Arguments to filter Znote_paygols to count.
     * @example
     * // Count the number of Znote_paygols
     * const count = await prisma.znote_paygol.count({
     *   where: {
     *     // ... the filter for the Znote_paygols we want to count
     *   }
     * })
    **/
    count<T extends znote_paygolCountArgs>(
      args?: Subset<T, znote_paygolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_paygolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_paygol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_paygolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_paygolAggregateArgs>(args: Subset<T, Znote_paygolAggregateArgs>): Prisma.PrismaPromise<GetZnote_paygolAggregateType<T>>

    /**
     * Group by Znote_paygol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_paygolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_paygolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_paygolGroupByArgs['orderBy'] }
        : { orderBy?: Znote_paygolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_paygolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_paygolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_paygol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_paygolClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_paygol base type for findUnique actions
   */
  export type znote_paygolFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paygol
     */
    select?: znote_paygolSelect<ExtArgs> | null
    /**
     * Filter, which znote_paygol to fetch.
     */
    where: znote_paygolWhereUniqueInput
  }

  /**
   * znote_paygol findUnique
   */
  export interface znote_paygolFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_paygolFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_paygol findUniqueOrThrow
   */
  export type znote_paygolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paygol
     */
    select?: znote_paygolSelect<ExtArgs> | null
    /**
     * Filter, which znote_paygol to fetch.
     */
    where: znote_paygolWhereUniqueInput
  }


  /**
   * znote_paygol base type for findFirst actions
   */
  export type znote_paygolFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paygol
     */
    select?: znote_paygolSelect<ExtArgs> | null
    /**
     * Filter, which znote_paygol to fetch.
     */
    where?: znote_paygolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_paygols to fetch.
     */
    orderBy?: Enumerable<znote_paygolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_paygols.
     */
    cursor?: znote_paygolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_paygols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_paygols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_paygols.
     */
    distinct?: Enumerable<Znote_paygolScalarFieldEnum>
  }

  /**
   * znote_paygol findFirst
   */
  export interface znote_paygolFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_paygolFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_paygol findFirstOrThrow
   */
  export type znote_paygolFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paygol
     */
    select?: znote_paygolSelect<ExtArgs> | null
    /**
     * Filter, which znote_paygol to fetch.
     */
    where?: znote_paygolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_paygols to fetch.
     */
    orderBy?: Enumerable<znote_paygolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_paygols.
     */
    cursor?: znote_paygolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_paygols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_paygols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_paygols.
     */
    distinct?: Enumerable<Znote_paygolScalarFieldEnum>
  }


  /**
   * znote_paygol findMany
   */
  export type znote_paygolFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paygol
     */
    select?: znote_paygolSelect<ExtArgs> | null
    /**
     * Filter, which znote_paygols to fetch.
     */
    where?: znote_paygolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_paygols to fetch.
     */
    orderBy?: Enumerable<znote_paygolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_paygols.
     */
    cursor?: znote_paygolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_paygols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_paygols.
     */
    skip?: number
    distinct?: Enumerable<Znote_paygolScalarFieldEnum>
  }


  /**
   * znote_paygol create
   */
  export type znote_paygolCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paygol
     */
    select?: znote_paygolSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_paygol.
     */
    data: XOR<znote_paygolCreateInput, znote_paygolUncheckedCreateInput>
  }


  /**
   * znote_paygol createMany
   */
  export type znote_paygolCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_paygols.
     */
    data: Enumerable<znote_paygolCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_paygol update
   */
  export type znote_paygolUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paygol
     */
    select?: znote_paygolSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_paygol.
     */
    data: XOR<znote_paygolUpdateInput, znote_paygolUncheckedUpdateInput>
    /**
     * Choose, which znote_paygol to update.
     */
    where: znote_paygolWhereUniqueInput
  }


  /**
   * znote_paygol updateMany
   */
  export type znote_paygolUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_paygols.
     */
    data: XOR<znote_paygolUpdateManyMutationInput, znote_paygolUncheckedUpdateManyInput>
    /**
     * Filter which znote_paygols to update
     */
    where?: znote_paygolWhereInput
  }


  /**
   * znote_paygol upsert
   */
  export type znote_paygolUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paygol
     */
    select?: znote_paygolSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_paygol to update in case it exists.
     */
    where: znote_paygolWhereUniqueInput
    /**
     * In case the znote_paygol found by the `where` argument doesn't exist, create a new znote_paygol with this data.
     */
    create: XOR<znote_paygolCreateInput, znote_paygolUncheckedCreateInput>
    /**
     * In case the znote_paygol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_paygolUpdateInput, znote_paygolUncheckedUpdateInput>
  }


  /**
   * znote_paygol delete
   */
  export type znote_paygolDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paygol
     */
    select?: znote_paygolSelect<ExtArgs> | null
    /**
     * Filter which znote_paygol to delete.
     */
    where: znote_paygolWhereUniqueInput
  }


  /**
   * znote_paygol deleteMany
   */
  export type znote_paygolDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_paygols to delete
     */
    where?: znote_paygolWhereInput
  }


  /**
   * znote_paygol without action
   */
  export type znote_paygolArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paygol
     */
    select?: znote_paygolSelect<ExtArgs> | null
  }



  /**
   * Model znote_paypal
   */


  export type AggregateZnote_paypal = {
    _count: Znote_paypalCountAggregateOutputType | null
    _avg: Znote_paypalAvgAggregateOutputType | null
    _sum: Znote_paypalSumAggregateOutputType | null
    _min: Znote_paypalMinAggregateOutputType | null
    _max: Znote_paypalMaxAggregateOutputType | null
  }

  export type Znote_paypalAvgAggregateOutputType = {
    id: number | null
    accid: number | null
    price: number | null
    points: number | null
  }

  export type Znote_paypalSumAggregateOutputType = {
    id: number | null
    accid: number | null
    price: number | null
    points: number | null
  }

  export type Znote_paypalMinAggregateOutputType = {
    id: number | null
    txn_id: string | null
    email: string | null
    accid: number | null
    price: number | null
    points: number | null
  }

  export type Znote_paypalMaxAggregateOutputType = {
    id: number | null
    txn_id: string | null
    email: string | null
    accid: number | null
    price: number | null
    points: number | null
  }

  export type Znote_paypalCountAggregateOutputType = {
    id: number
    txn_id: number
    email: number
    accid: number
    price: number
    points: number
    _all: number
  }


  export type Znote_paypalAvgAggregateInputType = {
    id?: true
    accid?: true
    price?: true
    points?: true
  }

  export type Znote_paypalSumAggregateInputType = {
    id?: true
    accid?: true
    price?: true
    points?: true
  }

  export type Znote_paypalMinAggregateInputType = {
    id?: true
    txn_id?: true
    email?: true
    accid?: true
    price?: true
    points?: true
  }

  export type Znote_paypalMaxAggregateInputType = {
    id?: true
    txn_id?: true
    email?: true
    accid?: true
    price?: true
    points?: true
  }

  export type Znote_paypalCountAggregateInputType = {
    id?: true
    txn_id?: true
    email?: true
    accid?: true
    price?: true
    points?: true
    _all?: true
  }

  export type Znote_paypalAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_paypal to aggregate.
     */
    where?: znote_paypalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_paypals to fetch.
     */
    orderBy?: Enumerable<znote_paypalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_paypalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_paypals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_paypals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_paypals
    **/
    _count?: true | Znote_paypalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_paypalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_paypalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_paypalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_paypalMaxAggregateInputType
  }

  export type GetZnote_paypalAggregateType<T extends Znote_paypalAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_paypal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_paypal[P]>
      : GetScalarType<T[P], AggregateZnote_paypal[P]>
  }




  export type Znote_paypalGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_paypalWhereInput
    orderBy?: Enumerable<znote_paypalOrderByWithAggregationInput>
    by: Znote_paypalScalarFieldEnum[]
    having?: znote_paypalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_paypalCountAggregateInputType | true
    _avg?: Znote_paypalAvgAggregateInputType
    _sum?: Znote_paypalSumAggregateInputType
    _min?: Znote_paypalMinAggregateInputType
    _max?: Znote_paypalMaxAggregateInputType
  }


  export type Znote_paypalGroupByOutputType = {
    id: number
    txn_id: string
    email: string
    accid: number
    price: number
    points: number
    _count: Znote_paypalCountAggregateOutputType | null
    _avg: Znote_paypalAvgAggregateOutputType | null
    _sum: Znote_paypalSumAggregateOutputType | null
    _min: Znote_paypalMinAggregateOutputType | null
    _max: Znote_paypalMaxAggregateOutputType | null
  }

  type GetZnote_paypalGroupByPayload<T extends Znote_paypalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_paypalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_paypalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_paypalGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_paypalGroupByOutputType[P]>
        }
      >
    >


  export type znote_paypalSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    txn_id?: boolean
    email?: boolean
    accid?: boolean
    price?: boolean
    points?: boolean
  }, ExtArgs["result"]["znote_paypal"]>

  export type znote_paypalSelectScalar = {
    id?: boolean
    txn_id?: boolean
    email?: boolean
    accid?: boolean
    price?: boolean
    points?: boolean
  }


  type znote_paypalGetPayload<S extends boolean | null | undefined | znote_paypalArgs> = $Types.GetResult<znote_paypalPayload, S>

  type znote_paypalCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_paypalFindManyArgs, 'select' | 'include'> & {
      select?: Znote_paypalCountAggregateInputType | true
    }

  export interface znote_paypalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_paypal'], meta: { name: 'znote_paypal' } }
    /**
     * Find zero or one Znote_paypal that matches the filter.
     * @param {znote_paypalFindUniqueArgs} args - Arguments to find a Znote_paypal
     * @example
     * // Get one Znote_paypal
     * const znote_paypal = await prisma.znote_paypal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_paypalFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_paypalFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_paypal'> extends True ? Prisma__znote_paypalClient<$Types.GetResult<znote_paypalPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_paypalClient<$Types.GetResult<znote_paypalPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_paypal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_paypalFindUniqueOrThrowArgs} args - Arguments to find a Znote_paypal
     * @example
     * // Get one Znote_paypal
     * const znote_paypal = await prisma.znote_paypal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_paypalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_paypalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_paypalClient<$Types.GetResult<znote_paypalPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_paypal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_paypalFindFirstArgs} args - Arguments to find a Znote_paypal
     * @example
     * // Get one Znote_paypal
     * const znote_paypal = await prisma.znote_paypal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_paypalFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_paypalFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_paypal'> extends True ? Prisma__znote_paypalClient<$Types.GetResult<znote_paypalPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_paypalClient<$Types.GetResult<znote_paypalPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_paypal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_paypalFindFirstOrThrowArgs} args - Arguments to find a Znote_paypal
     * @example
     * // Get one Znote_paypal
     * const znote_paypal = await prisma.znote_paypal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_paypalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_paypalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_paypalClient<$Types.GetResult<znote_paypalPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_paypals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_paypalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_paypals
     * const znote_paypals = await prisma.znote_paypal.findMany()
     * 
     * // Get first 10 Znote_paypals
     * const znote_paypals = await prisma.znote_paypal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_paypalWithIdOnly = await prisma.znote_paypal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_paypalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_paypalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_paypalPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_paypal.
     * @param {znote_paypalCreateArgs} args - Arguments to create a Znote_paypal.
     * @example
     * // Create one Znote_paypal
     * const Znote_paypal = await prisma.znote_paypal.create({
     *   data: {
     *     // ... data to create a Znote_paypal
     *   }
     * })
     * 
    **/
    create<T extends znote_paypalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_paypalCreateArgs<ExtArgs>>
    ): Prisma__znote_paypalClient<$Types.GetResult<znote_paypalPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_paypals.
     *     @param {znote_paypalCreateManyArgs} args - Arguments to create many Znote_paypals.
     *     @example
     *     // Create many Znote_paypals
     *     const znote_paypal = await prisma.znote_paypal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_paypalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_paypalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_paypal.
     * @param {znote_paypalDeleteArgs} args - Arguments to delete one Znote_paypal.
     * @example
     * // Delete one Znote_paypal
     * const Znote_paypal = await prisma.znote_paypal.delete({
     *   where: {
     *     // ... filter to delete one Znote_paypal
     *   }
     * })
     * 
    **/
    delete<T extends znote_paypalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_paypalDeleteArgs<ExtArgs>>
    ): Prisma__znote_paypalClient<$Types.GetResult<znote_paypalPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_paypal.
     * @param {znote_paypalUpdateArgs} args - Arguments to update one Znote_paypal.
     * @example
     * // Update one Znote_paypal
     * const znote_paypal = await prisma.znote_paypal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_paypalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_paypalUpdateArgs<ExtArgs>>
    ): Prisma__znote_paypalClient<$Types.GetResult<znote_paypalPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_paypals.
     * @param {znote_paypalDeleteManyArgs} args - Arguments to filter Znote_paypals to delete.
     * @example
     * // Delete a few Znote_paypals
     * const { count } = await prisma.znote_paypal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_paypalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_paypalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_paypals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_paypalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_paypals
     * const znote_paypal = await prisma.znote_paypal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_paypalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_paypalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_paypal.
     * @param {znote_paypalUpsertArgs} args - Arguments to update or create a Znote_paypal.
     * @example
     * // Update or create a Znote_paypal
     * const znote_paypal = await prisma.znote_paypal.upsert({
     *   create: {
     *     // ... data to create a Znote_paypal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_paypal we want to update
     *   }
     * })
    **/
    upsert<T extends znote_paypalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_paypalUpsertArgs<ExtArgs>>
    ): Prisma__znote_paypalClient<$Types.GetResult<znote_paypalPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_paypals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_paypalCountArgs} args - Arguments to filter Znote_paypals to count.
     * @example
     * // Count the number of Znote_paypals
     * const count = await prisma.znote_paypal.count({
     *   where: {
     *     // ... the filter for the Znote_paypals we want to count
     *   }
     * })
    **/
    count<T extends znote_paypalCountArgs>(
      args?: Subset<T, znote_paypalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_paypalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_paypal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_paypalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_paypalAggregateArgs>(args: Subset<T, Znote_paypalAggregateArgs>): Prisma.PrismaPromise<GetZnote_paypalAggregateType<T>>

    /**
     * Group by Znote_paypal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_paypalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_paypalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_paypalGroupByArgs['orderBy'] }
        : { orderBy?: Znote_paypalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_paypalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_paypalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_paypal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_paypalClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_paypal base type for findUnique actions
   */
  export type znote_paypalFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paypal
     */
    select?: znote_paypalSelect<ExtArgs> | null
    /**
     * Filter, which znote_paypal to fetch.
     */
    where: znote_paypalWhereUniqueInput
  }

  /**
   * znote_paypal findUnique
   */
  export interface znote_paypalFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_paypalFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_paypal findUniqueOrThrow
   */
  export type znote_paypalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paypal
     */
    select?: znote_paypalSelect<ExtArgs> | null
    /**
     * Filter, which znote_paypal to fetch.
     */
    where: znote_paypalWhereUniqueInput
  }


  /**
   * znote_paypal base type for findFirst actions
   */
  export type znote_paypalFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paypal
     */
    select?: znote_paypalSelect<ExtArgs> | null
    /**
     * Filter, which znote_paypal to fetch.
     */
    where?: znote_paypalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_paypals to fetch.
     */
    orderBy?: Enumerable<znote_paypalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_paypals.
     */
    cursor?: znote_paypalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_paypals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_paypals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_paypals.
     */
    distinct?: Enumerable<Znote_paypalScalarFieldEnum>
  }

  /**
   * znote_paypal findFirst
   */
  export interface znote_paypalFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_paypalFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_paypal findFirstOrThrow
   */
  export type znote_paypalFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paypal
     */
    select?: znote_paypalSelect<ExtArgs> | null
    /**
     * Filter, which znote_paypal to fetch.
     */
    where?: znote_paypalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_paypals to fetch.
     */
    orderBy?: Enumerable<znote_paypalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_paypals.
     */
    cursor?: znote_paypalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_paypals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_paypals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_paypals.
     */
    distinct?: Enumerable<Znote_paypalScalarFieldEnum>
  }


  /**
   * znote_paypal findMany
   */
  export type znote_paypalFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paypal
     */
    select?: znote_paypalSelect<ExtArgs> | null
    /**
     * Filter, which znote_paypals to fetch.
     */
    where?: znote_paypalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_paypals to fetch.
     */
    orderBy?: Enumerable<znote_paypalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_paypals.
     */
    cursor?: znote_paypalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_paypals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_paypals.
     */
    skip?: number
    distinct?: Enumerable<Znote_paypalScalarFieldEnum>
  }


  /**
   * znote_paypal create
   */
  export type znote_paypalCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paypal
     */
    select?: znote_paypalSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_paypal.
     */
    data: XOR<znote_paypalCreateInput, znote_paypalUncheckedCreateInput>
  }


  /**
   * znote_paypal createMany
   */
  export type znote_paypalCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_paypals.
     */
    data: Enumerable<znote_paypalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_paypal update
   */
  export type znote_paypalUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paypal
     */
    select?: znote_paypalSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_paypal.
     */
    data: XOR<znote_paypalUpdateInput, znote_paypalUncheckedUpdateInput>
    /**
     * Choose, which znote_paypal to update.
     */
    where: znote_paypalWhereUniqueInput
  }


  /**
   * znote_paypal updateMany
   */
  export type znote_paypalUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_paypals.
     */
    data: XOR<znote_paypalUpdateManyMutationInput, znote_paypalUncheckedUpdateManyInput>
    /**
     * Filter which znote_paypals to update
     */
    where?: znote_paypalWhereInput
  }


  /**
   * znote_paypal upsert
   */
  export type znote_paypalUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paypal
     */
    select?: znote_paypalSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_paypal to update in case it exists.
     */
    where: znote_paypalWhereUniqueInput
    /**
     * In case the znote_paypal found by the `where` argument doesn't exist, create a new znote_paypal with this data.
     */
    create: XOR<znote_paypalCreateInput, znote_paypalUncheckedCreateInput>
    /**
     * In case the znote_paypal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_paypalUpdateInput, znote_paypalUncheckedUpdateInput>
  }


  /**
   * znote_paypal delete
   */
  export type znote_paypalDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paypal
     */
    select?: znote_paypalSelect<ExtArgs> | null
    /**
     * Filter which znote_paypal to delete.
     */
    where: znote_paypalWhereUniqueInput
  }


  /**
   * znote_paypal deleteMany
   */
  export type znote_paypalDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_paypals to delete
     */
    where?: znote_paypalWhereInput
  }


  /**
   * znote_paypal without action
   */
  export type znote_paypalArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_paypal
     */
    select?: znote_paypalSelect<ExtArgs> | null
  }



  /**
   * Model znote_player_reports
   */


  export type AggregateZnote_player_reports = {
    _count: Znote_player_reportsCountAggregateOutputType | null
    _avg: Znote_player_reportsAvgAggregateOutputType | null
    _sum: Znote_player_reportsSumAggregateOutputType | null
    _min: Znote_player_reportsMinAggregateOutputType | null
    _max: Znote_player_reportsMaxAggregateOutputType | null
  }

  export type Znote_player_reportsAvgAggregateOutputType = {
    id: number | null
    posx: number | null
    posy: number | null
    posz: number | null
    date: number | null
    status: number | null
  }

  export type Znote_player_reportsSumAggregateOutputType = {
    id: number | null
    posx: number | null
    posy: number | null
    posz: number | null
    date: number | null
    status: number | null
  }

  export type Znote_player_reportsMinAggregateOutputType = {
    id: number | null
    name: string | null
    posx: number | null
    posy: number | null
    posz: number | null
    report_description: string | null
    date: number | null
    status: number | null
  }

  export type Znote_player_reportsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    posx: number | null
    posy: number | null
    posz: number | null
    report_description: string | null
    date: number | null
    status: number | null
  }

  export type Znote_player_reportsCountAggregateOutputType = {
    id: number
    name: number
    posx: number
    posy: number
    posz: number
    report_description: number
    date: number
    status: number
    _all: number
  }


  export type Znote_player_reportsAvgAggregateInputType = {
    id?: true
    posx?: true
    posy?: true
    posz?: true
    date?: true
    status?: true
  }

  export type Znote_player_reportsSumAggregateInputType = {
    id?: true
    posx?: true
    posy?: true
    posz?: true
    date?: true
    status?: true
  }

  export type Znote_player_reportsMinAggregateInputType = {
    id?: true
    name?: true
    posx?: true
    posy?: true
    posz?: true
    report_description?: true
    date?: true
    status?: true
  }

  export type Znote_player_reportsMaxAggregateInputType = {
    id?: true
    name?: true
    posx?: true
    posy?: true
    posz?: true
    report_description?: true
    date?: true
    status?: true
  }

  export type Znote_player_reportsCountAggregateInputType = {
    id?: true
    name?: true
    posx?: true
    posy?: true
    posz?: true
    report_description?: true
    date?: true
    status?: true
    _all?: true
  }

  export type Znote_player_reportsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_player_reports to aggregate.
     */
    where?: znote_player_reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_player_reports to fetch.
     */
    orderBy?: Enumerable<znote_player_reportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_player_reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_player_reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_player_reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_player_reports
    **/
    _count?: true | Znote_player_reportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_player_reportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_player_reportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_player_reportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_player_reportsMaxAggregateInputType
  }

  export type GetZnote_player_reportsAggregateType<T extends Znote_player_reportsAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_player_reports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_player_reports[P]>
      : GetScalarType<T[P], AggregateZnote_player_reports[P]>
  }




  export type Znote_player_reportsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_player_reportsWhereInput
    orderBy?: Enumerable<znote_player_reportsOrderByWithAggregationInput>
    by: Znote_player_reportsScalarFieldEnum[]
    having?: znote_player_reportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_player_reportsCountAggregateInputType | true
    _avg?: Znote_player_reportsAvgAggregateInputType
    _sum?: Znote_player_reportsSumAggregateInputType
    _min?: Znote_player_reportsMinAggregateInputType
    _max?: Znote_player_reportsMaxAggregateInputType
  }


  export type Znote_player_reportsGroupByOutputType = {
    id: number
    name: string
    posx: number
    posy: number
    posz: number
    report_description: string
    date: number
    status: number
    _count: Znote_player_reportsCountAggregateOutputType | null
    _avg: Znote_player_reportsAvgAggregateOutputType | null
    _sum: Znote_player_reportsSumAggregateOutputType | null
    _min: Znote_player_reportsMinAggregateOutputType | null
    _max: Znote_player_reportsMaxAggregateOutputType | null
  }

  type GetZnote_player_reportsGroupByPayload<T extends Znote_player_reportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_player_reportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_player_reportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_player_reportsGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_player_reportsGroupByOutputType[P]>
        }
      >
    >


  export type znote_player_reportsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    posx?: boolean
    posy?: boolean
    posz?: boolean
    report_description?: boolean
    date?: boolean
    status?: boolean
  }, ExtArgs["result"]["znote_player_reports"]>

  export type znote_player_reportsSelectScalar = {
    id?: boolean
    name?: boolean
    posx?: boolean
    posy?: boolean
    posz?: boolean
    report_description?: boolean
    date?: boolean
    status?: boolean
  }


  type znote_player_reportsGetPayload<S extends boolean | null | undefined | znote_player_reportsArgs> = $Types.GetResult<znote_player_reportsPayload, S>

  type znote_player_reportsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_player_reportsFindManyArgs, 'select' | 'include'> & {
      select?: Znote_player_reportsCountAggregateInputType | true
    }

  export interface znote_player_reportsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_player_reports'], meta: { name: 'znote_player_reports' } }
    /**
     * Find zero or one Znote_player_reports that matches the filter.
     * @param {znote_player_reportsFindUniqueArgs} args - Arguments to find a Znote_player_reports
     * @example
     * // Get one Znote_player_reports
     * const znote_player_reports = await prisma.znote_player_reports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_player_reportsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_player_reportsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_player_reports'> extends True ? Prisma__znote_player_reportsClient<$Types.GetResult<znote_player_reportsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_player_reportsClient<$Types.GetResult<znote_player_reportsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_player_reports that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_player_reportsFindUniqueOrThrowArgs} args - Arguments to find a Znote_player_reports
     * @example
     * // Get one Znote_player_reports
     * const znote_player_reports = await prisma.znote_player_reports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_player_reportsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_player_reportsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_player_reportsClient<$Types.GetResult<znote_player_reportsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_player_reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_player_reportsFindFirstArgs} args - Arguments to find a Znote_player_reports
     * @example
     * // Get one Znote_player_reports
     * const znote_player_reports = await prisma.znote_player_reports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_player_reportsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_player_reportsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_player_reports'> extends True ? Prisma__znote_player_reportsClient<$Types.GetResult<znote_player_reportsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_player_reportsClient<$Types.GetResult<znote_player_reportsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_player_reports that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_player_reportsFindFirstOrThrowArgs} args - Arguments to find a Znote_player_reports
     * @example
     * // Get one Znote_player_reports
     * const znote_player_reports = await prisma.znote_player_reports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_player_reportsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_player_reportsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_player_reportsClient<$Types.GetResult<znote_player_reportsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_player_reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_player_reportsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_player_reports
     * const znote_player_reports = await prisma.znote_player_reports.findMany()
     * 
     * // Get first 10 Znote_player_reports
     * const znote_player_reports = await prisma.znote_player_reports.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_player_reportsWithIdOnly = await prisma.znote_player_reports.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_player_reportsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_player_reportsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_player_reportsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_player_reports.
     * @param {znote_player_reportsCreateArgs} args - Arguments to create a Znote_player_reports.
     * @example
     * // Create one Znote_player_reports
     * const Znote_player_reports = await prisma.znote_player_reports.create({
     *   data: {
     *     // ... data to create a Znote_player_reports
     *   }
     * })
     * 
    **/
    create<T extends znote_player_reportsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_player_reportsCreateArgs<ExtArgs>>
    ): Prisma__znote_player_reportsClient<$Types.GetResult<znote_player_reportsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_player_reports.
     *     @param {znote_player_reportsCreateManyArgs} args - Arguments to create many Znote_player_reports.
     *     @example
     *     // Create many Znote_player_reports
     *     const znote_player_reports = await prisma.znote_player_reports.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_player_reportsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_player_reportsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_player_reports.
     * @param {znote_player_reportsDeleteArgs} args - Arguments to delete one Znote_player_reports.
     * @example
     * // Delete one Znote_player_reports
     * const Znote_player_reports = await prisma.znote_player_reports.delete({
     *   where: {
     *     // ... filter to delete one Znote_player_reports
     *   }
     * })
     * 
    **/
    delete<T extends znote_player_reportsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_player_reportsDeleteArgs<ExtArgs>>
    ): Prisma__znote_player_reportsClient<$Types.GetResult<znote_player_reportsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_player_reports.
     * @param {znote_player_reportsUpdateArgs} args - Arguments to update one Znote_player_reports.
     * @example
     * // Update one Znote_player_reports
     * const znote_player_reports = await prisma.znote_player_reports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_player_reportsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_player_reportsUpdateArgs<ExtArgs>>
    ): Prisma__znote_player_reportsClient<$Types.GetResult<znote_player_reportsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_player_reports.
     * @param {znote_player_reportsDeleteManyArgs} args - Arguments to filter Znote_player_reports to delete.
     * @example
     * // Delete a few Znote_player_reports
     * const { count } = await prisma.znote_player_reports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_player_reportsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_player_reportsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_player_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_player_reportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_player_reports
     * const znote_player_reports = await prisma.znote_player_reports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_player_reportsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_player_reportsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_player_reports.
     * @param {znote_player_reportsUpsertArgs} args - Arguments to update or create a Znote_player_reports.
     * @example
     * // Update or create a Znote_player_reports
     * const znote_player_reports = await prisma.znote_player_reports.upsert({
     *   create: {
     *     // ... data to create a Znote_player_reports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_player_reports we want to update
     *   }
     * })
    **/
    upsert<T extends znote_player_reportsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_player_reportsUpsertArgs<ExtArgs>>
    ): Prisma__znote_player_reportsClient<$Types.GetResult<znote_player_reportsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_player_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_player_reportsCountArgs} args - Arguments to filter Znote_player_reports to count.
     * @example
     * // Count the number of Znote_player_reports
     * const count = await prisma.znote_player_reports.count({
     *   where: {
     *     // ... the filter for the Znote_player_reports we want to count
     *   }
     * })
    **/
    count<T extends znote_player_reportsCountArgs>(
      args?: Subset<T, znote_player_reportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_player_reportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_player_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_player_reportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_player_reportsAggregateArgs>(args: Subset<T, Znote_player_reportsAggregateArgs>): Prisma.PrismaPromise<GetZnote_player_reportsAggregateType<T>>

    /**
     * Group by Znote_player_reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_player_reportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_player_reportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_player_reportsGroupByArgs['orderBy'] }
        : { orderBy?: Znote_player_reportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_player_reportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_player_reportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_player_reports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_player_reportsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_player_reports base type for findUnique actions
   */
  export type znote_player_reportsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_player_reports
     */
    select?: znote_player_reportsSelect<ExtArgs> | null
    /**
     * Filter, which znote_player_reports to fetch.
     */
    where: znote_player_reportsWhereUniqueInput
  }

  /**
   * znote_player_reports findUnique
   */
  export interface znote_player_reportsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_player_reportsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_player_reports findUniqueOrThrow
   */
  export type znote_player_reportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_player_reports
     */
    select?: znote_player_reportsSelect<ExtArgs> | null
    /**
     * Filter, which znote_player_reports to fetch.
     */
    where: znote_player_reportsWhereUniqueInput
  }


  /**
   * znote_player_reports base type for findFirst actions
   */
  export type znote_player_reportsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_player_reports
     */
    select?: znote_player_reportsSelect<ExtArgs> | null
    /**
     * Filter, which znote_player_reports to fetch.
     */
    where?: znote_player_reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_player_reports to fetch.
     */
    orderBy?: Enumerable<znote_player_reportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_player_reports.
     */
    cursor?: znote_player_reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_player_reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_player_reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_player_reports.
     */
    distinct?: Enumerable<Znote_player_reportsScalarFieldEnum>
  }

  /**
   * znote_player_reports findFirst
   */
  export interface znote_player_reportsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_player_reportsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_player_reports findFirstOrThrow
   */
  export type znote_player_reportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_player_reports
     */
    select?: znote_player_reportsSelect<ExtArgs> | null
    /**
     * Filter, which znote_player_reports to fetch.
     */
    where?: znote_player_reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_player_reports to fetch.
     */
    orderBy?: Enumerable<znote_player_reportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_player_reports.
     */
    cursor?: znote_player_reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_player_reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_player_reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_player_reports.
     */
    distinct?: Enumerable<Znote_player_reportsScalarFieldEnum>
  }


  /**
   * znote_player_reports findMany
   */
  export type znote_player_reportsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_player_reports
     */
    select?: znote_player_reportsSelect<ExtArgs> | null
    /**
     * Filter, which znote_player_reports to fetch.
     */
    where?: znote_player_reportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_player_reports to fetch.
     */
    orderBy?: Enumerable<znote_player_reportsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_player_reports.
     */
    cursor?: znote_player_reportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_player_reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_player_reports.
     */
    skip?: number
    distinct?: Enumerable<Znote_player_reportsScalarFieldEnum>
  }


  /**
   * znote_player_reports create
   */
  export type znote_player_reportsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_player_reports
     */
    select?: znote_player_reportsSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_player_reports.
     */
    data: XOR<znote_player_reportsCreateInput, znote_player_reportsUncheckedCreateInput>
  }


  /**
   * znote_player_reports createMany
   */
  export type znote_player_reportsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_player_reports.
     */
    data: Enumerable<znote_player_reportsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_player_reports update
   */
  export type znote_player_reportsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_player_reports
     */
    select?: znote_player_reportsSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_player_reports.
     */
    data: XOR<znote_player_reportsUpdateInput, znote_player_reportsUncheckedUpdateInput>
    /**
     * Choose, which znote_player_reports to update.
     */
    where: znote_player_reportsWhereUniqueInput
  }


  /**
   * znote_player_reports updateMany
   */
  export type znote_player_reportsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_player_reports.
     */
    data: XOR<znote_player_reportsUpdateManyMutationInput, znote_player_reportsUncheckedUpdateManyInput>
    /**
     * Filter which znote_player_reports to update
     */
    where?: znote_player_reportsWhereInput
  }


  /**
   * znote_player_reports upsert
   */
  export type znote_player_reportsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_player_reports
     */
    select?: znote_player_reportsSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_player_reports to update in case it exists.
     */
    where: znote_player_reportsWhereUniqueInput
    /**
     * In case the znote_player_reports found by the `where` argument doesn't exist, create a new znote_player_reports with this data.
     */
    create: XOR<znote_player_reportsCreateInput, znote_player_reportsUncheckedCreateInput>
    /**
     * In case the znote_player_reports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_player_reportsUpdateInput, znote_player_reportsUncheckedUpdateInput>
  }


  /**
   * znote_player_reports delete
   */
  export type znote_player_reportsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_player_reports
     */
    select?: znote_player_reportsSelect<ExtArgs> | null
    /**
     * Filter which znote_player_reports to delete.
     */
    where: znote_player_reportsWhereUniqueInput
  }


  /**
   * znote_player_reports deleteMany
   */
  export type znote_player_reportsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_player_reports to delete
     */
    where?: znote_player_reportsWhereInput
  }


  /**
   * znote_player_reports without action
   */
  export type znote_player_reportsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_player_reports
     */
    select?: znote_player_reportsSelect<ExtArgs> | null
  }



  /**
   * Model znote_players
   */


  export type AggregateZnote_players = {
    _count: Znote_playersCountAggregateOutputType | null
    _avg: Znote_playersAvgAggregateOutputType | null
    _sum: Znote_playersSumAggregateOutputType | null
    _min: Znote_playersMinAggregateOutputType | null
    _max: Znote_playersMaxAggregateOutputType | null
  }

  export type Znote_playersAvgAggregateOutputType = {
    id: number | null
    player_id: number | null
    created: number | null
    hide_char: number | null
  }

  export type Znote_playersSumAggregateOutputType = {
    id: number | null
    player_id: number | null
    created: number | null
    hide_char: number | null
  }

  export type Znote_playersMinAggregateOutputType = {
    id: number | null
    player_id: number | null
    created: number | null
    hide_char: number | null
    comment: string | null
  }

  export type Znote_playersMaxAggregateOutputType = {
    id: number | null
    player_id: number | null
    created: number | null
    hide_char: number | null
    comment: string | null
  }

  export type Znote_playersCountAggregateOutputType = {
    id: number
    player_id: number
    created: number
    hide_char: number
    comment: number
    _all: number
  }


  export type Znote_playersAvgAggregateInputType = {
    id?: true
    player_id?: true
    created?: true
    hide_char?: true
  }

  export type Znote_playersSumAggregateInputType = {
    id?: true
    player_id?: true
    created?: true
    hide_char?: true
  }

  export type Znote_playersMinAggregateInputType = {
    id?: true
    player_id?: true
    created?: true
    hide_char?: true
    comment?: true
  }

  export type Znote_playersMaxAggregateInputType = {
    id?: true
    player_id?: true
    created?: true
    hide_char?: true
    comment?: true
  }

  export type Znote_playersCountAggregateInputType = {
    id?: true
    player_id?: true
    created?: true
    hide_char?: true
    comment?: true
    _all?: true
  }

  export type Znote_playersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_players to aggregate.
     */
    where?: znote_playersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_players to fetch.
     */
    orderBy?: Enumerable<znote_playersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_playersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_players
    **/
    _count?: true | Znote_playersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_playersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_playersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_playersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_playersMaxAggregateInputType
  }

  export type GetZnote_playersAggregateType<T extends Znote_playersAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_players]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_players[P]>
      : GetScalarType<T[P], AggregateZnote_players[P]>
  }




  export type Znote_playersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_playersWhereInput
    orderBy?: Enumerable<znote_playersOrderByWithAggregationInput>
    by: Znote_playersScalarFieldEnum[]
    having?: znote_playersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_playersCountAggregateInputType | true
    _avg?: Znote_playersAvgAggregateInputType
    _sum?: Znote_playersSumAggregateInputType
    _min?: Znote_playersMinAggregateInputType
    _max?: Znote_playersMaxAggregateInputType
  }


  export type Znote_playersGroupByOutputType = {
    id: number
    player_id: number
    created: number
    hide_char: number
    comment: string
    _count: Znote_playersCountAggregateOutputType | null
    _avg: Znote_playersAvgAggregateOutputType | null
    _sum: Znote_playersSumAggregateOutputType | null
    _min: Znote_playersMinAggregateOutputType | null
    _max: Znote_playersMaxAggregateOutputType | null
  }

  type GetZnote_playersGroupByPayload<T extends Znote_playersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_playersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_playersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_playersGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_playersGroupByOutputType[P]>
        }
      >
    >


  export type znote_playersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    player_id?: boolean
    created?: boolean
    hide_char?: boolean
    comment?: boolean
  }, ExtArgs["result"]["znote_players"]>

  export type znote_playersSelectScalar = {
    id?: boolean
    player_id?: boolean
    created?: boolean
    hide_char?: boolean
    comment?: boolean
  }


  type znote_playersGetPayload<S extends boolean | null | undefined | znote_playersArgs> = $Types.GetResult<znote_playersPayload, S>

  type znote_playersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_playersFindManyArgs, 'select' | 'include'> & {
      select?: Znote_playersCountAggregateInputType | true
    }

  export interface znote_playersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_players'], meta: { name: 'znote_players' } }
    /**
     * Find zero or one Znote_players that matches the filter.
     * @param {znote_playersFindUniqueArgs} args - Arguments to find a Znote_players
     * @example
     * // Get one Znote_players
     * const znote_players = await prisma.znote_players.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_playersFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_playersFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_players'> extends True ? Prisma__znote_playersClient<$Types.GetResult<znote_playersPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_playersClient<$Types.GetResult<znote_playersPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_players that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_playersFindUniqueOrThrowArgs} args - Arguments to find a Znote_players
     * @example
     * // Get one Znote_players
     * const znote_players = await prisma.znote_players.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_playersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_playersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_playersClient<$Types.GetResult<znote_playersPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_playersFindFirstArgs} args - Arguments to find a Znote_players
     * @example
     * // Get one Znote_players
     * const znote_players = await prisma.znote_players.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_playersFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_playersFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_players'> extends True ? Prisma__znote_playersClient<$Types.GetResult<znote_playersPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_playersClient<$Types.GetResult<znote_playersPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_players that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_playersFindFirstOrThrowArgs} args - Arguments to find a Znote_players
     * @example
     * // Get one Znote_players
     * const znote_players = await prisma.znote_players.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_playersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_playersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_playersClient<$Types.GetResult<znote_playersPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_playersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_players
     * const znote_players = await prisma.znote_players.findMany()
     * 
     * // Get first 10 Znote_players
     * const znote_players = await prisma.znote_players.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_playersWithIdOnly = await prisma.znote_players.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_playersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_playersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_playersPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_players.
     * @param {znote_playersCreateArgs} args - Arguments to create a Znote_players.
     * @example
     * // Create one Znote_players
     * const Znote_players = await prisma.znote_players.create({
     *   data: {
     *     // ... data to create a Znote_players
     *   }
     * })
     * 
    **/
    create<T extends znote_playersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_playersCreateArgs<ExtArgs>>
    ): Prisma__znote_playersClient<$Types.GetResult<znote_playersPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_players.
     *     @param {znote_playersCreateManyArgs} args - Arguments to create many Znote_players.
     *     @example
     *     // Create many Znote_players
     *     const znote_players = await prisma.znote_players.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_playersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_playersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_players.
     * @param {znote_playersDeleteArgs} args - Arguments to delete one Znote_players.
     * @example
     * // Delete one Znote_players
     * const Znote_players = await prisma.znote_players.delete({
     *   where: {
     *     // ... filter to delete one Znote_players
     *   }
     * })
     * 
    **/
    delete<T extends znote_playersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_playersDeleteArgs<ExtArgs>>
    ): Prisma__znote_playersClient<$Types.GetResult<znote_playersPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_players.
     * @param {znote_playersUpdateArgs} args - Arguments to update one Znote_players.
     * @example
     * // Update one Znote_players
     * const znote_players = await prisma.znote_players.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_playersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_playersUpdateArgs<ExtArgs>>
    ): Prisma__znote_playersClient<$Types.GetResult<znote_playersPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_players.
     * @param {znote_playersDeleteManyArgs} args - Arguments to filter Znote_players to delete.
     * @example
     * // Delete a few Znote_players
     * const { count } = await prisma.znote_players.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_playersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_playersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_playersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_players
     * const znote_players = await prisma.znote_players.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_playersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_playersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_players.
     * @param {znote_playersUpsertArgs} args - Arguments to update or create a Znote_players.
     * @example
     * // Update or create a Znote_players
     * const znote_players = await prisma.znote_players.upsert({
     *   create: {
     *     // ... data to create a Znote_players
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_players we want to update
     *   }
     * })
    **/
    upsert<T extends znote_playersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_playersUpsertArgs<ExtArgs>>
    ): Prisma__znote_playersClient<$Types.GetResult<znote_playersPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_playersCountArgs} args - Arguments to filter Znote_players to count.
     * @example
     * // Count the number of Znote_players
     * const count = await prisma.znote_players.count({
     *   where: {
     *     // ... the filter for the Znote_players we want to count
     *   }
     * })
    **/
    count<T extends znote_playersCountArgs>(
      args?: Subset<T, znote_playersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_playersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_playersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_playersAggregateArgs>(args: Subset<T, Znote_playersAggregateArgs>): Prisma.PrismaPromise<GetZnote_playersAggregateType<T>>

    /**
     * Group by Znote_players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_playersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_playersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_playersGroupByArgs['orderBy'] }
        : { orderBy?: Znote_playersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_playersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_playersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_players.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_playersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_players base type for findUnique actions
   */
  export type znote_playersFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_players
     */
    select?: znote_playersSelect<ExtArgs> | null
    /**
     * Filter, which znote_players to fetch.
     */
    where: znote_playersWhereUniqueInput
  }

  /**
   * znote_players findUnique
   */
  export interface znote_playersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_playersFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_players findUniqueOrThrow
   */
  export type znote_playersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_players
     */
    select?: znote_playersSelect<ExtArgs> | null
    /**
     * Filter, which znote_players to fetch.
     */
    where: znote_playersWhereUniqueInput
  }


  /**
   * znote_players base type for findFirst actions
   */
  export type znote_playersFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_players
     */
    select?: znote_playersSelect<ExtArgs> | null
    /**
     * Filter, which znote_players to fetch.
     */
    where?: znote_playersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_players to fetch.
     */
    orderBy?: Enumerable<znote_playersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_players.
     */
    cursor?: znote_playersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_players.
     */
    distinct?: Enumerable<Znote_playersScalarFieldEnum>
  }

  /**
   * znote_players findFirst
   */
  export interface znote_playersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_playersFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_players findFirstOrThrow
   */
  export type znote_playersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_players
     */
    select?: znote_playersSelect<ExtArgs> | null
    /**
     * Filter, which znote_players to fetch.
     */
    where?: znote_playersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_players to fetch.
     */
    orderBy?: Enumerable<znote_playersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_players.
     */
    cursor?: znote_playersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_players.
     */
    distinct?: Enumerable<Znote_playersScalarFieldEnum>
  }


  /**
   * znote_players findMany
   */
  export type znote_playersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_players
     */
    select?: znote_playersSelect<ExtArgs> | null
    /**
     * Filter, which znote_players to fetch.
     */
    where?: znote_playersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_players to fetch.
     */
    orderBy?: Enumerable<znote_playersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_players.
     */
    cursor?: znote_playersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_players.
     */
    skip?: number
    distinct?: Enumerable<Znote_playersScalarFieldEnum>
  }


  /**
   * znote_players create
   */
  export type znote_playersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_players
     */
    select?: znote_playersSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_players.
     */
    data: XOR<znote_playersCreateInput, znote_playersUncheckedCreateInput>
  }


  /**
   * znote_players createMany
   */
  export type znote_playersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_players.
     */
    data: Enumerable<znote_playersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_players update
   */
  export type znote_playersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_players
     */
    select?: znote_playersSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_players.
     */
    data: XOR<znote_playersUpdateInput, znote_playersUncheckedUpdateInput>
    /**
     * Choose, which znote_players to update.
     */
    where: znote_playersWhereUniqueInput
  }


  /**
   * znote_players updateMany
   */
  export type znote_playersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_players.
     */
    data: XOR<znote_playersUpdateManyMutationInput, znote_playersUncheckedUpdateManyInput>
    /**
     * Filter which znote_players to update
     */
    where?: znote_playersWhereInput
  }


  /**
   * znote_players upsert
   */
  export type znote_playersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_players
     */
    select?: znote_playersSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_players to update in case it exists.
     */
    where: znote_playersWhereUniqueInput
    /**
     * In case the znote_players found by the `where` argument doesn't exist, create a new znote_players with this data.
     */
    create: XOR<znote_playersCreateInput, znote_playersUncheckedCreateInput>
    /**
     * In case the znote_players was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_playersUpdateInput, znote_playersUncheckedUpdateInput>
  }


  /**
   * znote_players delete
   */
  export type znote_playersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_players
     */
    select?: znote_playersSelect<ExtArgs> | null
    /**
     * Filter which znote_players to delete.
     */
    where: znote_playersWhereUniqueInput
  }


  /**
   * znote_players deleteMany
   */
  export type znote_playersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_players to delete
     */
    where?: znote_playersWhereInput
  }


  /**
   * znote_players without action
   */
  export type znote_playersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_players
     */
    select?: znote_playersSelect<ExtArgs> | null
  }



  /**
   * Model znote_shop
   */


  export type AggregateZnote_shop = {
    _count: Znote_shopCountAggregateOutputType | null
    _avg: Znote_shopAvgAggregateOutputType | null
    _sum: Znote_shopSumAggregateOutputType | null
    _min: Znote_shopMinAggregateOutputType | null
    _max: Znote_shopMaxAggregateOutputType | null
  }

  export type Znote_shopAvgAggregateOutputType = {
    id: number | null
    type: number | null
    itemid: number | null
    count: number | null
    points: number | null
  }

  export type Znote_shopSumAggregateOutputType = {
    id: number | null
    type: number | null
    itemid: number | null
    count: number | null
    points: number | null
  }

  export type Znote_shopMinAggregateOutputType = {
    id: number | null
    type: number | null
    itemid: number | null
    count: number | null
    description: string | null
    points: number | null
  }

  export type Znote_shopMaxAggregateOutputType = {
    id: number | null
    type: number | null
    itemid: number | null
    count: number | null
    description: string | null
    points: number | null
  }

  export type Znote_shopCountAggregateOutputType = {
    id: number
    type: number
    itemid: number
    count: number
    description: number
    points: number
    _all: number
  }


  export type Znote_shopAvgAggregateInputType = {
    id?: true
    type?: true
    itemid?: true
    count?: true
    points?: true
  }

  export type Znote_shopSumAggregateInputType = {
    id?: true
    type?: true
    itemid?: true
    count?: true
    points?: true
  }

  export type Znote_shopMinAggregateInputType = {
    id?: true
    type?: true
    itemid?: true
    count?: true
    description?: true
    points?: true
  }

  export type Znote_shopMaxAggregateInputType = {
    id?: true
    type?: true
    itemid?: true
    count?: true
    description?: true
    points?: true
  }

  export type Znote_shopCountAggregateInputType = {
    id?: true
    type?: true
    itemid?: true
    count?: true
    description?: true
    points?: true
    _all?: true
  }

  export type Znote_shopAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_shop to aggregate.
     */
    where?: znote_shopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_shops to fetch.
     */
    orderBy?: Enumerable<znote_shopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_shopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_shops
    **/
    _count?: true | Znote_shopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_shopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_shopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_shopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_shopMaxAggregateInputType
  }

  export type GetZnote_shopAggregateType<T extends Znote_shopAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_shop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_shop[P]>
      : GetScalarType<T[P], AggregateZnote_shop[P]>
  }




  export type Znote_shopGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_shopWhereInput
    orderBy?: Enumerable<znote_shopOrderByWithAggregationInput>
    by: Znote_shopScalarFieldEnum[]
    having?: znote_shopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_shopCountAggregateInputType | true
    _avg?: Znote_shopAvgAggregateInputType
    _sum?: Znote_shopSumAggregateInputType
    _min?: Znote_shopMinAggregateInputType
    _max?: Znote_shopMaxAggregateInputType
  }


  export type Znote_shopGroupByOutputType = {
    id: number
    type: number
    itemid: number | null
    count: number
    description: string
    points: number
    _count: Znote_shopCountAggregateOutputType | null
    _avg: Znote_shopAvgAggregateOutputType | null
    _sum: Znote_shopSumAggregateOutputType | null
    _min: Znote_shopMinAggregateOutputType | null
    _max: Znote_shopMaxAggregateOutputType | null
  }

  type GetZnote_shopGroupByPayload<T extends Znote_shopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_shopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_shopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_shopGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_shopGroupByOutputType[P]>
        }
      >
    >


  export type znote_shopSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    itemid?: boolean
    count?: boolean
    description?: boolean
    points?: boolean
  }, ExtArgs["result"]["znote_shop"]>

  export type znote_shopSelectScalar = {
    id?: boolean
    type?: boolean
    itemid?: boolean
    count?: boolean
    description?: boolean
    points?: boolean
  }


  type znote_shopGetPayload<S extends boolean | null | undefined | znote_shopArgs> = $Types.GetResult<znote_shopPayload, S>

  type znote_shopCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_shopFindManyArgs, 'select' | 'include'> & {
      select?: Znote_shopCountAggregateInputType | true
    }

  export interface znote_shopDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_shop'], meta: { name: 'znote_shop' } }
    /**
     * Find zero or one Znote_shop that matches the filter.
     * @param {znote_shopFindUniqueArgs} args - Arguments to find a Znote_shop
     * @example
     * // Get one Znote_shop
     * const znote_shop = await prisma.znote_shop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_shopFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_shopFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_shop'> extends True ? Prisma__znote_shopClient<$Types.GetResult<znote_shopPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_shopClient<$Types.GetResult<znote_shopPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_shop that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_shopFindUniqueOrThrowArgs} args - Arguments to find a Znote_shop
     * @example
     * // Get one Znote_shop
     * const znote_shop = await prisma.znote_shop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_shopFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shopFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_shopClient<$Types.GetResult<znote_shopPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_shop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shopFindFirstArgs} args - Arguments to find a Znote_shop
     * @example
     * // Get one Znote_shop
     * const znote_shop = await prisma.znote_shop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_shopFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_shopFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_shop'> extends True ? Prisma__znote_shopClient<$Types.GetResult<znote_shopPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_shopClient<$Types.GetResult<znote_shopPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_shop that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shopFindFirstOrThrowArgs} args - Arguments to find a Znote_shop
     * @example
     * // Get one Znote_shop
     * const znote_shop = await prisma.znote_shop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_shopFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shopFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_shopClient<$Types.GetResult<znote_shopPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_shops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shopFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_shops
     * const znote_shops = await prisma.znote_shop.findMany()
     * 
     * // Get first 10 Znote_shops
     * const znote_shops = await prisma.znote_shop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_shopWithIdOnly = await prisma.znote_shop.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_shopFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shopFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_shopPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_shop.
     * @param {znote_shopCreateArgs} args - Arguments to create a Znote_shop.
     * @example
     * // Create one Znote_shop
     * const Znote_shop = await prisma.znote_shop.create({
     *   data: {
     *     // ... data to create a Znote_shop
     *   }
     * })
     * 
    **/
    create<T extends znote_shopCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shopCreateArgs<ExtArgs>>
    ): Prisma__znote_shopClient<$Types.GetResult<znote_shopPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_shops.
     *     @param {znote_shopCreateManyArgs} args - Arguments to create many Znote_shops.
     *     @example
     *     // Create many Znote_shops
     *     const znote_shop = await prisma.znote_shop.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_shopCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shopCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_shop.
     * @param {znote_shopDeleteArgs} args - Arguments to delete one Znote_shop.
     * @example
     * // Delete one Znote_shop
     * const Znote_shop = await prisma.znote_shop.delete({
     *   where: {
     *     // ... filter to delete one Znote_shop
     *   }
     * })
     * 
    **/
    delete<T extends znote_shopDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shopDeleteArgs<ExtArgs>>
    ): Prisma__znote_shopClient<$Types.GetResult<znote_shopPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_shop.
     * @param {znote_shopUpdateArgs} args - Arguments to update one Znote_shop.
     * @example
     * // Update one Znote_shop
     * const znote_shop = await prisma.znote_shop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_shopUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shopUpdateArgs<ExtArgs>>
    ): Prisma__znote_shopClient<$Types.GetResult<znote_shopPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_shops.
     * @param {znote_shopDeleteManyArgs} args - Arguments to filter Znote_shops to delete.
     * @example
     * // Delete a few Znote_shops
     * const { count } = await prisma.znote_shop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_shopDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shopDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_shops
     * const znote_shop = await prisma.znote_shop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_shopUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shopUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_shop.
     * @param {znote_shopUpsertArgs} args - Arguments to update or create a Znote_shop.
     * @example
     * // Update or create a Znote_shop
     * const znote_shop = await prisma.znote_shop.upsert({
     *   create: {
     *     // ... data to create a Znote_shop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_shop we want to update
     *   }
     * })
    **/
    upsert<T extends znote_shopUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shopUpsertArgs<ExtArgs>>
    ): Prisma__znote_shopClient<$Types.GetResult<znote_shopPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shopCountArgs} args - Arguments to filter Znote_shops to count.
     * @example
     * // Count the number of Znote_shops
     * const count = await prisma.znote_shop.count({
     *   where: {
     *     // ... the filter for the Znote_shops we want to count
     *   }
     * })
    **/
    count<T extends znote_shopCountArgs>(
      args?: Subset<T, znote_shopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_shopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_shopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_shopAggregateArgs>(args: Subset<T, Znote_shopAggregateArgs>): Prisma.PrismaPromise<GetZnote_shopAggregateType<T>>

    /**
     * Group by Znote_shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_shopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_shopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_shopGroupByArgs['orderBy'] }
        : { orderBy?: Znote_shopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_shopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_shopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_shop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_shopClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_shop base type for findUnique actions
   */
  export type znote_shopFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop
     */
    select?: znote_shopSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop to fetch.
     */
    where: znote_shopWhereUniqueInput
  }

  /**
   * znote_shop findUnique
   */
  export interface znote_shopFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_shopFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_shop findUniqueOrThrow
   */
  export type znote_shopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop
     */
    select?: znote_shopSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop to fetch.
     */
    where: znote_shopWhereUniqueInput
  }


  /**
   * znote_shop base type for findFirst actions
   */
  export type znote_shopFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop
     */
    select?: znote_shopSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop to fetch.
     */
    where?: znote_shopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_shops to fetch.
     */
    orderBy?: Enumerable<znote_shopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_shops.
     */
    cursor?: znote_shopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_shops.
     */
    distinct?: Enumerable<Znote_shopScalarFieldEnum>
  }

  /**
   * znote_shop findFirst
   */
  export interface znote_shopFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_shopFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_shop findFirstOrThrow
   */
  export type znote_shopFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop
     */
    select?: znote_shopSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop to fetch.
     */
    where?: znote_shopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_shops to fetch.
     */
    orderBy?: Enumerable<znote_shopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_shops.
     */
    cursor?: znote_shopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_shops.
     */
    distinct?: Enumerable<Znote_shopScalarFieldEnum>
  }


  /**
   * znote_shop findMany
   */
  export type znote_shopFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop
     */
    select?: znote_shopSelect<ExtArgs> | null
    /**
     * Filter, which znote_shops to fetch.
     */
    where?: znote_shopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_shops to fetch.
     */
    orderBy?: Enumerable<znote_shopOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_shops.
     */
    cursor?: znote_shopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_shops.
     */
    skip?: number
    distinct?: Enumerable<Znote_shopScalarFieldEnum>
  }


  /**
   * znote_shop create
   */
  export type znote_shopCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop
     */
    select?: znote_shopSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_shop.
     */
    data: XOR<znote_shopCreateInput, znote_shopUncheckedCreateInput>
  }


  /**
   * znote_shop createMany
   */
  export type znote_shopCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_shops.
     */
    data: Enumerable<znote_shopCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_shop update
   */
  export type znote_shopUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop
     */
    select?: znote_shopSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_shop.
     */
    data: XOR<znote_shopUpdateInput, znote_shopUncheckedUpdateInput>
    /**
     * Choose, which znote_shop to update.
     */
    where: znote_shopWhereUniqueInput
  }


  /**
   * znote_shop updateMany
   */
  export type znote_shopUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_shops.
     */
    data: XOR<znote_shopUpdateManyMutationInput, znote_shopUncheckedUpdateManyInput>
    /**
     * Filter which znote_shops to update
     */
    where?: znote_shopWhereInput
  }


  /**
   * znote_shop upsert
   */
  export type znote_shopUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop
     */
    select?: znote_shopSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_shop to update in case it exists.
     */
    where: znote_shopWhereUniqueInput
    /**
     * In case the znote_shop found by the `where` argument doesn't exist, create a new znote_shop with this data.
     */
    create: XOR<znote_shopCreateInput, znote_shopUncheckedCreateInput>
    /**
     * In case the znote_shop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_shopUpdateInput, znote_shopUncheckedUpdateInput>
  }


  /**
   * znote_shop delete
   */
  export type znote_shopDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop
     */
    select?: znote_shopSelect<ExtArgs> | null
    /**
     * Filter which znote_shop to delete.
     */
    where: znote_shopWhereUniqueInput
  }


  /**
   * znote_shop deleteMany
   */
  export type znote_shopDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_shops to delete
     */
    where?: znote_shopWhereInput
  }


  /**
   * znote_shop without action
   */
  export type znote_shopArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop
     */
    select?: znote_shopSelect<ExtArgs> | null
  }



  /**
   * Model znote_shop_logs
   */


  export type AggregateZnote_shop_logs = {
    _count: Znote_shop_logsCountAggregateOutputType | null
    _avg: Znote_shop_logsAvgAggregateOutputType | null
    _sum: Znote_shop_logsSumAggregateOutputType | null
    _min: Znote_shop_logsMinAggregateOutputType | null
    _max: Znote_shop_logsMaxAggregateOutputType | null
  }

  export type Znote_shop_logsAvgAggregateOutputType = {
    id: number | null
    account_id: number | null
    player_id: number | null
    type: number | null
    itemid: number | null
    count: number | null
    points: number | null
    time: number | null
  }

  export type Znote_shop_logsSumAggregateOutputType = {
    id: number | null
    account_id: number | null
    player_id: number | null
    type: number | null
    itemid: number | null
    count: number | null
    points: number | null
    time: number | null
  }

  export type Znote_shop_logsMinAggregateOutputType = {
    id: number | null
    account_id: number | null
    player_id: number | null
    type: number | null
    itemid: number | null
    count: number | null
    points: number | null
    time: number | null
  }

  export type Znote_shop_logsMaxAggregateOutputType = {
    id: number | null
    account_id: number | null
    player_id: number | null
    type: number | null
    itemid: number | null
    count: number | null
    points: number | null
    time: number | null
  }

  export type Znote_shop_logsCountAggregateOutputType = {
    id: number
    account_id: number
    player_id: number
    type: number
    itemid: number
    count: number
    points: number
    time: number
    _all: number
  }


  export type Znote_shop_logsAvgAggregateInputType = {
    id?: true
    account_id?: true
    player_id?: true
    type?: true
    itemid?: true
    count?: true
    points?: true
    time?: true
  }

  export type Znote_shop_logsSumAggregateInputType = {
    id?: true
    account_id?: true
    player_id?: true
    type?: true
    itemid?: true
    count?: true
    points?: true
    time?: true
  }

  export type Znote_shop_logsMinAggregateInputType = {
    id?: true
    account_id?: true
    player_id?: true
    type?: true
    itemid?: true
    count?: true
    points?: true
    time?: true
  }

  export type Znote_shop_logsMaxAggregateInputType = {
    id?: true
    account_id?: true
    player_id?: true
    type?: true
    itemid?: true
    count?: true
    points?: true
    time?: true
  }

  export type Znote_shop_logsCountAggregateInputType = {
    id?: true
    account_id?: true
    player_id?: true
    type?: true
    itemid?: true
    count?: true
    points?: true
    time?: true
    _all?: true
  }

  export type Znote_shop_logsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_shop_logs to aggregate.
     */
    where?: znote_shop_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_shop_logs to fetch.
     */
    orderBy?: Enumerable<znote_shop_logsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_shop_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_shop_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_shop_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_shop_logs
    **/
    _count?: true | Znote_shop_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_shop_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_shop_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_shop_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_shop_logsMaxAggregateInputType
  }

  export type GetZnote_shop_logsAggregateType<T extends Znote_shop_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_shop_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_shop_logs[P]>
      : GetScalarType<T[P], AggregateZnote_shop_logs[P]>
  }




  export type Znote_shop_logsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_shop_logsWhereInput
    orderBy?: Enumerable<znote_shop_logsOrderByWithAggregationInput>
    by: Znote_shop_logsScalarFieldEnum[]
    having?: znote_shop_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_shop_logsCountAggregateInputType | true
    _avg?: Znote_shop_logsAvgAggregateInputType
    _sum?: Znote_shop_logsSumAggregateInputType
    _min?: Znote_shop_logsMinAggregateInputType
    _max?: Znote_shop_logsMaxAggregateInputType
  }


  export type Znote_shop_logsGroupByOutputType = {
    id: number
    account_id: number
    player_id: number
    type: number
    itemid: number
    count: number
    points: number
    time: number
    _count: Znote_shop_logsCountAggregateOutputType | null
    _avg: Znote_shop_logsAvgAggregateOutputType | null
    _sum: Znote_shop_logsSumAggregateOutputType | null
    _min: Znote_shop_logsMinAggregateOutputType | null
    _max: Znote_shop_logsMaxAggregateOutputType | null
  }

  type GetZnote_shop_logsGroupByPayload<T extends Znote_shop_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_shop_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_shop_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_shop_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_shop_logsGroupByOutputType[P]>
        }
      >
    >


  export type znote_shop_logsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    player_id?: boolean
    type?: boolean
    itemid?: boolean
    count?: boolean
    points?: boolean
    time?: boolean
  }, ExtArgs["result"]["znote_shop_logs"]>

  export type znote_shop_logsSelectScalar = {
    id?: boolean
    account_id?: boolean
    player_id?: boolean
    type?: boolean
    itemid?: boolean
    count?: boolean
    points?: boolean
    time?: boolean
  }


  type znote_shop_logsGetPayload<S extends boolean | null | undefined | znote_shop_logsArgs> = $Types.GetResult<znote_shop_logsPayload, S>

  type znote_shop_logsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_shop_logsFindManyArgs, 'select' | 'include'> & {
      select?: Znote_shop_logsCountAggregateInputType | true
    }

  export interface znote_shop_logsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_shop_logs'], meta: { name: 'znote_shop_logs' } }
    /**
     * Find zero or one Znote_shop_logs that matches the filter.
     * @param {znote_shop_logsFindUniqueArgs} args - Arguments to find a Znote_shop_logs
     * @example
     * // Get one Znote_shop_logs
     * const znote_shop_logs = await prisma.znote_shop_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_shop_logsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_shop_logsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_shop_logs'> extends True ? Prisma__znote_shop_logsClient<$Types.GetResult<znote_shop_logsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_shop_logsClient<$Types.GetResult<znote_shop_logsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_shop_logs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_shop_logsFindUniqueOrThrowArgs} args - Arguments to find a Znote_shop_logs
     * @example
     * // Get one Znote_shop_logs
     * const znote_shop_logs = await prisma.znote_shop_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_shop_logsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shop_logsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_shop_logsClient<$Types.GetResult<znote_shop_logsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_shop_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shop_logsFindFirstArgs} args - Arguments to find a Znote_shop_logs
     * @example
     * // Get one Znote_shop_logs
     * const znote_shop_logs = await prisma.znote_shop_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_shop_logsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_shop_logsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_shop_logs'> extends True ? Prisma__znote_shop_logsClient<$Types.GetResult<znote_shop_logsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_shop_logsClient<$Types.GetResult<znote_shop_logsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_shop_logs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shop_logsFindFirstOrThrowArgs} args - Arguments to find a Znote_shop_logs
     * @example
     * // Get one Znote_shop_logs
     * const znote_shop_logs = await prisma.znote_shop_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_shop_logsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shop_logsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_shop_logsClient<$Types.GetResult<znote_shop_logsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_shop_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shop_logsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_shop_logs
     * const znote_shop_logs = await prisma.znote_shop_logs.findMany()
     * 
     * // Get first 10 Znote_shop_logs
     * const znote_shop_logs = await prisma.znote_shop_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_shop_logsWithIdOnly = await prisma.znote_shop_logs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_shop_logsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shop_logsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_shop_logsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_shop_logs.
     * @param {znote_shop_logsCreateArgs} args - Arguments to create a Znote_shop_logs.
     * @example
     * // Create one Znote_shop_logs
     * const Znote_shop_logs = await prisma.znote_shop_logs.create({
     *   data: {
     *     // ... data to create a Znote_shop_logs
     *   }
     * })
     * 
    **/
    create<T extends znote_shop_logsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shop_logsCreateArgs<ExtArgs>>
    ): Prisma__znote_shop_logsClient<$Types.GetResult<znote_shop_logsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_shop_logs.
     *     @param {znote_shop_logsCreateManyArgs} args - Arguments to create many Znote_shop_logs.
     *     @example
     *     // Create many Znote_shop_logs
     *     const znote_shop_logs = await prisma.znote_shop_logs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_shop_logsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shop_logsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_shop_logs.
     * @param {znote_shop_logsDeleteArgs} args - Arguments to delete one Znote_shop_logs.
     * @example
     * // Delete one Znote_shop_logs
     * const Znote_shop_logs = await prisma.znote_shop_logs.delete({
     *   where: {
     *     // ... filter to delete one Znote_shop_logs
     *   }
     * })
     * 
    **/
    delete<T extends znote_shop_logsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shop_logsDeleteArgs<ExtArgs>>
    ): Prisma__znote_shop_logsClient<$Types.GetResult<znote_shop_logsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_shop_logs.
     * @param {znote_shop_logsUpdateArgs} args - Arguments to update one Znote_shop_logs.
     * @example
     * // Update one Znote_shop_logs
     * const znote_shop_logs = await prisma.znote_shop_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_shop_logsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shop_logsUpdateArgs<ExtArgs>>
    ): Prisma__znote_shop_logsClient<$Types.GetResult<znote_shop_logsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_shop_logs.
     * @param {znote_shop_logsDeleteManyArgs} args - Arguments to filter Znote_shop_logs to delete.
     * @example
     * // Delete a few Znote_shop_logs
     * const { count } = await prisma.znote_shop_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_shop_logsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shop_logsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_shop_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shop_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_shop_logs
     * const znote_shop_logs = await prisma.znote_shop_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_shop_logsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shop_logsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_shop_logs.
     * @param {znote_shop_logsUpsertArgs} args - Arguments to update or create a Znote_shop_logs.
     * @example
     * // Update or create a Znote_shop_logs
     * const znote_shop_logs = await prisma.znote_shop_logs.upsert({
     *   create: {
     *     // ... data to create a Znote_shop_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_shop_logs we want to update
     *   }
     * })
    **/
    upsert<T extends znote_shop_logsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shop_logsUpsertArgs<ExtArgs>>
    ): Prisma__znote_shop_logsClient<$Types.GetResult<znote_shop_logsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_shop_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shop_logsCountArgs} args - Arguments to filter Znote_shop_logs to count.
     * @example
     * // Count the number of Znote_shop_logs
     * const count = await prisma.znote_shop_logs.count({
     *   where: {
     *     // ... the filter for the Znote_shop_logs we want to count
     *   }
     * })
    **/
    count<T extends znote_shop_logsCountArgs>(
      args?: Subset<T, znote_shop_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_shop_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_shop_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_shop_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_shop_logsAggregateArgs>(args: Subset<T, Znote_shop_logsAggregateArgs>): Prisma.PrismaPromise<GetZnote_shop_logsAggregateType<T>>

    /**
     * Group by Znote_shop_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_shop_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_shop_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_shop_logsGroupByArgs['orderBy'] }
        : { orderBy?: Znote_shop_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_shop_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_shop_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_shop_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_shop_logsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_shop_logs base type for findUnique actions
   */
  export type znote_shop_logsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_logs
     */
    select?: znote_shop_logsSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop_logs to fetch.
     */
    where: znote_shop_logsWhereUniqueInput
  }

  /**
   * znote_shop_logs findUnique
   */
  export interface znote_shop_logsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_shop_logsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_shop_logs findUniqueOrThrow
   */
  export type znote_shop_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_logs
     */
    select?: znote_shop_logsSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop_logs to fetch.
     */
    where: znote_shop_logsWhereUniqueInput
  }


  /**
   * znote_shop_logs base type for findFirst actions
   */
  export type znote_shop_logsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_logs
     */
    select?: znote_shop_logsSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop_logs to fetch.
     */
    where?: znote_shop_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_shop_logs to fetch.
     */
    orderBy?: Enumerable<znote_shop_logsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_shop_logs.
     */
    cursor?: znote_shop_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_shop_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_shop_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_shop_logs.
     */
    distinct?: Enumerable<Znote_shop_logsScalarFieldEnum>
  }

  /**
   * znote_shop_logs findFirst
   */
  export interface znote_shop_logsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_shop_logsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_shop_logs findFirstOrThrow
   */
  export type znote_shop_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_logs
     */
    select?: znote_shop_logsSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop_logs to fetch.
     */
    where?: znote_shop_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_shop_logs to fetch.
     */
    orderBy?: Enumerable<znote_shop_logsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_shop_logs.
     */
    cursor?: znote_shop_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_shop_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_shop_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_shop_logs.
     */
    distinct?: Enumerable<Znote_shop_logsScalarFieldEnum>
  }


  /**
   * znote_shop_logs findMany
   */
  export type znote_shop_logsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_logs
     */
    select?: znote_shop_logsSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop_logs to fetch.
     */
    where?: znote_shop_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_shop_logs to fetch.
     */
    orderBy?: Enumerable<znote_shop_logsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_shop_logs.
     */
    cursor?: znote_shop_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_shop_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_shop_logs.
     */
    skip?: number
    distinct?: Enumerable<Znote_shop_logsScalarFieldEnum>
  }


  /**
   * znote_shop_logs create
   */
  export type znote_shop_logsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_logs
     */
    select?: znote_shop_logsSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_shop_logs.
     */
    data: XOR<znote_shop_logsCreateInput, znote_shop_logsUncheckedCreateInput>
  }


  /**
   * znote_shop_logs createMany
   */
  export type znote_shop_logsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_shop_logs.
     */
    data: Enumerable<znote_shop_logsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_shop_logs update
   */
  export type znote_shop_logsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_logs
     */
    select?: znote_shop_logsSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_shop_logs.
     */
    data: XOR<znote_shop_logsUpdateInput, znote_shop_logsUncheckedUpdateInput>
    /**
     * Choose, which znote_shop_logs to update.
     */
    where: znote_shop_logsWhereUniqueInput
  }


  /**
   * znote_shop_logs updateMany
   */
  export type znote_shop_logsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_shop_logs.
     */
    data: XOR<znote_shop_logsUpdateManyMutationInput, znote_shop_logsUncheckedUpdateManyInput>
    /**
     * Filter which znote_shop_logs to update
     */
    where?: znote_shop_logsWhereInput
  }


  /**
   * znote_shop_logs upsert
   */
  export type znote_shop_logsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_logs
     */
    select?: znote_shop_logsSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_shop_logs to update in case it exists.
     */
    where: znote_shop_logsWhereUniqueInput
    /**
     * In case the znote_shop_logs found by the `where` argument doesn't exist, create a new znote_shop_logs with this data.
     */
    create: XOR<znote_shop_logsCreateInput, znote_shop_logsUncheckedCreateInput>
    /**
     * In case the znote_shop_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_shop_logsUpdateInput, znote_shop_logsUncheckedUpdateInput>
  }


  /**
   * znote_shop_logs delete
   */
  export type znote_shop_logsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_logs
     */
    select?: znote_shop_logsSelect<ExtArgs> | null
    /**
     * Filter which znote_shop_logs to delete.
     */
    where: znote_shop_logsWhereUniqueInput
  }


  /**
   * znote_shop_logs deleteMany
   */
  export type znote_shop_logsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_shop_logs to delete
     */
    where?: znote_shop_logsWhereInput
  }


  /**
   * znote_shop_logs without action
   */
  export type znote_shop_logsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_logs
     */
    select?: znote_shop_logsSelect<ExtArgs> | null
  }



  /**
   * Model znote_shop_orders
   */


  export type AggregateZnote_shop_orders = {
    _count: Znote_shop_ordersCountAggregateOutputType | null
    _avg: Znote_shop_ordersAvgAggregateOutputType | null
    _sum: Znote_shop_ordersSumAggregateOutputType | null
    _min: Znote_shop_ordersMinAggregateOutputType | null
    _max: Znote_shop_ordersMaxAggregateOutputType | null
  }

  export type Znote_shop_ordersAvgAggregateOutputType = {
    id: number | null
    account_id: number | null
    type: number | null
    itemid: number | null
    count: number | null
    time: number | null
  }

  export type Znote_shop_ordersSumAggregateOutputType = {
    id: number | null
    account_id: number | null
    type: number | null
    itemid: number | null
    count: number | null
    time: number | null
  }

  export type Znote_shop_ordersMinAggregateOutputType = {
    id: number | null
    account_id: number | null
    type: number | null
    itemid: number | null
    count: number | null
    time: number | null
  }

  export type Znote_shop_ordersMaxAggregateOutputType = {
    id: number | null
    account_id: number | null
    type: number | null
    itemid: number | null
    count: number | null
    time: number | null
  }

  export type Znote_shop_ordersCountAggregateOutputType = {
    id: number
    account_id: number
    type: number
    itemid: number
    count: number
    time: number
    _all: number
  }


  export type Znote_shop_ordersAvgAggregateInputType = {
    id?: true
    account_id?: true
    type?: true
    itemid?: true
    count?: true
    time?: true
  }

  export type Znote_shop_ordersSumAggregateInputType = {
    id?: true
    account_id?: true
    type?: true
    itemid?: true
    count?: true
    time?: true
  }

  export type Znote_shop_ordersMinAggregateInputType = {
    id?: true
    account_id?: true
    type?: true
    itemid?: true
    count?: true
    time?: true
  }

  export type Znote_shop_ordersMaxAggregateInputType = {
    id?: true
    account_id?: true
    type?: true
    itemid?: true
    count?: true
    time?: true
  }

  export type Znote_shop_ordersCountAggregateInputType = {
    id?: true
    account_id?: true
    type?: true
    itemid?: true
    count?: true
    time?: true
    _all?: true
  }

  export type Znote_shop_ordersAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_shop_orders to aggregate.
     */
    where?: znote_shop_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_shop_orders to fetch.
     */
    orderBy?: Enumerable<znote_shop_ordersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_shop_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_shop_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_shop_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_shop_orders
    **/
    _count?: true | Znote_shop_ordersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_shop_ordersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_shop_ordersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_shop_ordersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_shop_ordersMaxAggregateInputType
  }

  export type GetZnote_shop_ordersAggregateType<T extends Znote_shop_ordersAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_shop_orders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_shop_orders[P]>
      : GetScalarType<T[P], AggregateZnote_shop_orders[P]>
  }




  export type Znote_shop_ordersGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_shop_ordersWhereInput
    orderBy?: Enumerable<znote_shop_ordersOrderByWithAggregationInput>
    by: Znote_shop_ordersScalarFieldEnum[]
    having?: znote_shop_ordersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_shop_ordersCountAggregateInputType | true
    _avg?: Znote_shop_ordersAvgAggregateInputType
    _sum?: Znote_shop_ordersSumAggregateInputType
    _min?: Znote_shop_ordersMinAggregateInputType
    _max?: Znote_shop_ordersMaxAggregateInputType
  }


  export type Znote_shop_ordersGroupByOutputType = {
    id: number
    account_id: number
    type: number
    itemid: number
    count: number
    time: number
    _count: Znote_shop_ordersCountAggregateOutputType | null
    _avg: Znote_shop_ordersAvgAggregateOutputType | null
    _sum: Znote_shop_ordersSumAggregateOutputType | null
    _min: Znote_shop_ordersMinAggregateOutputType | null
    _max: Znote_shop_ordersMaxAggregateOutputType | null
  }

  type GetZnote_shop_ordersGroupByPayload<T extends Znote_shop_ordersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_shop_ordersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_shop_ordersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_shop_ordersGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_shop_ordersGroupByOutputType[P]>
        }
      >
    >


  export type znote_shop_ordersSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    account_id?: boolean
    type?: boolean
    itemid?: boolean
    count?: boolean
    time?: boolean
  }, ExtArgs["result"]["znote_shop_orders"]>

  export type znote_shop_ordersSelectScalar = {
    id?: boolean
    account_id?: boolean
    type?: boolean
    itemid?: boolean
    count?: boolean
    time?: boolean
  }


  type znote_shop_ordersGetPayload<S extends boolean | null | undefined | znote_shop_ordersArgs> = $Types.GetResult<znote_shop_ordersPayload, S>

  type znote_shop_ordersCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_shop_ordersFindManyArgs, 'select' | 'include'> & {
      select?: Znote_shop_ordersCountAggregateInputType | true
    }

  export interface znote_shop_ordersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_shop_orders'], meta: { name: 'znote_shop_orders' } }
    /**
     * Find zero or one Znote_shop_orders that matches the filter.
     * @param {znote_shop_ordersFindUniqueArgs} args - Arguments to find a Znote_shop_orders
     * @example
     * // Get one Znote_shop_orders
     * const znote_shop_orders = await prisma.znote_shop_orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_shop_ordersFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_shop_ordersFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_shop_orders'> extends True ? Prisma__znote_shop_ordersClient<$Types.GetResult<znote_shop_ordersPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_shop_ordersClient<$Types.GetResult<znote_shop_ordersPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_shop_orders that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_shop_ordersFindUniqueOrThrowArgs} args - Arguments to find a Znote_shop_orders
     * @example
     * // Get one Znote_shop_orders
     * const znote_shop_orders = await prisma.znote_shop_orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_shop_ordersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shop_ordersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_shop_ordersClient<$Types.GetResult<znote_shop_ordersPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_shop_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shop_ordersFindFirstArgs} args - Arguments to find a Znote_shop_orders
     * @example
     * // Get one Znote_shop_orders
     * const znote_shop_orders = await prisma.znote_shop_orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_shop_ordersFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_shop_ordersFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_shop_orders'> extends True ? Prisma__znote_shop_ordersClient<$Types.GetResult<znote_shop_ordersPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_shop_ordersClient<$Types.GetResult<znote_shop_ordersPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_shop_orders that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shop_ordersFindFirstOrThrowArgs} args - Arguments to find a Znote_shop_orders
     * @example
     * // Get one Znote_shop_orders
     * const znote_shop_orders = await prisma.znote_shop_orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_shop_ordersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shop_ordersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_shop_ordersClient<$Types.GetResult<znote_shop_ordersPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_shop_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shop_ordersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_shop_orders
     * const znote_shop_orders = await prisma.znote_shop_orders.findMany()
     * 
     * // Get first 10 Znote_shop_orders
     * const znote_shop_orders = await prisma.znote_shop_orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_shop_ordersWithIdOnly = await prisma.znote_shop_orders.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_shop_ordersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shop_ordersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_shop_ordersPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_shop_orders.
     * @param {znote_shop_ordersCreateArgs} args - Arguments to create a Znote_shop_orders.
     * @example
     * // Create one Znote_shop_orders
     * const Znote_shop_orders = await prisma.znote_shop_orders.create({
     *   data: {
     *     // ... data to create a Znote_shop_orders
     *   }
     * })
     * 
    **/
    create<T extends znote_shop_ordersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shop_ordersCreateArgs<ExtArgs>>
    ): Prisma__znote_shop_ordersClient<$Types.GetResult<znote_shop_ordersPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_shop_orders.
     *     @param {znote_shop_ordersCreateManyArgs} args - Arguments to create many Znote_shop_orders.
     *     @example
     *     // Create many Znote_shop_orders
     *     const znote_shop_orders = await prisma.znote_shop_orders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_shop_ordersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shop_ordersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_shop_orders.
     * @param {znote_shop_ordersDeleteArgs} args - Arguments to delete one Znote_shop_orders.
     * @example
     * // Delete one Znote_shop_orders
     * const Znote_shop_orders = await prisma.znote_shop_orders.delete({
     *   where: {
     *     // ... filter to delete one Znote_shop_orders
     *   }
     * })
     * 
    **/
    delete<T extends znote_shop_ordersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shop_ordersDeleteArgs<ExtArgs>>
    ): Prisma__znote_shop_ordersClient<$Types.GetResult<znote_shop_ordersPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_shop_orders.
     * @param {znote_shop_ordersUpdateArgs} args - Arguments to update one Znote_shop_orders.
     * @example
     * // Update one Znote_shop_orders
     * const znote_shop_orders = await prisma.znote_shop_orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_shop_ordersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shop_ordersUpdateArgs<ExtArgs>>
    ): Prisma__znote_shop_ordersClient<$Types.GetResult<znote_shop_ordersPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_shop_orders.
     * @param {znote_shop_ordersDeleteManyArgs} args - Arguments to filter Znote_shop_orders to delete.
     * @example
     * // Delete a few Znote_shop_orders
     * const { count } = await prisma.znote_shop_orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_shop_ordersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_shop_ordersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_shop_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shop_ordersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_shop_orders
     * const znote_shop_orders = await prisma.znote_shop_orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_shop_ordersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shop_ordersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_shop_orders.
     * @param {znote_shop_ordersUpsertArgs} args - Arguments to update or create a Znote_shop_orders.
     * @example
     * // Update or create a Znote_shop_orders
     * const znote_shop_orders = await prisma.znote_shop_orders.upsert({
     *   create: {
     *     // ... data to create a Znote_shop_orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_shop_orders we want to update
     *   }
     * })
    **/
    upsert<T extends znote_shop_ordersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_shop_ordersUpsertArgs<ExtArgs>>
    ): Prisma__znote_shop_ordersClient<$Types.GetResult<znote_shop_ordersPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_shop_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_shop_ordersCountArgs} args - Arguments to filter Znote_shop_orders to count.
     * @example
     * // Count the number of Znote_shop_orders
     * const count = await prisma.znote_shop_orders.count({
     *   where: {
     *     // ... the filter for the Znote_shop_orders we want to count
     *   }
     * })
    **/
    count<T extends znote_shop_ordersCountArgs>(
      args?: Subset<T, znote_shop_ordersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_shop_ordersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_shop_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_shop_ordersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_shop_ordersAggregateArgs>(args: Subset<T, Znote_shop_ordersAggregateArgs>): Prisma.PrismaPromise<GetZnote_shop_ordersAggregateType<T>>

    /**
     * Group by Znote_shop_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_shop_ordersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_shop_ordersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_shop_ordersGroupByArgs['orderBy'] }
        : { orderBy?: Znote_shop_ordersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_shop_ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_shop_ordersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_shop_orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_shop_ordersClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_shop_orders base type for findUnique actions
   */
  export type znote_shop_ordersFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_orders
     */
    select?: znote_shop_ordersSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop_orders to fetch.
     */
    where: znote_shop_ordersWhereUniqueInput
  }

  /**
   * znote_shop_orders findUnique
   */
  export interface znote_shop_ordersFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_shop_ordersFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_shop_orders findUniqueOrThrow
   */
  export type znote_shop_ordersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_orders
     */
    select?: znote_shop_ordersSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop_orders to fetch.
     */
    where: znote_shop_ordersWhereUniqueInput
  }


  /**
   * znote_shop_orders base type for findFirst actions
   */
  export type znote_shop_ordersFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_orders
     */
    select?: znote_shop_ordersSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop_orders to fetch.
     */
    where?: znote_shop_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_shop_orders to fetch.
     */
    orderBy?: Enumerable<znote_shop_ordersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_shop_orders.
     */
    cursor?: znote_shop_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_shop_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_shop_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_shop_orders.
     */
    distinct?: Enumerable<Znote_shop_ordersScalarFieldEnum>
  }

  /**
   * znote_shop_orders findFirst
   */
  export interface znote_shop_ordersFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_shop_ordersFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_shop_orders findFirstOrThrow
   */
  export type znote_shop_ordersFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_orders
     */
    select?: znote_shop_ordersSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop_orders to fetch.
     */
    where?: znote_shop_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_shop_orders to fetch.
     */
    orderBy?: Enumerable<znote_shop_ordersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_shop_orders.
     */
    cursor?: znote_shop_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_shop_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_shop_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_shop_orders.
     */
    distinct?: Enumerable<Znote_shop_ordersScalarFieldEnum>
  }


  /**
   * znote_shop_orders findMany
   */
  export type znote_shop_ordersFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_orders
     */
    select?: znote_shop_ordersSelect<ExtArgs> | null
    /**
     * Filter, which znote_shop_orders to fetch.
     */
    where?: znote_shop_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_shop_orders to fetch.
     */
    orderBy?: Enumerable<znote_shop_ordersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_shop_orders.
     */
    cursor?: znote_shop_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_shop_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_shop_orders.
     */
    skip?: number
    distinct?: Enumerable<Znote_shop_ordersScalarFieldEnum>
  }


  /**
   * znote_shop_orders create
   */
  export type znote_shop_ordersCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_orders
     */
    select?: znote_shop_ordersSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_shop_orders.
     */
    data: XOR<znote_shop_ordersCreateInput, znote_shop_ordersUncheckedCreateInput>
  }


  /**
   * znote_shop_orders createMany
   */
  export type znote_shop_ordersCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_shop_orders.
     */
    data: Enumerable<znote_shop_ordersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_shop_orders update
   */
  export type znote_shop_ordersUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_orders
     */
    select?: znote_shop_ordersSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_shop_orders.
     */
    data: XOR<znote_shop_ordersUpdateInput, znote_shop_ordersUncheckedUpdateInput>
    /**
     * Choose, which znote_shop_orders to update.
     */
    where: znote_shop_ordersWhereUniqueInput
  }


  /**
   * znote_shop_orders updateMany
   */
  export type znote_shop_ordersUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_shop_orders.
     */
    data: XOR<znote_shop_ordersUpdateManyMutationInput, znote_shop_ordersUncheckedUpdateManyInput>
    /**
     * Filter which znote_shop_orders to update
     */
    where?: znote_shop_ordersWhereInput
  }


  /**
   * znote_shop_orders upsert
   */
  export type znote_shop_ordersUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_orders
     */
    select?: znote_shop_ordersSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_shop_orders to update in case it exists.
     */
    where: znote_shop_ordersWhereUniqueInput
    /**
     * In case the znote_shop_orders found by the `where` argument doesn't exist, create a new znote_shop_orders with this data.
     */
    create: XOR<znote_shop_ordersCreateInput, znote_shop_ordersUncheckedCreateInput>
    /**
     * In case the znote_shop_orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_shop_ordersUpdateInput, znote_shop_ordersUncheckedUpdateInput>
  }


  /**
   * znote_shop_orders delete
   */
  export type znote_shop_ordersDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_orders
     */
    select?: znote_shop_ordersSelect<ExtArgs> | null
    /**
     * Filter which znote_shop_orders to delete.
     */
    where: znote_shop_ordersWhereUniqueInput
  }


  /**
   * znote_shop_orders deleteMany
   */
  export type znote_shop_ordersDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_shop_orders to delete
     */
    where?: znote_shop_ordersWhereInput
  }


  /**
   * znote_shop_orders without action
   */
  export type znote_shop_ordersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_shop_orders
     */
    select?: znote_shop_ordersSelect<ExtArgs> | null
  }



  /**
   * Model znote_tickets
   */


  export type AggregateZnote_tickets = {
    _count: Znote_ticketsCountAggregateOutputType | null
    _avg: Znote_ticketsAvgAggregateOutputType | null
    _sum: Znote_ticketsSumAggregateOutputType | null
    _min: Znote_ticketsMinAggregateOutputType | null
    _max: Znote_ticketsMaxAggregateOutputType | null
  }

  export type Znote_ticketsAvgAggregateOutputType = {
    id: number | null
    owner: number | null
    ip: number | null
    creation: number | null
  }

  export type Znote_ticketsSumAggregateOutputType = {
    id: number | null
    owner: number | null
    ip: bigint | null
    creation: number | null
  }

  export type Znote_ticketsMinAggregateOutputType = {
    id: number | null
    owner: number | null
    username: string | null
    subject: string | null
    message: string | null
    ip: bigint | null
    creation: number | null
    status: string | null
  }

  export type Znote_ticketsMaxAggregateOutputType = {
    id: number | null
    owner: number | null
    username: string | null
    subject: string | null
    message: string | null
    ip: bigint | null
    creation: number | null
    status: string | null
  }

  export type Znote_ticketsCountAggregateOutputType = {
    id: number
    owner: number
    username: number
    subject: number
    message: number
    ip: number
    creation: number
    status: number
    _all: number
  }


  export type Znote_ticketsAvgAggregateInputType = {
    id?: true
    owner?: true
    ip?: true
    creation?: true
  }

  export type Znote_ticketsSumAggregateInputType = {
    id?: true
    owner?: true
    ip?: true
    creation?: true
  }

  export type Znote_ticketsMinAggregateInputType = {
    id?: true
    owner?: true
    username?: true
    subject?: true
    message?: true
    ip?: true
    creation?: true
    status?: true
  }

  export type Znote_ticketsMaxAggregateInputType = {
    id?: true
    owner?: true
    username?: true
    subject?: true
    message?: true
    ip?: true
    creation?: true
    status?: true
  }

  export type Znote_ticketsCountAggregateInputType = {
    id?: true
    owner?: true
    username?: true
    subject?: true
    message?: true
    ip?: true
    creation?: true
    status?: true
    _all?: true
  }

  export type Znote_ticketsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_tickets to aggregate.
     */
    where?: znote_ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_tickets to fetch.
     */
    orderBy?: Enumerable<znote_ticketsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_tickets
    **/
    _count?: true | Znote_ticketsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_ticketsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_ticketsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_ticketsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_ticketsMaxAggregateInputType
  }

  export type GetZnote_ticketsAggregateType<T extends Znote_ticketsAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_tickets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_tickets[P]>
      : GetScalarType<T[P], AggregateZnote_tickets[P]>
  }




  export type Znote_ticketsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_ticketsWhereInput
    orderBy?: Enumerable<znote_ticketsOrderByWithAggregationInput>
    by: Znote_ticketsScalarFieldEnum[]
    having?: znote_ticketsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_ticketsCountAggregateInputType | true
    _avg?: Znote_ticketsAvgAggregateInputType
    _sum?: Znote_ticketsSumAggregateInputType
    _min?: Znote_ticketsMinAggregateInputType
    _max?: Znote_ticketsMaxAggregateInputType
  }


  export type Znote_ticketsGroupByOutputType = {
    id: number
    owner: number
    username: string
    subject: string
    message: string
    ip: bigint
    creation: number
    status: string
    _count: Znote_ticketsCountAggregateOutputType | null
    _avg: Znote_ticketsAvgAggregateOutputType | null
    _sum: Znote_ticketsSumAggregateOutputType | null
    _min: Znote_ticketsMinAggregateOutputType | null
    _max: Znote_ticketsMaxAggregateOutputType | null
  }

  type GetZnote_ticketsGroupByPayload<T extends Znote_ticketsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_ticketsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_ticketsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_ticketsGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_ticketsGroupByOutputType[P]>
        }
      >
    >


  export type znote_ticketsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    owner?: boolean
    username?: boolean
    subject?: boolean
    message?: boolean
    ip?: boolean
    creation?: boolean
    status?: boolean
  }, ExtArgs["result"]["znote_tickets"]>

  export type znote_ticketsSelectScalar = {
    id?: boolean
    owner?: boolean
    username?: boolean
    subject?: boolean
    message?: boolean
    ip?: boolean
    creation?: boolean
    status?: boolean
  }


  type znote_ticketsGetPayload<S extends boolean | null | undefined | znote_ticketsArgs> = $Types.GetResult<znote_ticketsPayload, S>

  type znote_ticketsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_ticketsFindManyArgs, 'select' | 'include'> & {
      select?: Znote_ticketsCountAggregateInputType | true
    }

  export interface znote_ticketsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_tickets'], meta: { name: 'znote_tickets' } }
    /**
     * Find zero or one Znote_tickets that matches the filter.
     * @param {znote_ticketsFindUniqueArgs} args - Arguments to find a Znote_tickets
     * @example
     * // Get one Znote_tickets
     * const znote_tickets = await prisma.znote_tickets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_ticketsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_ticketsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_tickets'> extends True ? Prisma__znote_ticketsClient<$Types.GetResult<znote_ticketsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_ticketsClient<$Types.GetResult<znote_ticketsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_tickets that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_ticketsFindUniqueOrThrowArgs} args - Arguments to find a Znote_tickets
     * @example
     * // Get one Znote_tickets
     * const znote_tickets = await prisma.znote_tickets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_ticketsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_ticketsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_ticketsClient<$Types.GetResult<znote_ticketsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_ticketsFindFirstArgs} args - Arguments to find a Znote_tickets
     * @example
     * // Get one Znote_tickets
     * const znote_tickets = await prisma.znote_tickets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_ticketsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_ticketsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_tickets'> extends True ? Prisma__znote_ticketsClient<$Types.GetResult<znote_ticketsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_ticketsClient<$Types.GetResult<znote_ticketsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_tickets that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_ticketsFindFirstOrThrowArgs} args - Arguments to find a Znote_tickets
     * @example
     * // Get one Znote_tickets
     * const znote_tickets = await prisma.znote_tickets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_ticketsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_ticketsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_ticketsClient<$Types.GetResult<znote_ticketsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_ticketsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_tickets
     * const znote_tickets = await prisma.znote_tickets.findMany()
     * 
     * // Get first 10 Znote_tickets
     * const znote_tickets = await prisma.znote_tickets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_ticketsWithIdOnly = await prisma.znote_tickets.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_ticketsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_ticketsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_ticketsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_tickets.
     * @param {znote_ticketsCreateArgs} args - Arguments to create a Znote_tickets.
     * @example
     * // Create one Znote_tickets
     * const Znote_tickets = await prisma.znote_tickets.create({
     *   data: {
     *     // ... data to create a Znote_tickets
     *   }
     * })
     * 
    **/
    create<T extends znote_ticketsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_ticketsCreateArgs<ExtArgs>>
    ): Prisma__znote_ticketsClient<$Types.GetResult<znote_ticketsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_tickets.
     *     @param {znote_ticketsCreateManyArgs} args - Arguments to create many Znote_tickets.
     *     @example
     *     // Create many Znote_tickets
     *     const znote_tickets = await prisma.znote_tickets.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_ticketsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_ticketsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_tickets.
     * @param {znote_ticketsDeleteArgs} args - Arguments to delete one Znote_tickets.
     * @example
     * // Delete one Znote_tickets
     * const Znote_tickets = await prisma.znote_tickets.delete({
     *   where: {
     *     // ... filter to delete one Znote_tickets
     *   }
     * })
     * 
    **/
    delete<T extends znote_ticketsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_ticketsDeleteArgs<ExtArgs>>
    ): Prisma__znote_ticketsClient<$Types.GetResult<znote_ticketsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_tickets.
     * @param {znote_ticketsUpdateArgs} args - Arguments to update one Znote_tickets.
     * @example
     * // Update one Znote_tickets
     * const znote_tickets = await prisma.znote_tickets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_ticketsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_ticketsUpdateArgs<ExtArgs>>
    ): Prisma__znote_ticketsClient<$Types.GetResult<znote_ticketsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_tickets.
     * @param {znote_ticketsDeleteManyArgs} args - Arguments to filter Znote_tickets to delete.
     * @example
     * // Delete a few Znote_tickets
     * const { count } = await prisma.znote_tickets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_ticketsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_ticketsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_ticketsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_tickets
     * const znote_tickets = await prisma.znote_tickets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_ticketsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_ticketsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_tickets.
     * @param {znote_ticketsUpsertArgs} args - Arguments to update or create a Znote_tickets.
     * @example
     * // Update or create a Znote_tickets
     * const znote_tickets = await prisma.znote_tickets.upsert({
     *   create: {
     *     // ... data to create a Znote_tickets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_tickets we want to update
     *   }
     * })
    **/
    upsert<T extends znote_ticketsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_ticketsUpsertArgs<ExtArgs>>
    ): Prisma__znote_ticketsClient<$Types.GetResult<znote_ticketsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_ticketsCountArgs} args - Arguments to filter Znote_tickets to count.
     * @example
     * // Count the number of Znote_tickets
     * const count = await prisma.znote_tickets.count({
     *   where: {
     *     // ... the filter for the Znote_tickets we want to count
     *   }
     * })
    **/
    count<T extends znote_ticketsCountArgs>(
      args?: Subset<T, znote_ticketsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_ticketsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_ticketsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_ticketsAggregateArgs>(args: Subset<T, Znote_ticketsAggregateArgs>): Prisma.PrismaPromise<GetZnote_ticketsAggregateType<T>>

    /**
     * Group by Znote_tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_ticketsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_ticketsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_ticketsGroupByArgs['orderBy'] }
        : { orderBy?: Znote_ticketsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_ticketsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_ticketsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_tickets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_ticketsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_tickets base type for findUnique actions
   */
  export type znote_ticketsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets
     */
    select?: znote_ticketsSelect<ExtArgs> | null
    /**
     * Filter, which znote_tickets to fetch.
     */
    where: znote_ticketsWhereUniqueInput
  }

  /**
   * znote_tickets findUnique
   */
  export interface znote_ticketsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_ticketsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_tickets findUniqueOrThrow
   */
  export type znote_ticketsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets
     */
    select?: znote_ticketsSelect<ExtArgs> | null
    /**
     * Filter, which znote_tickets to fetch.
     */
    where: znote_ticketsWhereUniqueInput
  }


  /**
   * znote_tickets base type for findFirst actions
   */
  export type znote_ticketsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets
     */
    select?: znote_ticketsSelect<ExtArgs> | null
    /**
     * Filter, which znote_tickets to fetch.
     */
    where?: znote_ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_tickets to fetch.
     */
    orderBy?: Enumerable<znote_ticketsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_tickets.
     */
    cursor?: znote_ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_tickets.
     */
    distinct?: Enumerable<Znote_ticketsScalarFieldEnum>
  }

  /**
   * znote_tickets findFirst
   */
  export interface znote_ticketsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_ticketsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_tickets findFirstOrThrow
   */
  export type znote_ticketsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets
     */
    select?: znote_ticketsSelect<ExtArgs> | null
    /**
     * Filter, which znote_tickets to fetch.
     */
    where?: znote_ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_tickets to fetch.
     */
    orderBy?: Enumerable<znote_ticketsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_tickets.
     */
    cursor?: znote_ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_tickets.
     */
    distinct?: Enumerable<Znote_ticketsScalarFieldEnum>
  }


  /**
   * znote_tickets findMany
   */
  export type znote_ticketsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets
     */
    select?: znote_ticketsSelect<ExtArgs> | null
    /**
     * Filter, which znote_tickets to fetch.
     */
    where?: znote_ticketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_tickets to fetch.
     */
    orderBy?: Enumerable<znote_ticketsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_tickets.
     */
    cursor?: znote_ticketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_tickets.
     */
    skip?: number
    distinct?: Enumerable<Znote_ticketsScalarFieldEnum>
  }


  /**
   * znote_tickets create
   */
  export type znote_ticketsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets
     */
    select?: znote_ticketsSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_tickets.
     */
    data: XOR<znote_ticketsCreateInput, znote_ticketsUncheckedCreateInput>
  }


  /**
   * znote_tickets createMany
   */
  export type znote_ticketsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_tickets.
     */
    data: Enumerable<znote_ticketsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_tickets update
   */
  export type znote_ticketsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets
     */
    select?: znote_ticketsSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_tickets.
     */
    data: XOR<znote_ticketsUpdateInput, znote_ticketsUncheckedUpdateInput>
    /**
     * Choose, which znote_tickets to update.
     */
    where: znote_ticketsWhereUniqueInput
  }


  /**
   * znote_tickets updateMany
   */
  export type znote_ticketsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_tickets.
     */
    data: XOR<znote_ticketsUpdateManyMutationInput, znote_ticketsUncheckedUpdateManyInput>
    /**
     * Filter which znote_tickets to update
     */
    where?: znote_ticketsWhereInput
  }


  /**
   * znote_tickets upsert
   */
  export type znote_ticketsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets
     */
    select?: znote_ticketsSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_tickets to update in case it exists.
     */
    where: znote_ticketsWhereUniqueInput
    /**
     * In case the znote_tickets found by the `where` argument doesn't exist, create a new znote_tickets with this data.
     */
    create: XOR<znote_ticketsCreateInput, znote_ticketsUncheckedCreateInput>
    /**
     * In case the znote_tickets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_ticketsUpdateInput, znote_ticketsUncheckedUpdateInput>
  }


  /**
   * znote_tickets delete
   */
  export type znote_ticketsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets
     */
    select?: znote_ticketsSelect<ExtArgs> | null
    /**
     * Filter which znote_tickets to delete.
     */
    where: znote_ticketsWhereUniqueInput
  }


  /**
   * znote_tickets deleteMany
   */
  export type znote_ticketsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_tickets to delete
     */
    where?: znote_ticketsWhereInput
  }


  /**
   * znote_tickets without action
   */
  export type znote_ticketsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets
     */
    select?: znote_ticketsSelect<ExtArgs> | null
  }



  /**
   * Model znote_tickets_replies
   */


  export type AggregateZnote_tickets_replies = {
    _count: Znote_tickets_repliesCountAggregateOutputType | null
    _avg: Znote_tickets_repliesAvgAggregateOutputType | null
    _sum: Znote_tickets_repliesSumAggregateOutputType | null
    _min: Znote_tickets_repliesMinAggregateOutputType | null
    _max: Znote_tickets_repliesMaxAggregateOutputType | null
  }

  export type Znote_tickets_repliesAvgAggregateOutputType = {
    id: number | null
    tid: number | null
    created: number | null
  }

  export type Znote_tickets_repliesSumAggregateOutputType = {
    id: number | null
    tid: number | null
    created: number | null
  }

  export type Znote_tickets_repliesMinAggregateOutputType = {
    id: number | null
    tid: number | null
    username: string | null
    message: string | null
    created: number | null
  }

  export type Znote_tickets_repliesMaxAggregateOutputType = {
    id: number | null
    tid: number | null
    username: string | null
    message: string | null
    created: number | null
  }

  export type Znote_tickets_repliesCountAggregateOutputType = {
    id: number
    tid: number
    username: number
    message: number
    created: number
    _all: number
  }


  export type Znote_tickets_repliesAvgAggregateInputType = {
    id?: true
    tid?: true
    created?: true
  }

  export type Znote_tickets_repliesSumAggregateInputType = {
    id?: true
    tid?: true
    created?: true
  }

  export type Znote_tickets_repliesMinAggregateInputType = {
    id?: true
    tid?: true
    username?: true
    message?: true
    created?: true
  }

  export type Znote_tickets_repliesMaxAggregateInputType = {
    id?: true
    tid?: true
    username?: true
    message?: true
    created?: true
  }

  export type Znote_tickets_repliesCountAggregateInputType = {
    id?: true
    tid?: true
    username?: true
    message?: true
    created?: true
    _all?: true
  }

  export type Znote_tickets_repliesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_tickets_replies to aggregate.
     */
    where?: znote_tickets_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_tickets_replies to fetch.
     */
    orderBy?: Enumerable<znote_tickets_repliesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_tickets_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_tickets_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_tickets_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_tickets_replies
    **/
    _count?: true | Znote_tickets_repliesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_tickets_repliesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_tickets_repliesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_tickets_repliesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_tickets_repliesMaxAggregateInputType
  }

  export type GetZnote_tickets_repliesAggregateType<T extends Znote_tickets_repliesAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_tickets_replies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_tickets_replies[P]>
      : GetScalarType<T[P], AggregateZnote_tickets_replies[P]>
  }




  export type Znote_tickets_repliesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_tickets_repliesWhereInput
    orderBy?: Enumerable<znote_tickets_repliesOrderByWithAggregationInput>
    by: Znote_tickets_repliesScalarFieldEnum[]
    having?: znote_tickets_repliesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_tickets_repliesCountAggregateInputType | true
    _avg?: Znote_tickets_repliesAvgAggregateInputType
    _sum?: Znote_tickets_repliesSumAggregateInputType
    _min?: Znote_tickets_repliesMinAggregateInputType
    _max?: Znote_tickets_repliesMaxAggregateInputType
  }


  export type Znote_tickets_repliesGroupByOutputType = {
    id: number
    tid: number
    username: string
    message: string
    created: number
    _count: Znote_tickets_repliesCountAggregateOutputType | null
    _avg: Znote_tickets_repliesAvgAggregateOutputType | null
    _sum: Znote_tickets_repliesSumAggregateOutputType | null
    _min: Znote_tickets_repliesMinAggregateOutputType | null
    _max: Znote_tickets_repliesMaxAggregateOutputType | null
  }

  type GetZnote_tickets_repliesGroupByPayload<T extends Znote_tickets_repliesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_tickets_repliesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_tickets_repliesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_tickets_repliesGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_tickets_repliesGroupByOutputType[P]>
        }
      >
    >


  export type znote_tickets_repliesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tid?: boolean
    username?: boolean
    message?: boolean
    created?: boolean
  }, ExtArgs["result"]["znote_tickets_replies"]>

  export type znote_tickets_repliesSelectScalar = {
    id?: boolean
    tid?: boolean
    username?: boolean
    message?: boolean
    created?: boolean
  }


  type znote_tickets_repliesGetPayload<S extends boolean | null | undefined | znote_tickets_repliesArgs> = $Types.GetResult<znote_tickets_repliesPayload, S>

  type znote_tickets_repliesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_tickets_repliesFindManyArgs, 'select' | 'include'> & {
      select?: Znote_tickets_repliesCountAggregateInputType | true
    }

  export interface znote_tickets_repliesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_tickets_replies'], meta: { name: 'znote_tickets_replies' } }
    /**
     * Find zero or one Znote_tickets_replies that matches the filter.
     * @param {znote_tickets_repliesFindUniqueArgs} args - Arguments to find a Znote_tickets_replies
     * @example
     * // Get one Znote_tickets_replies
     * const znote_tickets_replies = await prisma.znote_tickets_replies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_tickets_repliesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_tickets_repliesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_tickets_replies'> extends True ? Prisma__znote_tickets_repliesClient<$Types.GetResult<znote_tickets_repliesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_tickets_repliesClient<$Types.GetResult<znote_tickets_repliesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_tickets_replies that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_tickets_repliesFindUniqueOrThrowArgs} args - Arguments to find a Znote_tickets_replies
     * @example
     * // Get one Znote_tickets_replies
     * const znote_tickets_replies = await prisma.znote_tickets_replies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_tickets_repliesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_tickets_repliesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_tickets_repliesClient<$Types.GetResult<znote_tickets_repliesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_tickets_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_tickets_repliesFindFirstArgs} args - Arguments to find a Znote_tickets_replies
     * @example
     * // Get one Znote_tickets_replies
     * const znote_tickets_replies = await prisma.znote_tickets_replies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_tickets_repliesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_tickets_repliesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_tickets_replies'> extends True ? Prisma__znote_tickets_repliesClient<$Types.GetResult<znote_tickets_repliesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_tickets_repliesClient<$Types.GetResult<znote_tickets_repliesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_tickets_replies that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_tickets_repliesFindFirstOrThrowArgs} args - Arguments to find a Znote_tickets_replies
     * @example
     * // Get one Znote_tickets_replies
     * const znote_tickets_replies = await prisma.znote_tickets_replies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_tickets_repliesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_tickets_repliesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_tickets_repliesClient<$Types.GetResult<znote_tickets_repliesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_tickets_replies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_tickets_repliesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_tickets_replies
     * const znote_tickets_replies = await prisma.znote_tickets_replies.findMany()
     * 
     * // Get first 10 Znote_tickets_replies
     * const znote_tickets_replies = await prisma.znote_tickets_replies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_tickets_repliesWithIdOnly = await prisma.znote_tickets_replies.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_tickets_repliesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_tickets_repliesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_tickets_repliesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_tickets_replies.
     * @param {znote_tickets_repliesCreateArgs} args - Arguments to create a Znote_tickets_replies.
     * @example
     * // Create one Znote_tickets_replies
     * const Znote_tickets_replies = await prisma.znote_tickets_replies.create({
     *   data: {
     *     // ... data to create a Znote_tickets_replies
     *   }
     * })
     * 
    **/
    create<T extends znote_tickets_repliesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_tickets_repliesCreateArgs<ExtArgs>>
    ): Prisma__znote_tickets_repliesClient<$Types.GetResult<znote_tickets_repliesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_tickets_replies.
     *     @param {znote_tickets_repliesCreateManyArgs} args - Arguments to create many Znote_tickets_replies.
     *     @example
     *     // Create many Znote_tickets_replies
     *     const znote_tickets_replies = await prisma.znote_tickets_replies.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_tickets_repliesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_tickets_repliesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_tickets_replies.
     * @param {znote_tickets_repliesDeleteArgs} args - Arguments to delete one Znote_tickets_replies.
     * @example
     * // Delete one Znote_tickets_replies
     * const Znote_tickets_replies = await prisma.znote_tickets_replies.delete({
     *   where: {
     *     // ... filter to delete one Znote_tickets_replies
     *   }
     * })
     * 
    **/
    delete<T extends znote_tickets_repliesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_tickets_repliesDeleteArgs<ExtArgs>>
    ): Prisma__znote_tickets_repliesClient<$Types.GetResult<znote_tickets_repliesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_tickets_replies.
     * @param {znote_tickets_repliesUpdateArgs} args - Arguments to update one Znote_tickets_replies.
     * @example
     * // Update one Znote_tickets_replies
     * const znote_tickets_replies = await prisma.znote_tickets_replies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_tickets_repliesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_tickets_repliesUpdateArgs<ExtArgs>>
    ): Prisma__znote_tickets_repliesClient<$Types.GetResult<znote_tickets_repliesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_tickets_replies.
     * @param {znote_tickets_repliesDeleteManyArgs} args - Arguments to filter Znote_tickets_replies to delete.
     * @example
     * // Delete a few Znote_tickets_replies
     * const { count } = await prisma.znote_tickets_replies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_tickets_repliesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_tickets_repliesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_tickets_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_tickets_repliesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_tickets_replies
     * const znote_tickets_replies = await prisma.znote_tickets_replies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_tickets_repliesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_tickets_repliesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_tickets_replies.
     * @param {znote_tickets_repliesUpsertArgs} args - Arguments to update or create a Znote_tickets_replies.
     * @example
     * // Update or create a Znote_tickets_replies
     * const znote_tickets_replies = await prisma.znote_tickets_replies.upsert({
     *   create: {
     *     // ... data to create a Znote_tickets_replies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_tickets_replies we want to update
     *   }
     * })
    **/
    upsert<T extends znote_tickets_repliesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_tickets_repliesUpsertArgs<ExtArgs>>
    ): Prisma__znote_tickets_repliesClient<$Types.GetResult<znote_tickets_repliesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_tickets_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_tickets_repliesCountArgs} args - Arguments to filter Znote_tickets_replies to count.
     * @example
     * // Count the number of Znote_tickets_replies
     * const count = await prisma.znote_tickets_replies.count({
     *   where: {
     *     // ... the filter for the Znote_tickets_replies we want to count
     *   }
     * })
    **/
    count<T extends znote_tickets_repliesCountArgs>(
      args?: Subset<T, znote_tickets_repliesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_tickets_repliesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_tickets_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_tickets_repliesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_tickets_repliesAggregateArgs>(args: Subset<T, Znote_tickets_repliesAggregateArgs>): Prisma.PrismaPromise<GetZnote_tickets_repliesAggregateType<T>>

    /**
     * Group by Znote_tickets_replies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_tickets_repliesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_tickets_repliesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_tickets_repliesGroupByArgs['orderBy'] }
        : { orderBy?: Znote_tickets_repliesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_tickets_repliesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_tickets_repliesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_tickets_replies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_tickets_repliesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_tickets_replies base type for findUnique actions
   */
  export type znote_tickets_repliesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets_replies
     */
    select?: znote_tickets_repliesSelect<ExtArgs> | null
    /**
     * Filter, which znote_tickets_replies to fetch.
     */
    where: znote_tickets_repliesWhereUniqueInput
  }

  /**
   * znote_tickets_replies findUnique
   */
  export interface znote_tickets_repliesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_tickets_repliesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_tickets_replies findUniqueOrThrow
   */
  export type znote_tickets_repliesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets_replies
     */
    select?: znote_tickets_repliesSelect<ExtArgs> | null
    /**
     * Filter, which znote_tickets_replies to fetch.
     */
    where: znote_tickets_repliesWhereUniqueInput
  }


  /**
   * znote_tickets_replies base type for findFirst actions
   */
  export type znote_tickets_repliesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets_replies
     */
    select?: znote_tickets_repliesSelect<ExtArgs> | null
    /**
     * Filter, which znote_tickets_replies to fetch.
     */
    where?: znote_tickets_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_tickets_replies to fetch.
     */
    orderBy?: Enumerable<znote_tickets_repliesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_tickets_replies.
     */
    cursor?: znote_tickets_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_tickets_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_tickets_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_tickets_replies.
     */
    distinct?: Enumerable<Znote_tickets_repliesScalarFieldEnum>
  }

  /**
   * znote_tickets_replies findFirst
   */
  export interface znote_tickets_repliesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_tickets_repliesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_tickets_replies findFirstOrThrow
   */
  export type znote_tickets_repliesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets_replies
     */
    select?: znote_tickets_repliesSelect<ExtArgs> | null
    /**
     * Filter, which znote_tickets_replies to fetch.
     */
    where?: znote_tickets_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_tickets_replies to fetch.
     */
    orderBy?: Enumerable<znote_tickets_repliesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_tickets_replies.
     */
    cursor?: znote_tickets_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_tickets_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_tickets_replies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_tickets_replies.
     */
    distinct?: Enumerable<Znote_tickets_repliesScalarFieldEnum>
  }


  /**
   * znote_tickets_replies findMany
   */
  export type znote_tickets_repliesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets_replies
     */
    select?: znote_tickets_repliesSelect<ExtArgs> | null
    /**
     * Filter, which znote_tickets_replies to fetch.
     */
    where?: znote_tickets_repliesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_tickets_replies to fetch.
     */
    orderBy?: Enumerable<znote_tickets_repliesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_tickets_replies.
     */
    cursor?: znote_tickets_repliesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_tickets_replies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_tickets_replies.
     */
    skip?: number
    distinct?: Enumerable<Znote_tickets_repliesScalarFieldEnum>
  }


  /**
   * znote_tickets_replies create
   */
  export type znote_tickets_repliesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets_replies
     */
    select?: znote_tickets_repliesSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_tickets_replies.
     */
    data: XOR<znote_tickets_repliesCreateInput, znote_tickets_repliesUncheckedCreateInput>
  }


  /**
   * znote_tickets_replies createMany
   */
  export type znote_tickets_repliesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_tickets_replies.
     */
    data: Enumerable<znote_tickets_repliesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_tickets_replies update
   */
  export type znote_tickets_repliesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets_replies
     */
    select?: znote_tickets_repliesSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_tickets_replies.
     */
    data: XOR<znote_tickets_repliesUpdateInput, znote_tickets_repliesUncheckedUpdateInput>
    /**
     * Choose, which znote_tickets_replies to update.
     */
    where: znote_tickets_repliesWhereUniqueInput
  }


  /**
   * znote_tickets_replies updateMany
   */
  export type znote_tickets_repliesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_tickets_replies.
     */
    data: XOR<znote_tickets_repliesUpdateManyMutationInput, znote_tickets_repliesUncheckedUpdateManyInput>
    /**
     * Filter which znote_tickets_replies to update
     */
    where?: znote_tickets_repliesWhereInput
  }


  /**
   * znote_tickets_replies upsert
   */
  export type znote_tickets_repliesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets_replies
     */
    select?: znote_tickets_repliesSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_tickets_replies to update in case it exists.
     */
    where: znote_tickets_repliesWhereUniqueInput
    /**
     * In case the znote_tickets_replies found by the `where` argument doesn't exist, create a new znote_tickets_replies with this data.
     */
    create: XOR<znote_tickets_repliesCreateInput, znote_tickets_repliesUncheckedCreateInput>
    /**
     * In case the znote_tickets_replies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_tickets_repliesUpdateInput, znote_tickets_repliesUncheckedUpdateInput>
  }


  /**
   * znote_tickets_replies delete
   */
  export type znote_tickets_repliesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets_replies
     */
    select?: znote_tickets_repliesSelect<ExtArgs> | null
    /**
     * Filter which znote_tickets_replies to delete.
     */
    where: znote_tickets_repliesWhereUniqueInput
  }


  /**
   * znote_tickets_replies deleteMany
   */
  export type znote_tickets_repliesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_tickets_replies to delete
     */
    where?: znote_tickets_repliesWhereInput
  }


  /**
   * znote_tickets_replies without action
   */
  export type znote_tickets_repliesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_tickets_replies
     */
    select?: znote_tickets_repliesSelect<ExtArgs> | null
  }



  /**
   * Model znote_visitors
   */


  export type AggregateZnote_visitors = {
    _count: Znote_visitorsCountAggregateOutputType | null
    _avg: Znote_visitorsAvgAggregateOutputType | null
    _sum: Znote_visitorsSumAggregateOutputType | null
    _min: Znote_visitorsMinAggregateOutputType | null
    _max: Znote_visitorsMaxAggregateOutputType | null
  }

  export type Znote_visitorsAvgAggregateOutputType = {
    id: number | null
    ip: number | null
    value: number | null
  }

  export type Znote_visitorsSumAggregateOutputType = {
    id: number | null
    ip: bigint | null
    value: number | null
  }

  export type Znote_visitorsMinAggregateOutputType = {
    id: number | null
    ip: bigint | null
    value: number | null
  }

  export type Znote_visitorsMaxAggregateOutputType = {
    id: number | null
    ip: bigint | null
    value: number | null
  }

  export type Znote_visitorsCountAggregateOutputType = {
    id: number
    ip: number
    value: number
    _all: number
  }


  export type Znote_visitorsAvgAggregateInputType = {
    id?: true
    ip?: true
    value?: true
  }

  export type Znote_visitorsSumAggregateInputType = {
    id?: true
    ip?: true
    value?: true
  }

  export type Znote_visitorsMinAggregateInputType = {
    id?: true
    ip?: true
    value?: true
  }

  export type Znote_visitorsMaxAggregateInputType = {
    id?: true
    ip?: true
    value?: true
  }

  export type Znote_visitorsCountAggregateInputType = {
    id?: true
    ip?: true
    value?: true
    _all?: true
  }

  export type Znote_visitorsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_visitors to aggregate.
     */
    where?: znote_visitorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_visitors to fetch.
     */
    orderBy?: Enumerable<znote_visitorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_visitorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_visitors
    **/
    _count?: true | Znote_visitorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_visitorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_visitorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_visitorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_visitorsMaxAggregateInputType
  }

  export type GetZnote_visitorsAggregateType<T extends Znote_visitorsAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_visitors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_visitors[P]>
      : GetScalarType<T[P], AggregateZnote_visitors[P]>
  }




  export type Znote_visitorsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_visitorsWhereInput
    orderBy?: Enumerable<znote_visitorsOrderByWithAggregationInput>
    by: Znote_visitorsScalarFieldEnum[]
    having?: znote_visitorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_visitorsCountAggregateInputType | true
    _avg?: Znote_visitorsAvgAggregateInputType
    _sum?: Znote_visitorsSumAggregateInputType
    _min?: Znote_visitorsMinAggregateInputType
    _max?: Znote_visitorsMaxAggregateInputType
  }


  export type Znote_visitorsGroupByOutputType = {
    id: number
    ip: bigint
    value: number
    _count: Znote_visitorsCountAggregateOutputType | null
    _avg: Znote_visitorsAvgAggregateOutputType | null
    _sum: Znote_visitorsSumAggregateOutputType | null
    _min: Znote_visitorsMinAggregateOutputType | null
    _max: Znote_visitorsMaxAggregateOutputType | null
  }

  type GetZnote_visitorsGroupByPayload<T extends Znote_visitorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_visitorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_visitorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_visitorsGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_visitorsGroupByOutputType[P]>
        }
      >
    >


  export type znote_visitorsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ip?: boolean
    value?: boolean
  }, ExtArgs["result"]["znote_visitors"]>

  export type znote_visitorsSelectScalar = {
    id?: boolean
    ip?: boolean
    value?: boolean
  }


  type znote_visitorsGetPayload<S extends boolean | null | undefined | znote_visitorsArgs> = $Types.GetResult<znote_visitorsPayload, S>

  type znote_visitorsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_visitorsFindManyArgs, 'select' | 'include'> & {
      select?: Znote_visitorsCountAggregateInputType | true
    }

  export interface znote_visitorsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_visitors'], meta: { name: 'znote_visitors' } }
    /**
     * Find zero or one Znote_visitors that matches the filter.
     * @param {znote_visitorsFindUniqueArgs} args - Arguments to find a Znote_visitors
     * @example
     * // Get one Znote_visitors
     * const znote_visitors = await prisma.znote_visitors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_visitorsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_visitorsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_visitors'> extends True ? Prisma__znote_visitorsClient<$Types.GetResult<znote_visitorsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_visitorsClient<$Types.GetResult<znote_visitorsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_visitors that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_visitorsFindUniqueOrThrowArgs} args - Arguments to find a Znote_visitors
     * @example
     * // Get one Znote_visitors
     * const znote_visitors = await prisma.znote_visitors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_visitorsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_visitorsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_visitorsClient<$Types.GetResult<znote_visitorsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_visitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_visitorsFindFirstArgs} args - Arguments to find a Znote_visitors
     * @example
     * // Get one Znote_visitors
     * const znote_visitors = await prisma.znote_visitors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_visitorsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_visitorsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_visitors'> extends True ? Prisma__znote_visitorsClient<$Types.GetResult<znote_visitorsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_visitorsClient<$Types.GetResult<znote_visitorsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_visitors that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_visitorsFindFirstOrThrowArgs} args - Arguments to find a Znote_visitors
     * @example
     * // Get one Znote_visitors
     * const znote_visitors = await prisma.znote_visitors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_visitorsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_visitorsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_visitorsClient<$Types.GetResult<znote_visitorsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_visitors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_visitorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_visitors
     * const znote_visitors = await prisma.znote_visitors.findMany()
     * 
     * // Get first 10 Znote_visitors
     * const znote_visitors = await prisma.znote_visitors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_visitorsWithIdOnly = await prisma.znote_visitors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_visitorsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_visitorsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_visitorsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_visitors.
     * @param {znote_visitorsCreateArgs} args - Arguments to create a Znote_visitors.
     * @example
     * // Create one Znote_visitors
     * const Znote_visitors = await prisma.znote_visitors.create({
     *   data: {
     *     // ... data to create a Znote_visitors
     *   }
     * })
     * 
    **/
    create<T extends znote_visitorsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_visitorsCreateArgs<ExtArgs>>
    ): Prisma__znote_visitorsClient<$Types.GetResult<znote_visitorsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_visitors.
     *     @param {znote_visitorsCreateManyArgs} args - Arguments to create many Znote_visitors.
     *     @example
     *     // Create many Znote_visitors
     *     const znote_visitors = await prisma.znote_visitors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_visitorsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_visitorsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_visitors.
     * @param {znote_visitorsDeleteArgs} args - Arguments to delete one Znote_visitors.
     * @example
     * // Delete one Znote_visitors
     * const Znote_visitors = await prisma.znote_visitors.delete({
     *   where: {
     *     // ... filter to delete one Znote_visitors
     *   }
     * })
     * 
    **/
    delete<T extends znote_visitorsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_visitorsDeleteArgs<ExtArgs>>
    ): Prisma__znote_visitorsClient<$Types.GetResult<znote_visitorsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_visitors.
     * @param {znote_visitorsUpdateArgs} args - Arguments to update one Znote_visitors.
     * @example
     * // Update one Znote_visitors
     * const znote_visitors = await prisma.znote_visitors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_visitorsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_visitorsUpdateArgs<ExtArgs>>
    ): Prisma__znote_visitorsClient<$Types.GetResult<znote_visitorsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_visitors.
     * @param {znote_visitorsDeleteManyArgs} args - Arguments to filter Znote_visitors to delete.
     * @example
     * // Delete a few Znote_visitors
     * const { count } = await prisma.znote_visitors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_visitorsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_visitorsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_visitorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_visitors
     * const znote_visitors = await prisma.znote_visitors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_visitorsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_visitorsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_visitors.
     * @param {znote_visitorsUpsertArgs} args - Arguments to update or create a Znote_visitors.
     * @example
     * // Update or create a Znote_visitors
     * const znote_visitors = await prisma.znote_visitors.upsert({
     *   create: {
     *     // ... data to create a Znote_visitors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_visitors we want to update
     *   }
     * })
    **/
    upsert<T extends znote_visitorsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_visitorsUpsertArgs<ExtArgs>>
    ): Prisma__znote_visitorsClient<$Types.GetResult<znote_visitorsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_visitorsCountArgs} args - Arguments to filter Znote_visitors to count.
     * @example
     * // Count the number of Znote_visitors
     * const count = await prisma.znote_visitors.count({
     *   where: {
     *     // ... the filter for the Znote_visitors we want to count
     *   }
     * })
    **/
    count<T extends znote_visitorsCountArgs>(
      args?: Subset<T, znote_visitorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_visitorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_visitorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_visitorsAggregateArgs>(args: Subset<T, Znote_visitorsAggregateArgs>): Prisma.PrismaPromise<GetZnote_visitorsAggregateType<T>>

    /**
     * Group by Znote_visitors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_visitorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_visitorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_visitorsGroupByArgs['orderBy'] }
        : { orderBy?: Znote_visitorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_visitorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_visitorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_visitors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_visitorsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_visitors base type for findUnique actions
   */
  export type znote_visitorsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors
     */
    select?: znote_visitorsSelect<ExtArgs> | null
    /**
     * Filter, which znote_visitors to fetch.
     */
    where: znote_visitorsWhereUniqueInput
  }

  /**
   * znote_visitors findUnique
   */
  export interface znote_visitorsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_visitorsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_visitors findUniqueOrThrow
   */
  export type znote_visitorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors
     */
    select?: znote_visitorsSelect<ExtArgs> | null
    /**
     * Filter, which znote_visitors to fetch.
     */
    where: znote_visitorsWhereUniqueInput
  }


  /**
   * znote_visitors base type for findFirst actions
   */
  export type znote_visitorsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors
     */
    select?: znote_visitorsSelect<ExtArgs> | null
    /**
     * Filter, which znote_visitors to fetch.
     */
    where?: znote_visitorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_visitors to fetch.
     */
    orderBy?: Enumerable<znote_visitorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_visitors.
     */
    cursor?: znote_visitorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_visitors.
     */
    distinct?: Enumerable<Znote_visitorsScalarFieldEnum>
  }

  /**
   * znote_visitors findFirst
   */
  export interface znote_visitorsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_visitorsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_visitors findFirstOrThrow
   */
  export type znote_visitorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors
     */
    select?: znote_visitorsSelect<ExtArgs> | null
    /**
     * Filter, which znote_visitors to fetch.
     */
    where?: znote_visitorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_visitors to fetch.
     */
    orderBy?: Enumerable<znote_visitorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_visitors.
     */
    cursor?: znote_visitorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_visitors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_visitors.
     */
    distinct?: Enumerable<Znote_visitorsScalarFieldEnum>
  }


  /**
   * znote_visitors findMany
   */
  export type znote_visitorsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors
     */
    select?: znote_visitorsSelect<ExtArgs> | null
    /**
     * Filter, which znote_visitors to fetch.
     */
    where?: znote_visitorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_visitors to fetch.
     */
    orderBy?: Enumerable<znote_visitorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_visitors.
     */
    cursor?: znote_visitorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_visitors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_visitors.
     */
    skip?: number
    distinct?: Enumerable<Znote_visitorsScalarFieldEnum>
  }


  /**
   * znote_visitors create
   */
  export type znote_visitorsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors
     */
    select?: znote_visitorsSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_visitors.
     */
    data: XOR<znote_visitorsCreateInput, znote_visitorsUncheckedCreateInput>
  }


  /**
   * znote_visitors createMany
   */
  export type znote_visitorsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_visitors.
     */
    data: Enumerable<znote_visitorsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_visitors update
   */
  export type znote_visitorsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors
     */
    select?: znote_visitorsSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_visitors.
     */
    data: XOR<znote_visitorsUpdateInput, znote_visitorsUncheckedUpdateInput>
    /**
     * Choose, which znote_visitors to update.
     */
    where: znote_visitorsWhereUniqueInput
  }


  /**
   * znote_visitors updateMany
   */
  export type znote_visitorsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_visitors.
     */
    data: XOR<znote_visitorsUpdateManyMutationInput, znote_visitorsUncheckedUpdateManyInput>
    /**
     * Filter which znote_visitors to update
     */
    where?: znote_visitorsWhereInput
  }


  /**
   * znote_visitors upsert
   */
  export type znote_visitorsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors
     */
    select?: znote_visitorsSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_visitors to update in case it exists.
     */
    where: znote_visitorsWhereUniqueInput
    /**
     * In case the znote_visitors found by the `where` argument doesn't exist, create a new znote_visitors with this data.
     */
    create: XOR<znote_visitorsCreateInput, znote_visitorsUncheckedCreateInput>
    /**
     * In case the znote_visitors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_visitorsUpdateInput, znote_visitorsUncheckedUpdateInput>
  }


  /**
   * znote_visitors delete
   */
  export type znote_visitorsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors
     */
    select?: znote_visitorsSelect<ExtArgs> | null
    /**
     * Filter which znote_visitors to delete.
     */
    where: znote_visitorsWhereUniqueInput
  }


  /**
   * znote_visitors deleteMany
   */
  export type znote_visitorsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_visitors to delete
     */
    where?: znote_visitorsWhereInput
  }


  /**
   * znote_visitors without action
   */
  export type znote_visitorsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors
     */
    select?: znote_visitorsSelect<ExtArgs> | null
  }



  /**
   * Model znote_visitors_details
   */


  export type AggregateZnote_visitors_details = {
    _count: Znote_visitors_detailsCountAggregateOutputType | null
    _avg: Znote_visitors_detailsAvgAggregateOutputType | null
    _sum: Znote_visitors_detailsSumAggregateOutputType | null
    _min: Znote_visitors_detailsMinAggregateOutputType | null
    _max: Znote_visitors_detailsMaxAggregateOutputType | null
  }

  export type Znote_visitors_detailsAvgAggregateOutputType = {
    id: number | null
    ip: number | null
    time: number | null
    type: number | null
    account_id: number | null
  }

  export type Znote_visitors_detailsSumAggregateOutputType = {
    id: number | null
    ip: bigint | null
    time: number | null
    type: number | null
    account_id: number | null
  }

  export type Znote_visitors_detailsMinAggregateOutputType = {
    id: number | null
    ip: bigint | null
    time: number | null
    type: number | null
    account_id: number | null
  }

  export type Znote_visitors_detailsMaxAggregateOutputType = {
    id: number | null
    ip: bigint | null
    time: number | null
    type: number | null
    account_id: number | null
  }

  export type Znote_visitors_detailsCountAggregateOutputType = {
    id: number
    ip: number
    time: number
    type: number
    account_id: number
    _all: number
  }


  export type Znote_visitors_detailsAvgAggregateInputType = {
    id?: true
    ip?: true
    time?: true
    type?: true
    account_id?: true
  }

  export type Znote_visitors_detailsSumAggregateInputType = {
    id?: true
    ip?: true
    time?: true
    type?: true
    account_id?: true
  }

  export type Znote_visitors_detailsMinAggregateInputType = {
    id?: true
    ip?: true
    time?: true
    type?: true
    account_id?: true
  }

  export type Znote_visitors_detailsMaxAggregateInputType = {
    id?: true
    ip?: true
    time?: true
    type?: true
    account_id?: true
  }

  export type Znote_visitors_detailsCountAggregateInputType = {
    id?: true
    ip?: true
    time?: true
    type?: true
    account_id?: true
    _all?: true
  }

  export type Znote_visitors_detailsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_visitors_details to aggregate.
     */
    where?: znote_visitors_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_visitors_details to fetch.
     */
    orderBy?: Enumerable<znote_visitors_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: znote_visitors_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_visitors_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_visitors_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned znote_visitors_details
    **/
    _count?: true | Znote_visitors_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Znote_visitors_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Znote_visitors_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Znote_visitors_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Znote_visitors_detailsMaxAggregateInputType
  }

  export type GetZnote_visitors_detailsAggregateType<T extends Znote_visitors_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateZnote_visitors_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZnote_visitors_details[P]>
      : GetScalarType<T[P], AggregateZnote_visitors_details[P]>
  }




  export type Znote_visitors_detailsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: znote_visitors_detailsWhereInput
    orderBy?: Enumerable<znote_visitors_detailsOrderByWithAggregationInput>
    by: Znote_visitors_detailsScalarFieldEnum[]
    having?: znote_visitors_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Znote_visitors_detailsCountAggregateInputType | true
    _avg?: Znote_visitors_detailsAvgAggregateInputType
    _sum?: Znote_visitors_detailsSumAggregateInputType
    _min?: Znote_visitors_detailsMinAggregateInputType
    _max?: Znote_visitors_detailsMaxAggregateInputType
  }


  export type Znote_visitors_detailsGroupByOutputType = {
    id: number
    ip: bigint
    time: number
    type: number
    account_id: number
    _count: Znote_visitors_detailsCountAggregateOutputType | null
    _avg: Znote_visitors_detailsAvgAggregateOutputType | null
    _sum: Znote_visitors_detailsSumAggregateOutputType | null
    _min: Znote_visitors_detailsMinAggregateOutputType | null
    _max: Znote_visitors_detailsMaxAggregateOutputType | null
  }

  type GetZnote_visitors_detailsGroupByPayload<T extends Znote_visitors_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Znote_visitors_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Znote_visitors_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Znote_visitors_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Znote_visitors_detailsGroupByOutputType[P]>
        }
      >
    >


  export type znote_visitors_detailsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ip?: boolean
    time?: boolean
    type?: boolean
    account_id?: boolean
  }, ExtArgs["result"]["znote_visitors_details"]>

  export type znote_visitors_detailsSelectScalar = {
    id?: boolean
    ip?: boolean
    time?: boolean
    type?: boolean
    account_id?: boolean
  }


  type znote_visitors_detailsGetPayload<S extends boolean | null | undefined | znote_visitors_detailsArgs> = $Types.GetResult<znote_visitors_detailsPayload, S>

  type znote_visitors_detailsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<znote_visitors_detailsFindManyArgs, 'select' | 'include'> & {
      select?: Znote_visitors_detailsCountAggregateInputType | true
    }

  export interface znote_visitors_detailsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['znote_visitors_details'], meta: { name: 'znote_visitors_details' } }
    /**
     * Find zero or one Znote_visitors_details that matches the filter.
     * @param {znote_visitors_detailsFindUniqueArgs} args - Arguments to find a Znote_visitors_details
     * @example
     * // Get one Znote_visitors_details
     * const znote_visitors_details = await prisma.znote_visitors_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends znote_visitors_detailsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, znote_visitors_detailsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'znote_visitors_details'> extends True ? Prisma__znote_visitors_detailsClient<$Types.GetResult<znote_visitors_detailsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__znote_visitors_detailsClient<$Types.GetResult<znote_visitors_detailsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Znote_visitors_details that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {znote_visitors_detailsFindUniqueOrThrowArgs} args - Arguments to find a Znote_visitors_details
     * @example
     * // Get one Znote_visitors_details
     * const znote_visitors_details = await prisma.znote_visitors_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends znote_visitors_detailsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_visitors_detailsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__znote_visitors_detailsClient<$Types.GetResult<znote_visitors_detailsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Znote_visitors_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_visitors_detailsFindFirstArgs} args - Arguments to find a Znote_visitors_details
     * @example
     * // Get one Znote_visitors_details
     * const znote_visitors_details = await prisma.znote_visitors_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends znote_visitors_detailsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, znote_visitors_detailsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'znote_visitors_details'> extends True ? Prisma__znote_visitors_detailsClient<$Types.GetResult<znote_visitors_detailsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__znote_visitors_detailsClient<$Types.GetResult<znote_visitors_detailsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Znote_visitors_details that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_visitors_detailsFindFirstOrThrowArgs} args - Arguments to find a Znote_visitors_details
     * @example
     * // Get one Znote_visitors_details
     * const znote_visitors_details = await prisma.znote_visitors_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends znote_visitors_detailsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_visitors_detailsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__znote_visitors_detailsClient<$Types.GetResult<znote_visitors_detailsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Znote_visitors_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_visitors_detailsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Znote_visitors_details
     * const znote_visitors_details = await prisma.znote_visitors_details.findMany()
     * 
     * // Get first 10 Znote_visitors_details
     * const znote_visitors_details = await prisma.znote_visitors_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const znote_visitors_detailsWithIdOnly = await prisma.znote_visitors_details.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends znote_visitors_detailsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_visitors_detailsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<znote_visitors_detailsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Znote_visitors_details.
     * @param {znote_visitors_detailsCreateArgs} args - Arguments to create a Znote_visitors_details.
     * @example
     * // Create one Znote_visitors_details
     * const Znote_visitors_details = await prisma.znote_visitors_details.create({
     *   data: {
     *     // ... data to create a Znote_visitors_details
     *   }
     * })
     * 
    **/
    create<T extends znote_visitors_detailsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_visitors_detailsCreateArgs<ExtArgs>>
    ): Prisma__znote_visitors_detailsClient<$Types.GetResult<znote_visitors_detailsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Znote_visitors_details.
     *     @param {znote_visitors_detailsCreateManyArgs} args - Arguments to create many Znote_visitors_details.
     *     @example
     *     // Create many Znote_visitors_details
     *     const znote_visitors_details = await prisma.znote_visitors_details.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends znote_visitors_detailsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_visitors_detailsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Znote_visitors_details.
     * @param {znote_visitors_detailsDeleteArgs} args - Arguments to delete one Znote_visitors_details.
     * @example
     * // Delete one Znote_visitors_details
     * const Znote_visitors_details = await prisma.znote_visitors_details.delete({
     *   where: {
     *     // ... filter to delete one Znote_visitors_details
     *   }
     * })
     * 
    **/
    delete<T extends znote_visitors_detailsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, znote_visitors_detailsDeleteArgs<ExtArgs>>
    ): Prisma__znote_visitors_detailsClient<$Types.GetResult<znote_visitors_detailsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Znote_visitors_details.
     * @param {znote_visitors_detailsUpdateArgs} args - Arguments to update one Znote_visitors_details.
     * @example
     * // Update one Znote_visitors_details
     * const znote_visitors_details = await prisma.znote_visitors_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends znote_visitors_detailsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, znote_visitors_detailsUpdateArgs<ExtArgs>>
    ): Prisma__znote_visitors_detailsClient<$Types.GetResult<znote_visitors_detailsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Znote_visitors_details.
     * @param {znote_visitors_detailsDeleteManyArgs} args - Arguments to filter Znote_visitors_details to delete.
     * @example
     * // Delete a few Znote_visitors_details
     * const { count } = await prisma.znote_visitors_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends znote_visitors_detailsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, znote_visitors_detailsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Znote_visitors_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_visitors_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Znote_visitors_details
     * const znote_visitors_details = await prisma.znote_visitors_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends znote_visitors_detailsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, znote_visitors_detailsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Znote_visitors_details.
     * @param {znote_visitors_detailsUpsertArgs} args - Arguments to update or create a Znote_visitors_details.
     * @example
     * // Update or create a Znote_visitors_details
     * const znote_visitors_details = await prisma.znote_visitors_details.upsert({
     *   create: {
     *     // ... data to create a Znote_visitors_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Znote_visitors_details we want to update
     *   }
     * })
    **/
    upsert<T extends znote_visitors_detailsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, znote_visitors_detailsUpsertArgs<ExtArgs>>
    ): Prisma__znote_visitors_detailsClient<$Types.GetResult<znote_visitors_detailsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Znote_visitors_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {znote_visitors_detailsCountArgs} args - Arguments to filter Znote_visitors_details to count.
     * @example
     * // Count the number of Znote_visitors_details
     * const count = await prisma.znote_visitors_details.count({
     *   where: {
     *     // ... the filter for the Znote_visitors_details we want to count
     *   }
     * })
    **/
    count<T extends znote_visitors_detailsCountArgs>(
      args?: Subset<T, znote_visitors_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Znote_visitors_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Znote_visitors_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_visitors_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Znote_visitors_detailsAggregateArgs>(args: Subset<T, Znote_visitors_detailsAggregateArgs>): Prisma.PrismaPromise<GetZnote_visitors_detailsAggregateType<T>>

    /**
     * Group by Znote_visitors_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Znote_visitors_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Znote_visitors_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Znote_visitors_detailsGroupByArgs['orderBy'] }
        : { orderBy?: Znote_visitors_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Znote_visitors_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZnote_visitors_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for znote_visitors_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__znote_visitors_detailsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * znote_visitors_details base type for findUnique actions
   */
  export type znote_visitors_detailsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors_details
     */
    select?: znote_visitors_detailsSelect<ExtArgs> | null
    /**
     * Filter, which znote_visitors_details to fetch.
     */
    where: znote_visitors_detailsWhereUniqueInput
  }

  /**
   * znote_visitors_details findUnique
   */
  export interface znote_visitors_detailsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_visitors_detailsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_visitors_details findUniqueOrThrow
   */
  export type znote_visitors_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors_details
     */
    select?: znote_visitors_detailsSelect<ExtArgs> | null
    /**
     * Filter, which znote_visitors_details to fetch.
     */
    where: znote_visitors_detailsWhereUniqueInput
  }


  /**
   * znote_visitors_details base type for findFirst actions
   */
  export type znote_visitors_detailsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors_details
     */
    select?: znote_visitors_detailsSelect<ExtArgs> | null
    /**
     * Filter, which znote_visitors_details to fetch.
     */
    where?: znote_visitors_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_visitors_details to fetch.
     */
    orderBy?: Enumerable<znote_visitors_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_visitors_details.
     */
    cursor?: znote_visitors_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_visitors_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_visitors_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_visitors_details.
     */
    distinct?: Enumerable<Znote_visitors_detailsScalarFieldEnum>
  }

  /**
   * znote_visitors_details findFirst
   */
  export interface znote_visitors_detailsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends znote_visitors_detailsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * znote_visitors_details findFirstOrThrow
   */
  export type znote_visitors_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors_details
     */
    select?: znote_visitors_detailsSelect<ExtArgs> | null
    /**
     * Filter, which znote_visitors_details to fetch.
     */
    where?: znote_visitors_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_visitors_details to fetch.
     */
    orderBy?: Enumerable<znote_visitors_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for znote_visitors_details.
     */
    cursor?: znote_visitors_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_visitors_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_visitors_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of znote_visitors_details.
     */
    distinct?: Enumerable<Znote_visitors_detailsScalarFieldEnum>
  }


  /**
   * znote_visitors_details findMany
   */
  export type znote_visitors_detailsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors_details
     */
    select?: znote_visitors_detailsSelect<ExtArgs> | null
    /**
     * Filter, which znote_visitors_details to fetch.
     */
    where?: znote_visitors_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of znote_visitors_details to fetch.
     */
    orderBy?: Enumerable<znote_visitors_detailsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing znote_visitors_details.
     */
    cursor?: znote_visitors_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` znote_visitors_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` znote_visitors_details.
     */
    skip?: number
    distinct?: Enumerable<Znote_visitors_detailsScalarFieldEnum>
  }


  /**
   * znote_visitors_details create
   */
  export type znote_visitors_detailsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors_details
     */
    select?: znote_visitors_detailsSelect<ExtArgs> | null
    /**
     * The data needed to create a znote_visitors_details.
     */
    data: XOR<znote_visitors_detailsCreateInput, znote_visitors_detailsUncheckedCreateInput>
  }


  /**
   * znote_visitors_details createMany
   */
  export type znote_visitors_detailsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many znote_visitors_details.
     */
    data: Enumerable<znote_visitors_detailsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * znote_visitors_details update
   */
  export type znote_visitors_detailsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors_details
     */
    select?: znote_visitors_detailsSelect<ExtArgs> | null
    /**
     * The data needed to update a znote_visitors_details.
     */
    data: XOR<znote_visitors_detailsUpdateInput, znote_visitors_detailsUncheckedUpdateInput>
    /**
     * Choose, which znote_visitors_details to update.
     */
    where: znote_visitors_detailsWhereUniqueInput
  }


  /**
   * znote_visitors_details updateMany
   */
  export type znote_visitors_detailsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update znote_visitors_details.
     */
    data: XOR<znote_visitors_detailsUpdateManyMutationInput, znote_visitors_detailsUncheckedUpdateManyInput>
    /**
     * Filter which znote_visitors_details to update
     */
    where?: znote_visitors_detailsWhereInput
  }


  /**
   * znote_visitors_details upsert
   */
  export type znote_visitors_detailsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors_details
     */
    select?: znote_visitors_detailsSelect<ExtArgs> | null
    /**
     * The filter to search for the znote_visitors_details to update in case it exists.
     */
    where: znote_visitors_detailsWhereUniqueInput
    /**
     * In case the znote_visitors_details found by the `where` argument doesn't exist, create a new znote_visitors_details with this data.
     */
    create: XOR<znote_visitors_detailsCreateInput, znote_visitors_detailsUncheckedCreateInput>
    /**
     * In case the znote_visitors_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<znote_visitors_detailsUpdateInput, znote_visitors_detailsUncheckedUpdateInput>
  }


  /**
   * znote_visitors_details delete
   */
  export type znote_visitors_detailsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors_details
     */
    select?: znote_visitors_detailsSelect<ExtArgs> | null
    /**
     * Filter which znote_visitors_details to delete.
     */
    where: znote_visitors_detailsWhereUniqueInput
  }


  /**
   * znote_visitors_details deleteMany
   */
  export type znote_visitors_detailsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which znote_visitors_details to delete
     */
    where?: znote_visitors_detailsWhereInput
  }


  /**
   * znote_visitors_details without action
   */
  export type znote_visitors_detailsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the znote_visitors_details
     */
    select?: znote_visitors_detailsSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    password: 'password',
    secret: 'secret',
    type: 'type',
    premium_ends_at: 'premium_ends_at',
    email: 'email',
    creation: 'creation',
    premium_points: 'premium_points',
    premdays: 'premdays',
    wallet: 'wallet',
    alpha_key: 'alpha_key'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    group_id: 'group_id',
    account_id: 'account_id',
    level: 'level',
    vocation: 'vocation',
    health: 'health',
    healthmax: 'healthmax',
    experience: 'experience',
    lookbody: 'lookbody',
    lookfeet: 'lookfeet',
    lookhead: 'lookhead',
    looklegs: 'looklegs',
    looktype: 'looktype',
    lookaddons: 'lookaddons',
    direction: 'direction',
    maglevel: 'maglevel',
    mana: 'mana',
    manamax: 'manamax',
    manaspent: 'manaspent',
    soul: 'soul',
    town_id: 'town_id',
    posx: 'posx',
    posy: 'posy',
    posz: 'posz',
    conditions: 'conditions',
    cap: 'cap',
    sex: 'sex',
    lastlogin: 'lastlogin',
    lastip: 'lastip',
    save: 'save',
    skull: 'skull',
    skulltime: 'skulltime',
    lastlogout: 'lastlogout',
    blessings: 'blessings',
    onlinetime: 'onlinetime',
    deletion: 'deletion',
    balance: 'balance',
    offlinetraining_time: 'offlinetraining_time',
    offlinetraining_skill: 'offlinetraining_skill',
    stamina: 'stamina',
    skill_fist: 'skill_fist',
    skill_fist_tries: 'skill_fist_tries',
    skill_club: 'skill_club',
    skill_club_tries: 'skill_club_tries',
    skill_sword: 'skill_sword',
    skill_sword_tries: 'skill_sword_tries',
    skill_axe: 'skill_axe',
    skill_axe_tries: 'skill_axe_tries',
    skill_dist: 'skill_dist',
    skill_dist_tries: 'skill_dist_tries',
    skill_shielding: 'skill_shielding',
    skill_shielding_tries: 'skill_shielding_tries',
    skill_fishing: 'skill_fishing',
    skill_fishing_tries: 'skill_fishing_tries',
    stat_str: 'stat_str',
    stat_int: 'stat_int',
    stat_dex: 'stat_dex',
    stat_vit: 'stat_vit',
    stat_spr: 'stat_spr',
    stat_wis: 'stat_wis'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const HouseScalarFieldEnum: {
    id: 'id',
    owner: 'owner',
    paid: 'paid',
    warnings: 'warnings',
    name: 'name',
    rent: 'rent',
    town_id: 'town_id',
    bid: 'bid',
    bid_end: 'bid_end',
    last_bid: 'last_bid',
    highest_bidder: 'highest_bidder',
    size: 'size',
    beds: 'beds',
    land_zone: 'land_zone',
    land_plot: 'land_plot',
    bioma: 'bioma',
    land_size: 'land_size',
    plant: 'plant',
    harvest: 'harvest',
    mining: 'mining',
    livestock: 'livestock',
    fishing_boat: 'fishing_boat',
    json_data: 'json_data',
    enable: 'enable'
  };

  export type HouseScalarFieldEnum = (typeof HouseScalarFieldEnum)[keyof typeof HouseScalarFieldEnum]


  export const Account_ban_historyScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    reason: 'reason',
    banned_at: 'banned_at',
    expired_at: 'expired_at',
    banned_by: 'banned_by'
  };

  export type Account_ban_historyScalarFieldEnum = (typeof Account_ban_historyScalarFieldEnum)[keyof typeof Account_ban_historyScalarFieldEnum]


  export const Account_bansScalarFieldEnum: {
    account_id: 'account_id',
    reason: 'reason',
    banned_at: 'banned_at',
    expires_at: 'expires_at',
    banned_by: 'banned_by'
  };

  export type Account_bansScalarFieldEnum = (typeof Account_bansScalarFieldEnum)[keyof typeof Account_bansScalarFieldEnum]


  export const Account_storageScalarFieldEnum: {
    account_id: 'account_id',
    key: 'key',
    value: 'value'
  };

  export type Account_storageScalarFieldEnum = (typeof Account_storageScalarFieldEnum)[keyof typeof Account_storageScalarFieldEnum]


  export const Account_viplistScalarFieldEnum: {
    account_id: 'account_id',
    player_id: 'player_id',
    description: 'description',
    icon: 'icon',
    notify: 'notify'
  };

  export type Account_viplistScalarFieldEnum = (typeof Account_viplistScalarFieldEnum)[keyof typeof Account_viplistScalarFieldEnum]


  export const Guild_invitesScalarFieldEnum: {
    player_id: 'player_id',
    guild_id: 'guild_id'
  };

  export type Guild_invitesScalarFieldEnum = (typeof Guild_invitesScalarFieldEnum)[keyof typeof Guild_invitesScalarFieldEnum]


  export const Guild_membershipScalarFieldEnum: {
    player_id: 'player_id',
    guild_id: 'guild_id',
    rank_id: 'rank_id',
    nick: 'nick'
  };

  export type Guild_membershipScalarFieldEnum = (typeof Guild_membershipScalarFieldEnum)[keyof typeof Guild_membershipScalarFieldEnum]


  export const Guild_ranksScalarFieldEnum: {
    id: 'id',
    guild_id: 'guild_id',
    name: 'name',
    level: 'level'
  };

  export type Guild_ranksScalarFieldEnum = (typeof Guild_ranksScalarFieldEnum)[keyof typeof Guild_ranksScalarFieldEnum]


  export const Guild_warsScalarFieldEnum: {
    id: 'id',
    guild1: 'guild1',
    guild2: 'guild2',
    name1: 'name1',
    name2: 'name2',
    status: 'status',
    started: 'started',
    ended: 'ended'
  };

  export type Guild_warsScalarFieldEnum = (typeof Guild_warsScalarFieldEnum)[keyof typeof Guild_warsScalarFieldEnum]


  export const GuildsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ownerid: 'ownerid',
    creationdata: 'creationdata',
    motd: 'motd'
  };

  export type GuildsScalarFieldEnum = (typeof GuildsScalarFieldEnum)[keyof typeof GuildsScalarFieldEnum]


  export const Guildwar_killsScalarFieldEnum: {
    id: 'id',
    killer: 'killer',
    target: 'target',
    killerguild: 'killerguild',
    targetguild: 'targetguild',
    warid: 'warid',
    time: 'time'
  };

  export type Guildwar_killsScalarFieldEnum = (typeof Guildwar_killsScalarFieldEnum)[keyof typeof Guildwar_killsScalarFieldEnum]


  export const Ip_bansScalarFieldEnum: {
    ip: 'ip',
    reason: 'reason',
    banned_at: 'banned_at',
    expires_at: 'expires_at',
    banned_by: 'banned_by'
  };

  export type Ip_bansScalarFieldEnum = (typeof Ip_bansScalarFieldEnum)[keyof typeof Ip_bansScalarFieldEnum]


  export const Market_historyScalarFieldEnum: {
    id: 'id',
    player_id: 'player_id',
    sale: 'sale',
    itemtype: 'itemtype',
    amount: 'amount',
    price: 'price',
    expires_at: 'expires_at',
    inserted: 'inserted',
    state: 'state'
  };

  export type Market_historyScalarFieldEnum = (typeof Market_historyScalarFieldEnum)[keyof typeof Market_historyScalarFieldEnum]


  export const Market_offersScalarFieldEnum: {
    id: 'id',
    player_id: 'player_id',
    sale: 'sale',
    itemtype: 'itemtype',
    amount: 'amount',
    created: 'created',
    anonymous: 'anonymous',
    price: 'price'
  };

  export type Market_offersScalarFieldEnum = (typeof Market_offersScalarFieldEnum)[keyof typeof Market_offersScalarFieldEnum]


  export const PetsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    rank: 'rank',
    stage: 'stage',
    name: 'name',
    pet: 'pet',
    owner: 'owner',
    level: 'level',
    experience: 'experience',
    addonItem: 'addonItem',
    strength: 'strength',
    wisdom: 'wisdom',
    agility: 'agility',
    sustain: 'sustain',
    magicResistance: 'magicResistance',
    lucky: 'lucky',
    hungry: 'hungry',
    hygiene: 'hygiene',
    happiness: 'happiness',
    health: 'health',
    cooldowns: 'cooldowns',
    world_id: 'world_id',
    wallet: 'wallet'
  };

  export type PetsScalarFieldEnum = (typeof PetsScalarFieldEnum)[keyof typeof PetsScalarFieldEnum]


  export const Player_depotitemsScalarFieldEnum: {
    player_id: 'player_id',
    sid: 'sid',
    pid: 'pid',
    itemtype: 'itemtype',
    count: 'count',
    attributes: 'attributes',
    json_data: 'json_data'
  };

  export type Player_depotitemsScalarFieldEnum = (typeof Player_depotitemsScalarFieldEnum)[keyof typeof Player_depotitemsScalarFieldEnum]


  export const Player_inboxitemsScalarFieldEnum: {
    player_id: 'player_id',
    sid: 'sid',
    pid: 'pid',
    itemtype: 'itemtype',
    count: 'count',
    attributes: 'attributes',
    json_data: 'json_data'
  };

  export type Player_inboxitemsScalarFieldEnum = (typeof Player_inboxitemsScalarFieldEnum)[keyof typeof Player_inboxitemsScalarFieldEnum]


  export const Player_namelocksScalarFieldEnum: {
    player_id: 'player_id',
    reason: 'reason',
    namelocked_at: 'namelocked_at',
    namelocked_by: 'namelocked_by'
  };

  export type Player_namelocksScalarFieldEnum = (typeof Player_namelocksScalarFieldEnum)[keyof typeof Player_namelocksScalarFieldEnum]


  export const Player_storageScalarFieldEnum: {
    player_id: 'player_id',
    key: 'key',
    value: 'value'
  };

  export type Player_storageScalarFieldEnum = (typeof Player_storageScalarFieldEnum)[keyof typeof Player_storageScalarFieldEnum]


  export const Player_storeinboxitemsScalarFieldEnum: {
    player_id: 'player_id',
    sid: 'sid',
    pid: 'pid',
    itemtype: 'itemtype',
    count: 'count',
    attributes: 'attributes',
    json_data: 'json_data'
  };

  export type Player_storeinboxitemsScalarFieldEnum = (typeof Player_storeinboxitemsScalarFieldEnum)[keyof typeof Player_storeinboxitemsScalarFieldEnum]


  export const Players_onlineScalarFieldEnum: {
    player_id: 'player_id'
  };

  export type Players_onlineScalarFieldEnum = (typeof Players_onlineScalarFieldEnum)[keyof typeof Players_onlineScalarFieldEnum]


  export const Server_configScalarFieldEnum: {
    config: 'config',
    value: 'value'
  };

  export type Server_configScalarFieldEnum = (typeof Server_configScalarFieldEnum)[keyof typeof Server_configScalarFieldEnum]


  export const Shop_historyScalarFieldEnum: {
    id: 'id',
    account: 'account',
    player: 'player',
    date: 'date',
    title: 'title',
    cost: 'cost',
    details: 'details'
  };

  export type Shop_historyScalarFieldEnum = (typeof Shop_historyScalarFieldEnum)[keyof typeof Shop_historyScalarFieldEnum]


  export const TownsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    posx: 'posx',
    posy: 'posy',
    posz: 'posz'
  };

  export type TownsScalarFieldEnum = (typeof TownsScalarFieldEnum)[keyof typeof TownsScalarFieldEnum]


  export const ZnoteScalarFieldEnum: {
    id: 'id',
    version: 'version',
    installed: 'installed',
    cached: 'cached'
  };

  export type ZnoteScalarFieldEnum = (typeof ZnoteScalarFieldEnum)[keyof typeof ZnoteScalarFieldEnum]


  export const Znote_accountsScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    ip: 'ip',
    created: 'created',
    points: 'points',
    cooldown: 'cooldown',
    active: 'active',
    active_email: 'active_email',
    activekey: 'activekey',
    flag: 'flag',
    secret: 'secret'
  };

  export type Znote_accountsScalarFieldEnum = (typeof Znote_accountsScalarFieldEnum)[keyof typeof Znote_accountsScalarFieldEnum]


  export const Znote_auction_playerScalarFieldEnum: {
    id: 'id',
    player_id: 'player_id',
    original_account_id: 'original_account_id',
    bidder_account_id: 'bidder_account_id',
    time_begin: 'time_begin',
    time_end: 'time_end',
    price: 'price',
    bid: 'bid',
    deposit: 'deposit',
    sold: 'sold',
    claimed: 'claimed'
  };

  export type Znote_auction_playerScalarFieldEnum = (typeof Znote_auction_playerScalarFieldEnum)[keyof typeof Znote_auction_playerScalarFieldEnum]


  export const Znote_changelogScalarFieldEnum: {
    id: 'id',
    text: 'text',
    time: 'time',
    report_id: 'report_id',
    status: 'status'
  };

  export type Znote_changelogScalarFieldEnum = (typeof Znote_changelogScalarFieldEnum)[keyof typeof Znote_changelogScalarFieldEnum]


  export const Znote_deleted_charactersScalarFieldEnum: {
    id: 'id',
    original_account_id: 'original_account_id',
    character_name: 'character_name',
    time: 'time',
    done: 'done'
  };

  export type Znote_deleted_charactersScalarFieldEnum = (typeof Znote_deleted_charactersScalarFieldEnum)[keyof typeof Znote_deleted_charactersScalarFieldEnum]


  export const Znote_forumScalarFieldEnum: {
    id: 'id',
    name: 'name',
    access: 'access',
    closed: 'closed',
    hidden: 'hidden',
    guild_id: 'guild_id'
  };

  export type Znote_forumScalarFieldEnum = (typeof Znote_forumScalarFieldEnum)[keyof typeof Znote_forumScalarFieldEnum]


  export const Znote_forum_postsScalarFieldEnum: {
    id: 'id',
    thread_id: 'thread_id',
    player_id: 'player_id',
    player_name: 'player_name',
    text: 'text',
    created: 'created',
    updated: 'updated'
  };

  export type Znote_forum_postsScalarFieldEnum = (typeof Znote_forum_postsScalarFieldEnum)[keyof typeof Znote_forum_postsScalarFieldEnum]


  export const Znote_forum_threadsScalarFieldEnum: {
    id: 'id',
    forum_id: 'forum_id',
    player_id: 'player_id',
    player_name: 'player_name',
    title: 'title',
    text: 'text',
    created: 'created',
    updated: 'updated',
    sticky: 'sticky',
    hidden: 'hidden',
    closed: 'closed'
  };

  export type Znote_forum_threadsScalarFieldEnum = (typeof Znote_forum_threadsScalarFieldEnum)[keyof typeof Znote_forum_threadsScalarFieldEnum]


  export const Znote_global_storageScalarFieldEnum: {
    key: 'key',
    value: 'value'
  };

  export type Znote_global_storageScalarFieldEnum = (typeof Znote_global_storageScalarFieldEnum)[keyof typeof Znote_global_storageScalarFieldEnum]


  export const Znote_guild_warsScalarFieldEnum: {
    id: 'id',
    limit: 'limit'
  };

  export type Znote_guild_warsScalarFieldEnum = (typeof Znote_guild_warsScalarFieldEnum)[keyof typeof Znote_guild_warsScalarFieldEnum]


  export const Znote_imagesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    desc: 'desc',
    date: 'date',
    status: 'status',
    image: 'image',
    delhash: 'delhash',
    account_id: 'account_id'
  };

  export type Znote_imagesScalarFieldEnum = (typeof Znote_imagesScalarFieldEnum)[keyof typeof Znote_imagesScalarFieldEnum]


  export const Znote_newsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    text: 'text',
    date: 'date',
    pid: 'pid'
  };

  export type Znote_newsScalarFieldEnum = (typeof Znote_newsScalarFieldEnum)[keyof typeof Znote_newsScalarFieldEnum]


  export const Znote_paygolScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    price: 'price',
    points: 'points',
    message_id: 'message_id',
    service_id: 'service_id',
    shortcode: 'shortcode',
    keyword: 'keyword',
    message: 'message',
    sender: 'sender',
    operator: 'operator',
    country: 'country',
    currency: 'currency'
  };

  export type Znote_paygolScalarFieldEnum = (typeof Znote_paygolScalarFieldEnum)[keyof typeof Znote_paygolScalarFieldEnum]


  export const Znote_paypalScalarFieldEnum: {
    id: 'id',
    txn_id: 'txn_id',
    email: 'email',
    accid: 'accid',
    price: 'price',
    points: 'points'
  };

  export type Znote_paypalScalarFieldEnum = (typeof Znote_paypalScalarFieldEnum)[keyof typeof Znote_paypalScalarFieldEnum]


  export const Znote_player_reportsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    posx: 'posx',
    posy: 'posy',
    posz: 'posz',
    report_description: 'report_description',
    date: 'date',
    status: 'status'
  };

  export type Znote_player_reportsScalarFieldEnum = (typeof Znote_player_reportsScalarFieldEnum)[keyof typeof Znote_player_reportsScalarFieldEnum]


  export const Znote_playersScalarFieldEnum: {
    id: 'id',
    player_id: 'player_id',
    created: 'created',
    hide_char: 'hide_char',
    comment: 'comment'
  };

  export type Znote_playersScalarFieldEnum = (typeof Znote_playersScalarFieldEnum)[keyof typeof Znote_playersScalarFieldEnum]


  export const Znote_shopScalarFieldEnum: {
    id: 'id',
    type: 'type',
    itemid: 'itemid',
    count: 'count',
    description: 'description',
    points: 'points'
  };

  export type Znote_shopScalarFieldEnum = (typeof Znote_shopScalarFieldEnum)[keyof typeof Znote_shopScalarFieldEnum]


  export const Znote_shop_logsScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    player_id: 'player_id',
    type: 'type',
    itemid: 'itemid',
    count: 'count',
    points: 'points',
    time: 'time'
  };

  export type Znote_shop_logsScalarFieldEnum = (typeof Znote_shop_logsScalarFieldEnum)[keyof typeof Znote_shop_logsScalarFieldEnum]


  export const Znote_shop_ordersScalarFieldEnum: {
    id: 'id',
    account_id: 'account_id',
    type: 'type',
    itemid: 'itemid',
    count: 'count',
    time: 'time'
  };

  export type Znote_shop_ordersScalarFieldEnum = (typeof Znote_shop_ordersScalarFieldEnum)[keyof typeof Znote_shop_ordersScalarFieldEnum]


  export const Znote_ticketsScalarFieldEnum: {
    id: 'id',
    owner: 'owner',
    username: 'username',
    subject: 'subject',
    message: 'message',
    ip: 'ip',
    creation: 'creation',
    status: 'status'
  };

  export type Znote_ticketsScalarFieldEnum = (typeof Znote_ticketsScalarFieldEnum)[keyof typeof Znote_ticketsScalarFieldEnum]


  export const Znote_tickets_repliesScalarFieldEnum: {
    id: 'id',
    tid: 'tid',
    username: 'username',
    message: 'message',
    created: 'created'
  };

  export type Znote_tickets_repliesScalarFieldEnum = (typeof Znote_tickets_repliesScalarFieldEnum)[keyof typeof Znote_tickets_repliesScalarFieldEnum]


  export const Znote_visitorsScalarFieldEnum: {
    id: 'id',
    ip: 'ip',
    value: 'value'
  };

  export type Znote_visitorsScalarFieldEnum = (typeof Znote_visitorsScalarFieldEnum)[keyof typeof Znote_visitorsScalarFieldEnum]


  export const Znote_visitors_detailsScalarFieldEnum: {
    id: 'id',
    ip: 'ip',
    time: 'time',
    type: 'type',
    account_id: 'account_id'
  };

  export type Znote_visitors_detailsScalarFieldEnum = (typeof Znote_visitors_detailsScalarFieldEnum)[keyof typeof Znote_visitors_detailsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: Enumerable<AccountWhereInput>
    OR?: Enumerable<AccountWhereInput>
    NOT?: Enumerable<AccountWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    password?: StringFilter | string
    secret?: StringNullableFilter | string | null
    type?: IntFilter | number
    premium_ends_at?: IntFilter | number
    email?: StringFilter | string
    creation?: IntFilter | number
    premium_points?: IntFilter | number
    premdays?: IntFilter | number
    wallet?: StringNullableFilter | string | null
    alpha_key?: StringNullableFilter | string | null
    account_ban_history?: Account_ban_historyListRelationFilter
    account_bans?: XOR<Account_bansRelationFilter, account_bansWhereInput> | null
    account_storage?: Account_storageListRelationFilter
    account_viplist?: Account_viplistListRelationFilter
    players?: PlayerListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    secret?: SortOrderInput | SortOrder
    type?: SortOrder
    premium_ends_at?: SortOrder
    email?: SortOrder
    creation?: SortOrder
    premium_points?: SortOrder
    premdays?: SortOrder
    wallet?: SortOrderInput | SortOrder
    alpha_key?: SortOrderInput | SortOrder
    account_ban_history?: account_ban_historyOrderByRelationAggregateInput
    account_bans?: account_bansOrderByWithRelationInput
    account_storage?: account_storageOrderByRelationAggregateInput
    account_viplist?: account_viplistOrderByRelationAggregateInput
    players?: PlayerOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    secret?: SortOrderInput | SortOrder
    type?: SortOrder
    premium_ends_at?: SortOrder
    email?: SortOrder
    creation?: SortOrder
    premium_points?: SortOrder
    premdays?: SortOrder
    wallet?: SortOrderInput | SortOrder
    alpha_key?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AccountScalarWhereWithAggregatesInput>
    OR?: Enumerable<AccountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AccountScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    secret?: StringNullableWithAggregatesFilter | string | null
    type?: IntWithAggregatesFilter | number
    premium_ends_at?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    creation?: IntWithAggregatesFilter | number
    premium_points?: IntWithAggregatesFilter | number
    premdays?: IntWithAggregatesFilter | number
    wallet?: StringNullableWithAggregatesFilter | string | null
    alpha_key?: StringNullableWithAggregatesFilter | string | null
  }

  export type PlayerWhereInput = {
    AND?: Enumerable<PlayerWhereInput>
    OR?: Enumerable<PlayerWhereInput>
    NOT?: Enumerable<PlayerWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    group_id?: IntFilter | number
    account_id?: IntFilter | number
    level?: IntFilter | number
    vocation?: IntFilter | number
    health?: IntFilter | number
    healthmax?: IntFilter | number
    experience?: BigIntFilter | bigint | number
    lookbody?: IntFilter | number
    lookfeet?: IntFilter | number
    lookhead?: IntFilter | number
    looklegs?: IntFilter | number
    looktype?: IntFilter | number
    lookaddons?: IntFilter | number
    direction?: IntFilter | number
    maglevel?: IntFilter | number
    mana?: IntFilter | number
    manamax?: IntFilter | number
    manaspent?: BigIntFilter | bigint | number
    soul?: IntFilter | number
    town_id?: IntFilter | number
    posx?: IntFilter | number
    posy?: IntFilter | number
    posz?: IntFilter | number
    conditions?: BytesFilter | Buffer
    cap?: IntFilter | number
    sex?: IntFilter | number
    lastlogin?: BigIntFilter | bigint | number
    lastip?: IntFilter | number
    save?: BoolFilter | boolean
    skull?: BoolFilter | boolean
    skulltime?: BigIntFilter | bigint | number
    lastlogout?: BigIntFilter | bigint | number
    blessings?: IntFilter | number
    onlinetime?: BigIntFilter | bigint | number
    deletion?: BigIntFilter | bigint | number
    balance?: BigIntFilter | bigint | number
    offlinetraining_time?: IntFilter | number
    offlinetraining_skill?: IntFilter | number
    stamina?: IntFilter | number
    skill_fist?: IntFilter | number
    skill_fist_tries?: BigIntFilter | bigint | number
    skill_club?: IntFilter | number
    skill_club_tries?: BigIntFilter | bigint | number
    skill_sword?: IntFilter | number
    skill_sword_tries?: BigIntFilter | bigint | number
    skill_axe?: IntFilter | number
    skill_axe_tries?: BigIntFilter | bigint | number
    skill_dist?: IntFilter | number
    skill_dist_tries?: BigIntFilter | bigint | number
    skill_shielding?: IntFilter | number
    skill_shielding_tries?: BigIntFilter | bigint | number
    skill_fishing?: IntFilter | number
    skill_fishing_tries?: BigIntFilter | bigint | number
    stat_str?: IntFilter | number
    stat_int?: IntFilter | number
    stat_dex?: IntFilter | number
    stat_vit?: IntFilter | number
    stat_spr?: IntFilter | number
    stat_wis?: IntFilter | number
    account_ban_history?: Account_ban_historyListRelationFilter
    account_bans?: Account_bansListRelationFilter
    account_viplist?: Account_viplistListRelationFilter
    guild_invites?: Guild_invitesListRelationFilter
    guild_membership?: XOR<Guild_membershipRelationFilter, guild_membershipWhereInput> | null
    guilds?: XOR<GuildsRelationFilter, guildsWhereInput> | null
    ip_bans?: Ip_bansListRelationFilter
    market_history?: Market_historyListRelationFilter
    market_offers?: Market_offersListRelationFilter
    player_depotitems?: Player_depotitemsListRelationFilter
    player_inboxitems?: Player_inboxitemsListRelationFilter
    player_namelocks_player_namelocks_player_idToplayers?: XOR<Player_namelocksRelationFilter, player_namelocksWhereInput> | null
    player_namelocks_player_namelocks_namelocked_byToplayers?: Player_namelocksListRelationFilter
    player_storage?: Player_storageListRelationFilter
    player_storeinboxitems?: Player_storeinboxitemsListRelationFilter
    accounts?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type PlayerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    group_id?: SortOrder
    account_id?: SortOrder
    level?: SortOrder
    vocation?: SortOrder
    health?: SortOrder
    healthmax?: SortOrder
    experience?: SortOrder
    lookbody?: SortOrder
    lookfeet?: SortOrder
    lookhead?: SortOrder
    looklegs?: SortOrder
    looktype?: SortOrder
    lookaddons?: SortOrder
    direction?: SortOrder
    maglevel?: SortOrder
    mana?: SortOrder
    manamax?: SortOrder
    manaspent?: SortOrder
    soul?: SortOrder
    town_id?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    conditions?: SortOrder
    cap?: SortOrder
    sex?: SortOrder
    lastlogin?: SortOrder
    lastip?: SortOrder
    save?: SortOrder
    skull?: SortOrder
    skulltime?: SortOrder
    lastlogout?: SortOrder
    blessings?: SortOrder
    onlinetime?: SortOrder
    deletion?: SortOrder
    balance?: SortOrder
    offlinetraining_time?: SortOrder
    offlinetraining_skill?: SortOrder
    stamina?: SortOrder
    skill_fist?: SortOrder
    skill_fist_tries?: SortOrder
    skill_club?: SortOrder
    skill_club_tries?: SortOrder
    skill_sword?: SortOrder
    skill_sword_tries?: SortOrder
    skill_axe?: SortOrder
    skill_axe_tries?: SortOrder
    skill_dist?: SortOrder
    skill_dist_tries?: SortOrder
    skill_shielding?: SortOrder
    skill_shielding_tries?: SortOrder
    skill_fishing?: SortOrder
    skill_fishing_tries?: SortOrder
    stat_str?: SortOrder
    stat_int?: SortOrder
    stat_dex?: SortOrder
    stat_vit?: SortOrder
    stat_spr?: SortOrder
    stat_wis?: SortOrder
    account_ban_history?: account_ban_historyOrderByRelationAggregateInput
    account_bans?: account_bansOrderByRelationAggregateInput
    account_viplist?: account_viplistOrderByRelationAggregateInput
    guild_invites?: guild_invitesOrderByRelationAggregateInput
    guild_membership?: guild_membershipOrderByWithRelationInput
    guilds?: guildsOrderByWithRelationInput
    ip_bans?: ip_bansOrderByRelationAggregateInput
    market_history?: market_historyOrderByRelationAggregateInput
    market_offers?: market_offersOrderByRelationAggregateInput
    player_depotitems?: player_depotitemsOrderByRelationAggregateInput
    player_inboxitems?: player_inboxitemsOrderByRelationAggregateInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksOrderByWithRelationInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksOrderByRelationAggregateInput
    player_storage?: player_storageOrderByRelationAggregateInput
    player_storeinboxitems?: player_storeinboxitemsOrderByRelationAggregateInput
    accounts?: AccountOrderByWithRelationInput
  }

  export type PlayerWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type PlayerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    group_id?: SortOrder
    account_id?: SortOrder
    level?: SortOrder
    vocation?: SortOrder
    health?: SortOrder
    healthmax?: SortOrder
    experience?: SortOrder
    lookbody?: SortOrder
    lookfeet?: SortOrder
    lookhead?: SortOrder
    looklegs?: SortOrder
    looktype?: SortOrder
    lookaddons?: SortOrder
    direction?: SortOrder
    maglevel?: SortOrder
    mana?: SortOrder
    manamax?: SortOrder
    manaspent?: SortOrder
    soul?: SortOrder
    town_id?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    conditions?: SortOrder
    cap?: SortOrder
    sex?: SortOrder
    lastlogin?: SortOrder
    lastip?: SortOrder
    save?: SortOrder
    skull?: SortOrder
    skulltime?: SortOrder
    lastlogout?: SortOrder
    blessings?: SortOrder
    onlinetime?: SortOrder
    deletion?: SortOrder
    balance?: SortOrder
    offlinetraining_time?: SortOrder
    offlinetraining_skill?: SortOrder
    stamina?: SortOrder
    skill_fist?: SortOrder
    skill_fist_tries?: SortOrder
    skill_club?: SortOrder
    skill_club_tries?: SortOrder
    skill_sword?: SortOrder
    skill_sword_tries?: SortOrder
    skill_axe?: SortOrder
    skill_axe_tries?: SortOrder
    skill_dist?: SortOrder
    skill_dist_tries?: SortOrder
    skill_shielding?: SortOrder
    skill_shielding_tries?: SortOrder
    skill_fishing?: SortOrder
    skill_fishing_tries?: SortOrder
    stat_str?: SortOrder
    stat_int?: SortOrder
    stat_dex?: SortOrder
    stat_vit?: SortOrder
    stat_spr?: SortOrder
    stat_wis?: SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _avg?: PlayerAvgOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
    _sum?: PlayerSumOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PlayerScalarWhereWithAggregatesInput>
    OR?: Enumerable<PlayerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PlayerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    group_id?: IntWithAggregatesFilter | number
    account_id?: IntWithAggregatesFilter | number
    level?: IntWithAggregatesFilter | number
    vocation?: IntWithAggregatesFilter | number
    health?: IntWithAggregatesFilter | number
    healthmax?: IntWithAggregatesFilter | number
    experience?: BigIntWithAggregatesFilter | bigint | number
    lookbody?: IntWithAggregatesFilter | number
    lookfeet?: IntWithAggregatesFilter | number
    lookhead?: IntWithAggregatesFilter | number
    looklegs?: IntWithAggregatesFilter | number
    looktype?: IntWithAggregatesFilter | number
    lookaddons?: IntWithAggregatesFilter | number
    direction?: IntWithAggregatesFilter | number
    maglevel?: IntWithAggregatesFilter | number
    mana?: IntWithAggregatesFilter | number
    manamax?: IntWithAggregatesFilter | number
    manaspent?: BigIntWithAggregatesFilter | bigint | number
    soul?: IntWithAggregatesFilter | number
    town_id?: IntWithAggregatesFilter | number
    posx?: IntWithAggregatesFilter | number
    posy?: IntWithAggregatesFilter | number
    posz?: IntWithAggregatesFilter | number
    conditions?: BytesWithAggregatesFilter | Buffer
    cap?: IntWithAggregatesFilter | number
    sex?: IntWithAggregatesFilter | number
    lastlogin?: BigIntWithAggregatesFilter | bigint | number
    lastip?: IntWithAggregatesFilter | number
    save?: BoolWithAggregatesFilter | boolean
    skull?: BoolWithAggregatesFilter | boolean
    skulltime?: BigIntWithAggregatesFilter | bigint | number
    lastlogout?: BigIntWithAggregatesFilter | bigint | number
    blessings?: IntWithAggregatesFilter | number
    onlinetime?: BigIntWithAggregatesFilter | bigint | number
    deletion?: BigIntWithAggregatesFilter | bigint | number
    balance?: BigIntWithAggregatesFilter | bigint | number
    offlinetraining_time?: IntWithAggregatesFilter | number
    offlinetraining_skill?: IntWithAggregatesFilter | number
    stamina?: IntWithAggregatesFilter | number
    skill_fist?: IntWithAggregatesFilter | number
    skill_fist_tries?: BigIntWithAggregatesFilter | bigint | number
    skill_club?: IntWithAggregatesFilter | number
    skill_club_tries?: BigIntWithAggregatesFilter | bigint | number
    skill_sword?: IntWithAggregatesFilter | number
    skill_sword_tries?: BigIntWithAggregatesFilter | bigint | number
    skill_axe?: IntWithAggregatesFilter | number
    skill_axe_tries?: BigIntWithAggregatesFilter | bigint | number
    skill_dist?: IntWithAggregatesFilter | number
    skill_dist_tries?: BigIntWithAggregatesFilter | bigint | number
    skill_shielding?: IntWithAggregatesFilter | number
    skill_shielding_tries?: BigIntWithAggregatesFilter | bigint | number
    skill_fishing?: IntWithAggregatesFilter | number
    skill_fishing_tries?: BigIntWithAggregatesFilter | bigint | number
    stat_str?: IntWithAggregatesFilter | number
    stat_int?: IntWithAggregatesFilter | number
    stat_dex?: IntWithAggregatesFilter | number
    stat_vit?: IntWithAggregatesFilter | number
    stat_spr?: IntWithAggregatesFilter | number
    stat_wis?: IntWithAggregatesFilter | number
  }

  export type HouseWhereInput = {
    AND?: Enumerable<HouseWhereInput>
    OR?: Enumerable<HouseWhereInput>
    NOT?: Enumerable<HouseWhereInput>
    id?: IntFilter | number
    owner?: IntFilter | number
    paid?: IntFilter | number
    warnings?: IntFilter | number
    name?: StringFilter | string
    rent?: IntFilter | number
    town_id?: IntFilter | number
    bid?: IntFilter | number
    bid_end?: IntFilter | number
    last_bid?: IntFilter | number
    highest_bidder?: IntFilter | number
    size?: IntFilter | number
    beds?: IntFilter | number
    land_zone?: StringFilter | string
    land_plot?: StringFilter | string
    bioma?: StringFilter | string
    land_size?: StringFilter | string
    plant?: StringFilter | string
    harvest?: StringFilter | string
    mining?: StringFilter | string
    livestock?: StringFilter | string
    fishing_boat?: StringFilter | string
    json_data?: JsonNullableFilter
    enable?: BoolFilter | boolean
  }

  export type HouseOrderByWithRelationInput = {
    id?: SortOrder
    owner?: SortOrder
    paid?: SortOrder
    warnings?: SortOrder
    name?: SortOrder
    rent?: SortOrder
    town_id?: SortOrder
    bid?: SortOrder
    bid_end?: SortOrder
    last_bid?: SortOrder
    highest_bidder?: SortOrder
    size?: SortOrder
    beds?: SortOrder
    land_zone?: SortOrder
    land_plot?: SortOrder
    bioma?: SortOrder
    land_size?: SortOrder
    plant?: SortOrder
    harvest?: SortOrder
    mining?: SortOrder
    livestock?: SortOrder
    fishing_boat?: SortOrder
    json_data?: SortOrderInput | SortOrder
    enable?: SortOrder
  }

  export type HouseWhereUniqueInput = {
    id?: number
  }

  export type HouseOrderByWithAggregationInput = {
    id?: SortOrder
    owner?: SortOrder
    paid?: SortOrder
    warnings?: SortOrder
    name?: SortOrder
    rent?: SortOrder
    town_id?: SortOrder
    bid?: SortOrder
    bid_end?: SortOrder
    last_bid?: SortOrder
    highest_bidder?: SortOrder
    size?: SortOrder
    beds?: SortOrder
    land_zone?: SortOrder
    land_plot?: SortOrder
    bioma?: SortOrder
    land_size?: SortOrder
    plant?: SortOrder
    harvest?: SortOrder
    mining?: SortOrder
    livestock?: SortOrder
    fishing_boat?: SortOrder
    json_data?: SortOrderInput | SortOrder
    enable?: SortOrder
    _count?: HouseCountOrderByAggregateInput
    _avg?: HouseAvgOrderByAggregateInput
    _max?: HouseMaxOrderByAggregateInput
    _min?: HouseMinOrderByAggregateInput
    _sum?: HouseSumOrderByAggregateInput
  }

  export type HouseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HouseScalarWhereWithAggregatesInput>
    OR?: Enumerable<HouseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HouseScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    owner?: IntWithAggregatesFilter | number
    paid?: IntWithAggregatesFilter | number
    warnings?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    rent?: IntWithAggregatesFilter | number
    town_id?: IntWithAggregatesFilter | number
    bid?: IntWithAggregatesFilter | number
    bid_end?: IntWithAggregatesFilter | number
    last_bid?: IntWithAggregatesFilter | number
    highest_bidder?: IntWithAggregatesFilter | number
    size?: IntWithAggregatesFilter | number
    beds?: IntWithAggregatesFilter | number
    land_zone?: StringWithAggregatesFilter | string
    land_plot?: StringWithAggregatesFilter | string
    bioma?: StringWithAggregatesFilter | string
    land_size?: StringWithAggregatesFilter | string
    plant?: StringWithAggregatesFilter | string
    harvest?: StringWithAggregatesFilter | string
    mining?: StringWithAggregatesFilter | string
    livestock?: StringWithAggregatesFilter | string
    fishing_boat?: StringWithAggregatesFilter | string
    json_data?: JsonNullableWithAggregatesFilter
    enable?: BoolWithAggregatesFilter | boolean
  }

  export type account_ban_historyWhereInput = {
    AND?: Enumerable<account_ban_historyWhereInput>
    OR?: Enumerable<account_ban_historyWhereInput>
    NOT?: Enumerable<account_ban_historyWhereInput>
    id?: IntFilter | number
    account_id?: IntFilter | number
    reason?: StringFilter | string
    banned_at?: BigIntFilter | bigint | number
    expired_at?: BigIntFilter | bigint | number
    banned_by?: IntFilter | number
    accounts?: XOR<AccountRelationFilter, AccountWhereInput>
    players?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type account_ban_historyOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expired_at?: SortOrder
    banned_by?: SortOrder
    accounts?: AccountOrderByWithRelationInput
    players?: PlayerOrderByWithRelationInput
  }

  export type account_ban_historyWhereUniqueInput = {
    id?: number
  }

  export type account_ban_historyOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expired_at?: SortOrder
    banned_by?: SortOrder
    _count?: account_ban_historyCountOrderByAggregateInput
    _avg?: account_ban_historyAvgOrderByAggregateInput
    _max?: account_ban_historyMaxOrderByAggregateInput
    _min?: account_ban_historyMinOrderByAggregateInput
    _sum?: account_ban_historySumOrderByAggregateInput
  }

  export type account_ban_historyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<account_ban_historyScalarWhereWithAggregatesInput>
    OR?: Enumerable<account_ban_historyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<account_ban_historyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    account_id?: IntWithAggregatesFilter | number
    reason?: StringWithAggregatesFilter | string
    banned_at?: BigIntWithAggregatesFilter | bigint | number
    expired_at?: BigIntWithAggregatesFilter | bigint | number
    banned_by?: IntWithAggregatesFilter | number
  }

  export type account_bansWhereInput = {
    AND?: Enumerable<account_bansWhereInput>
    OR?: Enumerable<account_bansWhereInput>
    NOT?: Enumerable<account_bansWhereInput>
    account_id?: IntFilter | number
    reason?: StringFilter | string
    banned_at?: BigIntFilter | bigint | number
    expires_at?: BigIntFilter | bigint | number
    banned_by?: IntFilter | number
    accounts?: XOR<AccountRelationFilter, AccountWhereInput>
    players?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type account_bansOrderByWithRelationInput = {
    account_id?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
    accounts?: AccountOrderByWithRelationInput
    players?: PlayerOrderByWithRelationInput
  }

  export type account_bansWhereUniqueInput = {
    account_id?: number
  }

  export type account_bansOrderByWithAggregationInput = {
    account_id?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
    _count?: account_bansCountOrderByAggregateInput
    _avg?: account_bansAvgOrderByAggregateInput
    _max?: account_bansMaxOrderByAggregateInput
    _min?: account_bansMinOrderByAggregateInput
    _sum?: account_bansSumOrderByAggregateInput
  }

  export type account_bansScalarWhereWithAggregatesInput = {
    AND?: Enumerable<account_bansScalarWhereWithAggregatesInput>
    OR?: Enumerable<account_bansScalarWhereWithAggregatesInput>
    NOT?: Enumerable<account_bansScalarWhereWithAggregatesInput>
    account_id?: IntWithAggregatesFilter | number
    reason?: StringWithAggregatesFilter | string
    banned_at?: BigIntWithAggregatesFilter | bigint | number
    expires_at?: BigIntWithAggregatesFilter | bigint | number
    banned_by?: IntWithAggregatesFilter | number
  }

  export type account_storageWhereInput = {
    AND?: Enumerable<account_storageWhereInput>
    OR?: Enumerable<account_storageWhereInput>
    NOT?: Enumerable<account_storageWhereInput>
    account_id?: IntFilter | number
    key?: IntFilter | number
    value?: IntFilter | number
    accounts?: XOR<AccountRelationFilter, AccountWhereInput>
  }

  export type account_storageOrderByWithRelationInput = {
    account_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    accounts?: AccountOrderByWithRelationInput
  }

  export type account_storageWhereUniqueInput = {
    account_id_key?: account_storageAccount_idKeyCompoundUniqueInput
  }

  export type account_storageOrderByWithAggregationInput = {
    account_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: account_storageCountOrderByAggregateInput
    _avg?: account_storageAvgOrderByAggregateInput
    _max?: account_storageMaxOrderByAggregateInput
    _min?: account_storageMinOrderByAggregateInput
    _sum?: account_storageSumOrderByAggregateInput
  }

  export type account_storageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<account_storageScalarWhereWithAggregatesInput>
    OR?: Enumerable<account_storageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<account_storageScalarWhereWithAggregatesInput>
    account_id?: IntWithAggregatesFilter | number
    key?: IntWithAggregatesFilter | number
    value?: IntWithAggregatesFilter | number
  }

  export type account_viplistWhereInput = {
    AND?: Enumerable<account_viplistWhereInput>
    OR?: Enumerable<account_viplistWhereInput>
    NOT?: Enumerable<account_viplistWhereInput>
    account_id?: IntFilter | number
    player_id?: IntFilter | number
    description?: StringFilter | string
    icon?: IntFilter | number
    notify?: BoolFilter | boolean
    accounts?: XOR<AccountRelationFilter, AccountWhereInput>
    players?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type account_viplistOrderByWithRelationInput = {
    account_id?: SortOrder
    player_id?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    notify?: SortOrder
    accounts?: AccountOrderByWithRelationInput
    players?: PlayerOrderByWithRelationInput
  }

  export type account_viplistWhereUniqueInput = {
    account_id_player_id?: account_viplistAccount_idPlayer_idCompoundUniqueInput
  }

  export type account_viplistOrderByWithAggregationInput = {
    account_id?: SortOrder
    player_id?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    notify?: SortOrder
    _count?: account_viplistCountOrderByAggregateInput
    _avg?: account_viplistAvgOrderByAggregateInput
    _max?: account_viplistMaxOrderByAggregateInput
    _min?: account_viplistMinOrderByAggregateInput
    _sum?: account_viplistSumOrderByAggregateInput
  }

  export type account_viplistScalarWhereWithAggregatesInput = {
    AND?: Enumerable<account_viplistScalarWhereWithAggregatesInput>
    OR?: Enumerable<account_viplistScalarWhereWithAggregatesInput>
    NOT?: Enumerable<account_viplistScalarWhereWithAggregatesInput>
    account_id?: IntWithAggregatesFilter | number
    player_id?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    icon?: IntWithAggregatesFilter | number
    notify?: BoolWithAggregatesFilter | boolean
  }

  export type guild_invitesWhereInput = {
    AND?: Enumerable<guild_invitesWhereInput>
    OR?: Enumerable<guild_invitesWhereInput>
    NOT?: Enumerable<guild_invitesWhereInput>
    player_id?: IntFilter | number
    guild_id?: IntFilter | number
    players?: XOR<PlayerRelationFilter, PlayerWhereInput>
    guilds?: XOR<GuildsRelationFilter, guildsWhereInput>
  }

  export type guild_invitesOrderByWithRelationInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
    players?: PlayerOrderByWithRelationInput
    guilds?: guildsOrderByWithRelationInput
  }

  export type guild_invitesWhereUniqueInput = {
    player_id_guild_id?: guild_invitesPlayer_idGuild_idCompoundUniqueInput
  }

  export type guild_invitesOrderByWithAggregationInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
    _count?: guild_invitesCountOrderByAggregateInput
    _avg?: guild_invitesAvgOrderByAggregateInput
    _max?: guild_invitesMaxOrderByAggregateInput
    _min?: guild_invitesMinOrderByAggregateInput
    _sum?: guild_invitesSumOrderByAggregateInput
  }

  export type guild_invitesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<guild_invitesScalarWhereWithAggregatesInput>
    OR?: Enumerable<guild_invitesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<guild_invitesScalarWhereWithAggregatesInput>
    player_id?: IntWithAggregatesFilter | number
    guild_id?: IntWithAggregatesFilter | number
  }

  export type guild_membershipWhereInput = {
    AND?: Enumerable<guild_membershipWhereInput>
    OR?: Enumerable<guild_membershipWhereInput>
    NOT?: Enumerable<guild_membershipWhereInput>
    player_id?: IntFilter | number
    guild_id?: IntFilter | number
    rank_id?: IntFilter | number
    nick?: StringFilter | string
    players?: XOR<PlayerRelationFilter, PlayerWhereInput>
    guilds?: XOR<GuildsRelationFilter, guildsWhereInput>
    guild_ranks?: XOR<Guild_ranksRelationFilter, guild_ranksWhereInput>
  }

  export type guild_membershipOrderByWithRelationInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
    rank_id?: SortOrder
    nick?: SortOrder
    players?: PlayerOrderByWithRelationInput
    guilds?: guildsOrderByWithRelationInput
    guild_ranks?: guild_ranksOrderByWithRelationInput
  }

  export type guild_membershipWhereUniqueInput = {
    player_id?: number
  }

  export type guild_membershipOrderByWithAggregationInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
    rank_id?: SortOrder
    nick?: SortOrder
    _count?: guild_membershipCountOrderByAggregateInput
    _avg?: guild_membershipAvgOrderByAggregateInput
    _max?: guild_membershipMaxOrderByAggregateInput
    _min?: guild_membershipMinOrderByAggregateInput
    _sum?: guild_membershipSumOrderByAggregateInput
  }

  export type guild_membershipScalarWhereWithAggregatesInput = {
    AND?: Enumerable<guild_membershipScalarWhereWithAggregatesInput>
    OR?: Enumerable<guild_membershipScalarWhereWithAggregatesInput>
    NOT?: Enumerable<guild_membershipScalarWhereWithAggregatesInput>
    player_id?: IntWithAggregatesFilter | number
    guild_id?: IntWithAggregatesFilter | number
    rank_id?: IntWithAggregatesFilter | number
    nick?: StringWithAggregatesFilter | string
  }

  export type guild_ranksWhereInput = {
    AND?: Enumerable<guild_ranksWhereInput>
    OR?: Enumerable<guild_ranksWhereInput>
    NOT?: Enumerable<guild_ranksWhereInput>
    id?: IntFilter | number
    guild_id?: IntFilter | number
    name?: StringFilter | string
    level?: IntFilter | number
    guild_membership?: Guild_membershipListRelationFilter
    guilds?: XOR<GuildsRelationFilter, guildsWhereInput>
  }

  export type guild_ranksOrderByWithRelationInput = {
    id?: SortOrder
    guild_id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    guild_membership?: guild_membershipOrderByRelationAggregateInput
    guilds?: guildsOrderByWithRelationInput
  }

  export type guild_ranksWhereUniqueInput = {
    id?: number
  }

  export type guild_ranksOrderByWithAggregationInput = {
    id?: SortOrder
    guild_id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    _count?: guild_ranksCountOrderByAggregateInput
    _avg?: guild_ranksAvgOrderByAggregateInput
    _max?: guild_ranksMaxOrderByAggregateInput
    _min?: guild_ranksMinOrderByAggregateInput
    _sum?: guild_ranksSumOrderByAggregateInput
  }

  export type guild_ranksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<guild_ranksScalarWhereWithAggregatesInput>
    OR?: Enumerable<guild_ranksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<guild_ranksScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    guild_id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    level?: IntWithAggregatesFilter | number
  }

  export type guild_warsWhereInput = {
    AND?: Enumerable<guild_warsWhereInput>
    OR?: Enumerable<guild_warsWhereInput>
    NOT?: Enumerable<guild_warsWhereInput>
    id?: IntFilter | number
    guild1?: IntFilter | number
    guild2?: IntFilter | number
    name1?: StringFilter | string
    name2?: StringFilter | string
    status?: IntFilter | number
    started?: BigIntFilter | bigint | number
    ended?: BigIntFilter | bigint | number
    guildwar_kills?: Guildwar_killsListRelationFilter
  }

  export type guild_warsOrderByWithRelationInput = {
    id?: SortOrder
    guild1?: SortOrder
    guild2?: SortOrder
    name1?: SortOrder
    name2?: SortOrder
    status?: SortOrder
    started?: SortOrder
    ended?: SortOrder
    guildwar_kills?: guildwar_killsOrderByRelationAggregateInput
  }

  export type guild_warsWhereUniqueInput = {
    id?: number
  }

  export type guild_warsOrderByWithAggregationInput = {
    id?: SortOrder
    guild1?: SortOrder
    guild2?: SortOrder
    name1?: SortOrder
    name2?: SortOrder
    status?: SortOrder
    started?: SortOrder
    ended?: SortOrder
    _count?: guild_warsCountOrderByAggregateInput
    _avg?: guild_warsAvgOrderByAggregateInput
    _max?: guild_warsMaxOrderByAggregateInput
    _min?: guild_warsMinOrderByAggregateInput
    _sum?: guild_warsSumOrderByAggregateInput
  }

  export type guild_warsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<guild_warsScalarWhereWithAggregatesInput>
    OR?: Enumerable<guild_warsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<guild_warsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    guild1?: IntWithAggregatesFilter | number
    guild2?: IntWithAggregatesFilter | number
    name1?: StringWithAggregatesFilter | string
    name2?: StringWithAggregatesFilter | string
    status?: IntWithAggregatesFilter | number
    started?: BigIntWithAggregatesFilter | bigint | number
    ended?: BigIntWithAggregatesFilter | bigint | number
  }

  export type guildsWhereInput = {
    AND?: Enumerable<guildsWhereInput>
    OR?: Enumerable<guildsWhereInput>
    NOT?: Enumerable<guildsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    ownerid?: IntFilter | number
    creationdata?: IntFilter | number
    motd?: StringFilter | string
    guild_invites?: Guild_invitesListRelationFilter
    guild_membership?: Guild_membershipListRelationFilter
    guild_ranks?: Guild_ranksListRelationFilter
    players?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type guildsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerid?: SortOrder
    creationdata?: SortOrder
    motd?: SortOrder
    guild_invites?: guild_invitesOrderByRelationAggregateInput
    guild_membership?: guild_membershipOrderByRelationAggregateInput
    guild_ranks?: guild_ranksOrderByRelationAggregateInput
    players?: PlayerOrderByWithRelationInput
  }

  export type guildsWhereUniqueInput = {
    id?: number
    name?: string
    ownerid?: number
  }

  export type guildsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerid?: SortOrder
    creationdata?: SortOrder
    motd?: SortOrder
    _count?: guildsCountOrderByAggregateInput
    _avg?: guildsAvgOrderByAggregateInput
    _max?: guildsMaxOrderByAggregateInput
    _min?: guildsMinOrderByAggregateInput
    _sum?: guildsSumOrderByAggregateInput
  }

  export type guildsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<guildsScalarWhereWithAggregatesInput>
    OR?: Enumerable<guildsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<guildsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    ownerid?: IntWithAggregatesFilter | number
    creationdata?: IntWithAggregatesFilter | number
    motd?: StringWithAggregatesFilter | string
  }

  export type guildwar_killsWhereInput = {
    AND?: Enumerable<guildwar_killsWhereInput>
    OR?: Enumerable<guildwar_killsWhereInput>
    NOT?: Enumerable<guildwar_killsWhereInput>
    id?: IntFilter | number
    killer?: StringFilter | string
    target?: StringFilter | string
    killerguild?: IntFilter | number
    targetguild?: IntFilter | number
    warid?: IntFilter | number
    time?: BigIntFilter | bigint | number
    guild_wars?: XOR<Guild_warsRelationFilter, guild_warsWhereInput>
  }

  export type guildwar_killsOrderByWithRelationInput = {
    id?: SortOrder
    killer?: SortOrder
    target?: SortOrder
    killerguild?: SortOrder
    targetguild?: SortOrder
    warid?: SortOrder
    time?: SortOrder
    guild_wars?: guild_warsOrderByWithRelationInput
  }

  export type guildwar_killsWhereUniqueInput = {
    id?: number
  }

  export type guildwar_killsOrderByWithAggregationInput = {
    id?: SortOrder
    killer?: SortOrder
    target?: SortOrder
    killerguild?: SortOrder
    targetguild?: SortOrder
    warid?: SortOrder
    time?: SortOrder
    _count?: guildwar_killsCountOrderByAggregateInput
    _avg?: guildwar_killsAvgOrderByAggregateInput
    _max?: guildwar_killsMaxOrderByAggregateInput
    _min?: guildwar_killsMinOrderByAggregateInput
    _sum?: guildwar_killsSumOrderByAggregateInput
  }

  export type guildwar_killsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<guildwar_killsScalarWhereWithAggregatesInput>
    OR?: Enumerable<guildwar_killsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<guildwar_killsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    killer?: StringWithAggregatesFilter | string
    target?: StringWithAggregatesFilter | string
    killerguild?: IntWithAggregatesFilter | number
    targetguild?: IntWithAggregatesFilter | number
    warid?: IntWithAggregatesFilter | number
    time?: BigIntWithAggregatesFilter | bigint | number
  }

  export type ip_bansWhereInput = {
    AND?: Enumerable<ip_bansWhereInput>
    OR?: Enumerable<ip_bansWhereInput>
    NOT?: Enumerable<ip_bansWhereInput>
    ip?: IntFilter | number
    reason?: StringFilter | string
    banned_at?: BigIntFilter | bigint | number
    expires_at?: BigIntFilter | bigint | number
    banned_by?: IntFilter | number
    players?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type ip_bansOrderByWithRelationInput = {
    ip?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
    players?: PlayerOrderByWithRelationInput
  }

  export type ip_bansWhereUniqueInput = {
    ip?: number
  }

  export type ip_bansOrderByWithAggregationInput = {
    ip?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
    _count?: ip_bansCountOrderByAggregateInput
    _avg?: ip_bansAvgOrderByAggregateInput
    _max?: ip_bansMaxOrderByAggregateInput
    _min?: ip_bansMinOrderByAggregateInput
    _sum?: ip_bansSumOrderByAggregateInput
  }

  export type ip_bansScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ip_bansScalarWhereWithAggregatesInput>
    OR?: Enumerable<ip_bansScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ip_bansScalarWhereWithAggregatesInput>
    ip?: IntWithAggregatesFilter | number
    reason?: StringWithAggregatesFilter | string
    banned_at?: BigIntWithAggregatesFilter | bigint | number
    expires_at?: BigIntWithAggregatesFilter | bigint | number
    banned_by?: IntWithAggregatesFilter | number
  }

  export type market_historyWhereInput = {
    AND?: Enumerable<market_historyWhereInput>
    OR?: Enumerable<market_historyWhereInput>
    NOT?: Enumerable<market_historyWhereInput>
    id?: IntFilter | number
    player_id?: IntFilter | number
    sale?: BoolFilter | boolean
    itemtype?: IntFilter | number
    amount?: IntFilter | number
    price?: IntFilter | number
    expires_at?: BigIntFilter | bigint | number
    inserted?: BigIntFilter | bigint | number
    state?: IntFilter | number
    players?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type market_historyOrderByWithRelationInput = {
    id?: SortOrder
    player_id?: SortOrder
    sale?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    expires_at?: SortOrder
    inserted?: SortOrder
    state?: SortOrder
    players?: PlayerOrderByWithRelationInput
  }

  export type market_historyWhereUniqueInput = {
    id?: number
  }

  export type market_historyOrderByWithAggregationInput = {
    id?: SortOrder
    player_id?: SortOrder
    sale?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    expires_at?: SortOrder
    inserted?: SortOrder
    state?: SortOrder
    _count?: market_historyCountOrderByAggregateInput
    _avg?: market_historyAvgOrderByAggregateInput
    _max?: market_historyMaxOrderByAggregateInput
    _min?: market_historyMinOrderByAggregateInput
    _sum?: market_historySumOrderByAggregateInput
  }

  export type market_historyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<market_historyScalarWhereWithAggregatesInput>
    OR?: Enumerable<market_historyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<market_historyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    player_id?: IntWithAggregatesFilter | number
    sale?: BoolWithAggregatesFilter | boolean
    itemtype?: IntWithAggregatesFilter | number
    amount?: IntWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    expires_at?: BigIntWithAggregatesFilter | bigint | number
    inserted?: BigIntWithAggregatesFilter | bigint | number
    state?: IntWithAggregatesFilter | number
  }

  export type market_offersWhereInput = {
    AND?: Enumerable<market_offersWhereInput>
    OR?: Enumerable<market_offersWhereInput>
    NOT?: Enumerable<market_offersWhereInput>
    id?: IntFilter | number
    player_id?: IntFilter | number
    sale?: BoolFilter | boolean
    itemtype?: IntFilter | number
    amount?: IntFilter | number
    created?: BigIntFilter | bigint | number
    anonymous?: BoolFilter | boolean
    price?: IntFilter | number
    players?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type market_offersOrderByWithRelationInput = {
    id?: SortOrder
    player_id?: SortOrder
    sale?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    created?: SortOrder
    anonymous?: SortOrder
    price?: SortOrder
    players?: PlayerOrderByWithRelationInput
  }

  export type market_offersWhereUniqueInput = {
    id?: number
  }

  export type market_offersOrderByWithAggregationInput = {
    id?: SortOrder
    player_id?: SortOrder
    sale?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    created?: SortOrder
    anonymous?: SortOrder
    price?: SortOrder
    _count?: market_offersCountOrderByAggregateInput
    _avg?: market_offersAvgOrderByAggregateInput
    _max?: market_offersMaxOrderByAggregateInput
    _min?: market_offersMinOrderByAggregateInput
    _sum?: market_offersSumOrderByAggregateInput
  }

  export type market_offersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<market_offersScalarWhereWithAggregatesInput>
    OR?: Enumerable<market_offersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<market_offersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    player_id?: IntWithAggregatesFilter | number
    sale?: BoolWithAggregatesFilter | boolean
    itemtype?: IntWithAggregatesFilter | number
    amount?: IntWithAggregatesFilter | number
    created?: BigIntWithAggregatesFilter | bigint | number
    anonymous?: BoolWithAggregatesFilter | boolean
    price?: IntWithAggregatesFilter | number
  }

  export type petsWhereInput = {
    AND?: Enumerable<petsWhereInput>
    OR?: Enumerable<petsWhereInput>
    NOT?: Enumerable<petsWhereInput>
    id?: IntFilter | number
    type?: IntFilter | number
    rank?: IntFilter | number
    stage?: IntFilter | number
    name?: StringFilter | string
    pet?: StringFilter | string
    owner?: StringFilter | string
    level?: IntFilter | number
    experience?: IntFilter | number
    addonItem?: IntFilter | number
    strength?: IntFilter | number
    wisdom?: IntFilter | number
    agility?: IntFilter | number
    sustain?: IntFilter | number
    magicResistance?: IntFilter | number
    lucky?: IntFilter | number
    hungry?: IntFilter | number
    hygiene?: IntFilter | number
    happiness?: IntFilter | number
    health?: BigIntFilter | bigint | number
    cooldowns?: StringFilter | string
    world_id?: BoolFilter | boolean
    wallet?: StringFilter | string
  }

  export type petsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    rank?: SortOrder
    stage?: SortOrder
    name?: SortOrder
    pet?: SortOrder
    owner?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    addonItem?: SortOrder
    strength?: SortOrder
    wisdom?: SortOrder
    agility?: SortOrder
    sustain?: SortOrder
    magicResistance?: SortOrder
    lucky?: SortOrder
    hungry?: SortOrder
    hygiene?: SortOrder
    happiness?: SortOrder
    health?: SortOrder
    cooldowns?: SortOrder
    world_id?: SortOrder
    wallet?: SortOrder
  }

  export type petsWhereUniqueInput = {
    id?: number
  }

  export type petsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    rank?: SortOrder
    stage?: SortOrder
    name?: SortOrder
    pet?: SortOrder
    owner?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    addonItem?: SortOrder
    strength?: SortOrder
    wisdom?: SortOrder
    agility?: SortOrder
    sustain?: SortOrder
    magicResistance?: SortOrder
    lucky?: SortOrder
    hungry?: SortOrder
    hygiene?: SortOrder
    happiness?: SortOrder
    health?: SortOrder
    cooldowns?: SortOrder
    world_id?: SortOrder
    wallet?: SortOrder
    _count?: petsCountOrderByAggregateInput
    _avg?: petsAvgOrderByAggregateInput
    _max?: petsMaxOrderByAggregateInput
    _min?: petsMinOrderByAggregateInput
    _sum?: petsSumOrderByAggregateInput
  }

  export type petsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<petsScalarWhereWithAggregatesInput>
    OR?: Enumerable<petsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<petsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: IntWithAggregatesFilter | number
    rank?: IntWithAggregatesFilter | number
    stage?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    pet?: StringWithAggregatesFilter | string
    owner?: StringWithAggregatesFilter | string
    level?: IntWithAggregatesFilter | number
    experience?: IntWithAggregatesFilter | number
    addonItem?: IntWithAggregatesFilter | number
    strength?: IntWithAggregatesFilter | number
    wisdom?: IntWithAggregatesFilter | number
    agility?: IntWithAggregatesFilter | number
    sustain?: IntWithAggregatesFilter | number
    magicResistance?: IntWithAggregatesFilter | number
    lucky?: IntWithAggregatesFilter | number
    hungry?: IntWithAggregatesFilter | number
    hygiene?: IntWithAggregatesFilter | number
    happiness?: IntWithAggregatesFilter | number
    health?: BigIntWithAggregatesFilter | bigint | number
    cooldowns?: StringWithAggregatesFilter | string
    world_id?: BoolWithAggregatesFilter | boolean
    wallet?: StringWithAggregatesFilter | string
  }

  export type player_depotitemsWhereInput = {
    AND?: Enumerable<player_depotitemsWhereInput>
    OR?: Enumerable<player_depotitemsWhereInput>
    NOT?: Enumerable<player_depotitemsWhereInput>
    player_id?: IntFilter | number
    sid?: IntFilter | number
    pid?: IntFilter | number
    itemtype?: IntFilter | number
    count?: IntFilter | number
    attributes?: BytesFilter | Buffer
    json_data?: JsonNullableFilter
    players?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type player_depotitemsOrderByWithRelationInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
    json_data?: SortOrderInput | SortOrder
    players?: PlayerOrderByWithRelationInput
  }

  export type player_depotitemsWhereUniqueInput = {
    player_id_sid?: player_depotitemsPlayer_idSidCompoundUniqueInput
  }

  export type player_depotitemsOrderByWithAggregationInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
    json_data?: SortOrderInput | SortOrder
    _count?: player_depotitemsCountOrderByAggregateInput
    _avg?: player_depotitemsAvgOrderByAggregateInput
    _max?: player_depotitemsMaxOrderByAggregateInput
    _min?: player_depotitemsMinOrderByAggregateInput
    _sum?: player_depotitemsSumOrderByAggregateInput
  }

  export type player_depotitemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<player_depotitemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<player_depotitemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<player_depotitemsScalarWhereWithAggregatesInput>
    player_id?: IntWithAggregatesFilter | number
    sid?: IntWithAggregatesFilter | number
    pid?: IntWithAggregatesFilter | number
    itemtype?: IntWithAggregatesFilter | number
    count?: IntWithAggregatesFilter | number
    attributes?: BytesWithAggregatesFilter | Buffer
    json_data?: JsonNullableWithAggregatesFilter
  }

  export type player_inboxitemsWhereInput = {
    AND?: Enumerable<player_inboxitemsWhereInput>
    OR?: Enumerable<player_inboxitemsWhereInput>
    NOT?: Enumerable<player_inboxitemsWhereInput>
    player_id?: IntFilter | number
    sid?: IntFilter | number
    pid?: IntFilter | number
    itemtype?: IntFilter | number
    count?: IntFilter | number
    attributes?: BytesFilter | Buffer
    json_data?: JsonNullableFilter
    players?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type player_inboxitemsOrderByWithRelationInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
    json_data?: SortOrderInput | SortOrder
    players?: PlayerOrderByWithRelationInput
  }

  export type player_inboxitemsWhereUniqueInput = {
    player_id_sid?: player_inboxitemsPlayer_idSidCompoundUniqueInput
  }

  export type player_inboxitemsOrderByWithAggregationInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
    json_data?: SortOrderInput | SortOrder
    _count?: player_inboxitemsCountOrderByAggregateInput
    _avg?: player_inboxitemsAvgOrderByAggregateInput
    _max?: player_inboxitemsMaxOrderByAggregateInput
    _min?: player_inboxitemsMinOrderByAggregateInput
    _sum?: player_inboxitemsSumOrderByAggregateInput
  }

  export type player_inboxitemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<player_inboxitemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<player_inboxitemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<player_inboxitemsScalarWhereWithAggregatesInput>
    player_id?: IntWithAggregatesFilter | number
    sid?: IntWithAggregatesFilter | number
    pid?: IntWithAggregatesFilter | number
    itemtype?: IntWithAggregatesFilter | number
    count?: IntWithAggregatesFilter | number
    attributes?: BytesWithAggregatesFilter | Buffer
    json_data?: JsonNullableWithAggregatesFilter
  }

  export type player_namelocksWhereInput = {
    AND?: Enumerable<player_namelocksWhereInput>
    OR?: Enumerable<player_namelocksWhereInput>
    NOT?: Enumerable<player_namelocksWhereInput>
    player_id?: IntFilter | number
    reason?: StringFilter | string
    namelocked_at?: BigIntFilter | bigint | number
    namelocked_by?: IntFilter | number
    players_player_namelocks_player_idToplayers?: XOR<PlayerRelationFilter, PlayerWhereInput>
    players_player_namelocks_namelocked_byToplayers?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type player_namelocksOrderByWithRelationInput = {
    player_id?: SortOrder
    reason?: SortOrder
    namelocked_at?: SortOrder
    namelocked_by?: SortOrder
    players_player_namelocks_player_idToplayers?: PlayerOrderByWithRelationInput
    players_player_namelocks_namelocked_byToplayers?: PlayerOrderByWithRelationInput
  }

  export type player_namelocksWhereUniqueInput = {
    player_id?: number
  }

  export type player_namelocksOrderByWithAggregationInput = {
    player_id?: SortOrder
    reason?: SortOrder
    namelocked_at?: SortOrder
    namelocked_by?: SortOrder
    _count?: player_namelocksCountOrderByAggregateInput
    _avg?: player_namelocksAvgOrderByAggregateInput
    _max?: player_namelocksMaxOrderByAggregateInput
    _min?: player_namelocksMinOrderByAggregateInput
    _sum?: player_namelocksSumOrderByAggregateInput
  }

  export type player_namelocksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<player_namelocksScalarWhereWithAggregatesInput>
    OR?: Enumerable<player_namelocksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<player_namelocksScalarWhereWithAggregatesInput>
    player_id?: IntWithAggregatesFilter | number
    reason?: StringWithAggregatesFilter | string
    namelocked_at?: BigIntWithAggregatesFilter | bigint | number
    namelocked_by?: IntWithAggregatesFilter | number
  }

  export type player_storageWhereInput = {
    AND?: Enumerable<player_storageWhereInput>
    OR?: Enumerable<player_storageWhereInput>
    NOT?: Enumerable<player_storageWhereInput>
    player_id?: IntFilter | number
    key?: IntFilter | number
    value?: IntFilter | number
    players?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type player_storageOrderByWithRelationInput = {
    player_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    players?: PlayerOrderByWithRelationInput
  }

  export type player_storageWhereUniqueInput = {
    player_id_key?: player_storagePlayer_idKeyCompoundUniqueInput
  }

  export type player_storageOrderByWithAggregationInput = {
    player_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: player_storageCountOrderByAggregateInput
    _avg?: player_storageAvgOrderByAggregateInput
    _max?: player_storageMaxOrderByAggregateInput
    _min?: player_storageMinOrderByAggregateInput
    _sum?: player_storageSumOrderByAggregateInput
  }

  export type player_storageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<player_storageScalarWhereWithAggregatesInput>
    OR?: Enumerable<player_storageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<player_storageScalarWhereWithAggregatesInput>
    player_id?: IntWithAggregatesFilter | number
    key?: IntWithAggregatesFilter | number
    value?: IntWithAggregatesFilter | number
  }

  export type player_storeinboxitemsWhereInput = {
    AND?: Enumerable<player_storeinboxitemsWhereInput>
    OR?: Enumerable<player_storeinboxitemsWhereInput>
    NOT?: Enumerable<player_storeinboxitemsWhereInput>
    player_id?: IntFilter | number
    sid?: IntFilter | number
    pid?: IntFilter | number
    itemtype?: IntFilter | number
    count?: IntFilter | number
    attributes?: BytesFilter | Buffer
    json_data?: JsonNullableFilter
    players?: XOR<PlayerRelationFilter, PlayerWhereInput>
  }

  export type player_storeinboxitemsOrderByWithRelationInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
    json_data?: SortOrderInput | SortOrder
    players?: PlayerOrderByWithRelationInput
  }

  export type player_storeinboxitemsWhereUniqueInput = {
    player_id_sid?: player_storeinboxitemsPlayer_idSidCompoundUniqueInput
  }

  export type player_storeinboxitemsOrderByWithAggregationInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
    json_data?: SortOrderInput | SortOrder
    _count?: player_storeinboxitemsCountOrderByAggregateInput
    _avg?: player_storeinboxitemsAvgOrderByAggregateInput
    _max?: player_storeinboxitemsMaxOrderByAggregateInput
    _min?: player_storeinboxitemsMinOrderByAggregateInput
    _sum?: player_storeinboxitemsSumOrderByAggregateInput
  }

  export type player_storeinboxitemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<player_storeinboxitemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<player_storeinboxitemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<player_storeinboxitemsScalarWhereWithAggregatesInput>
    player_id?: IntWithAggregatesFilter | number
    sid?: IntWithAggregatesFilter | number
    pid?: IntWithAggregatesFilter | number
    itemtype?: IntWithAggregatesFilter | number
    count?: IntWithAggregatesFilter | number
    attributes?: BytesWithAggregatesFilter | Buffer
    json_data?: JsonNullableWithAggregatesFilter
  }

  export type players_onlineWhereInput = {
    AND?: Enumerable<players_onlineWhereInput>
    OR?: Enumerable<players_onlineWhereInput>
    NOT?: Enumerable<players_onlineWhereInput>
    player_id?: IntFilter | number
  }

  export type players_onlineOrderByWithRelationInput = {
    player_id?: SortOrder
  }

  export type players_onlineWhereUniqueInput = {
    player_id?: number
  }

  export type players_onlineOrderByWithAggregationInput = {
    player_id?: SortOrder
    _count?: players_onlineCountOrderByAggregateInput
    _avg?: players_onlineAvgOrderByAggregateInput
    _max?: players_onlineMaxOrderByAggregateInput
    _min?: players_onlineMinOrderByAggregateInput
    _sum?: players_onlineSumOrderByAggregateInput
  }

  export type players_onlineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<players_onlineScalarWhereWithAggregatesInput>
    OR?: Enumerable<players_onlineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<players_onlineScalarWhereWithAggregatesInput>
    player_id?: IntWithAggregatesFilter | number
  }

  export type server_configWhereInput = {
    AND?: Enumerable<server_configWhereInput>
    OR?: Enumerable<server_configWhereInput>
    NOT?: Enumerable<server_configWhereInput>
    config?: StringFilter | string
    value?: StringFilter | string
  }

  export type server_configOrderByWithRelationInput = {
    config?: SortOrder
    value?: SortOrder
  }

  export type server_configWhereUniqueInput = {
    config?: string
  }

  export type server_configOrderByWithAggregationInput = {
    config?: SortOrder
    value?: SortOrder
    _count?: server_configCountOrderByAggregateInput
    _max?: server_configMaxOrderByAggregateInput
    _min?: server_configMinOrderByAggregateInput
  }

  export type server_configScalarWhereWithAggregatesInput = {
    AND?: Enumerable<server_configScalarWhereWithAggregatesInput>
    OR?: Enumerable<server_configScalarWhereWithAggregatesInput>
    NOT?: Enumerable<server_configScalarWhereWithAggregatesInput>
    config?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
  }

  export type shop_historyWhereInput = {
    AND?: Enumerable<shop_historyWhereInput>
    OR?: Enumerable<shop_historyWhereInput>
    NOT?: Enumerable<shop_historyWhereInput>
    id?: IntFilter | number
    account?: IntFilter | number
    player?: IntFilter | number
    date?: DateTimeFilter | Date | string
    title?: StringFilter | string
    cost?: IntFilter | number
    details?: StringFilter | string
  }

  export type shop_historyOrderByWithRelationInput = {
    id?: SortOrder
    account?: SortOrder
    player?: SortOrder
    date?: SortOrder
    title?: SortOrder
    cost?: SortOrder
    details?: SortOrder
  }

  export type shop_historyWhereUniqueInput = {
    id?: number
  }

  export type shop_historyOrderByWithAggregationInput = {
    id?: SortOrder
    account?: SortOrder
    player?: SortOrder
    date?: SortOrder
    title?: SortOrder
    cost?: SortOrder
    details?: SortOrder
    _count?: shop_historyCountOrderByAggregateInput
    _avg?: shop_historyAvgOrderByAggregateInput
    _max?: shop_historyMaxOrderByAggregateInput
    _min?: shop_historyMinOrderByAggregateInput
    _sum?: shop_historySumOrderByAggregateInput
  }

  export type shop_historyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<shop_historyScalarWhereWithAggregatesInput>
    OR?: Enumerable<shop_historyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<shop_historyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    account?: IntWithAggregatesFilter | number
    player?: IntWithAggregatesFilter | number
    date?: DateTimeWithAggregatesFilter | Date | string
    title?: StringWithAggregatesFilter | string
    cost?: IntWithAggregatesFilter | number
    details?: StringWithAggregatesFilter | string
  }

  export type townsWhereInput = {
    AND?: Enumerable<townsWhereInput>
    OR?: Enumerable<townsWhereInput>
    NOT?: Enumerable<townsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    posx?: IntFilter | number
    posy?: IntFilter | number
    posz?: IntFilter | number
  }

  export type townsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
  }

  export type townsWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type townsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    _count?: townsCountOrderByAggregateInput
    _avg?: townsAvgOrderByAggregateInput
    _max?: townsMaxOrderByAggregateInput
    _min?: townsMinOrderByAggregateInput
    _sum?: townsSumOrderByAggregateInput
  }

  export type townsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<townsScalarWhereWithAggregatesInput>
    OR?: Enumerable<townsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<townsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    posx?: IntWithAggregatesFilter | number
    posy?: IntWithAggregatesFilter | number
    posz?: IntWithAggregatesFilter | number
  }

  export type znoteWhereInput = {
    AND?: Enumerable<znoteWhereInput>
    OR?: Enumerable<znoteWhereInput>
    NOT?: Enumerable<znoteWhereInput>
    id?: IntFilter | number
    version?: StringFilter | string
    installed?: IntFilter | number
    cached?: IntNullableFilter | number | null
  }

  export type znoteOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    installed?: SortOrder
    cached?: SortOrderInput | SortOrder
  }

  export type znoteWhereUniqueInput = {
    id?: number
  }

  export type znoteOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    installed?: SortOrder
    cached?: SortOrderInput | SortOrder
    _count?: znoteCountOrderByAggregateInput
    _avg?: znoteAvgOrderByAggregateInput
    _max?: znoteMaxOrderByAggregateInput
    _min?: znoteMinOrderByAggregateInput
    _sum?: znoteSumOrderByAggregateInput
  }

  export type znoteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znoteScalarWhereWithAggregatesInput>
    OR?: Enumerable<znoteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znoteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    version?: StringWithAggregatesFilter | string
    installed?: IntWithAggregatesFilter | number
    cached?: IntNullableWithAggregatesFilter | number | null
  }

  export type znote_accountsWhereInput = {
    AND?: Enumerable<znote_accountsWhereInput>
    OR?: Enumerable<znote_accountsWhereInput>
    NOT?: Enumerable<znote_accountsWhereInput>
    id?: IntFilter | number
    account_id?: IntFilter | number
    ip?: BigIntFilter | bigint | number
    created?: IntFilter | number
    points?: IntNullableFilter | number | null
    cooldown?: IntNullableFilter | number | null
    active?: IntFilter | number
    active_email?: IntFilter | number
    activekey?: IntFilter | number
    flag?: StringFilter | string
    secret?: StringNullableFilter | string | null
  }

  export type znote_accountsOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    ip?: SortOrder
    created?: SortOrder
    points?: SortOrderInput | SortOrder
    cooldown?: SortOrderInput | SortOrder
    active?: SortOrder
    active_email?: SortOrder
    activekey?: SortOrder
    flag?: SortOrder
    secret?: SortOrderInput | SortOrder
  }

  export type znote_accountsWhereUniqueInput = {
    id?: number
  }

  export type znote_accountsOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    ip?: SortOrder
    created?: SortOrder
    points?: SortOrderInput | SortOrder
    cooldown?: SortOrderInput | SortOrder
    active?: SortOrder
    active_email?: SortOrder
    activekey?: SortOrder
    flag?: SortOrder
    secret?: SortOrderInput | SortOrder
    _count?: znote_accountsCountOrderByAggregateInput
    _avg?: znote_accountsAvgOrderByAggregateInput
    _max?: znote_accountsMaxOrderByAggregateInput
    _min?: znote_accountsMinOrderByAggregateInput
    _sum?: znote_accountsSumOrderByAggregateInput
  }

  export type znote_accountsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_accountsScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_accountsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_accountsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    account_id?: IntWithAggregatesFilter | number
    ip?: BigIntWithAggregatesFilter | bigint | number
    created?: IntWithAggregatesFilter | number
    points?: IntNullableWithAggregatesFilter | number | null
    cooldown?: IntNullableWithAggregatesFilter | number | null
    active?: IntWithAggregatesFilter | number
    active_email?: IntWithAggregatesFilter | number
    activekey?: IntWithAggregatesFilter | number
    flag?: StringWithAggregatesFilter | string
    secret?: StringNullableWithAggregatesFilter | string | null
  }

  export type znote_auction_playerWhereInput = {
    AND?: Enumerable<znote_auction_playerWhereInput>
    OR?: Enumerable<znote_auction_playerWhereInput>
    NOT?: Enumerable<znote_auction_playerWhereInput>
    id?: IntFilter | number
    player_id?: IntFilter | number
    original_account_id?: IntFilter | number
    bidder_account_id?: IntFilter | number
    time_begin?: IntFilter | number
    time_end?: IntFilter | number
    price?: IntFilter | number
    bid?: IntFilter | number
    deposit?: IntFilter | number
    sold?: IntFilter | number
    claimed?: IntFilter | number
  }

  export type znote_auction_playerOrderByWithRelationInput = {
    id?: SortOrder
    player_id?: SortOrder
    original_account_id?: SortOrder
    bidder_account_id?: SortOrder
    time_begin?: SortOrder
    time_end?: SortOrder
    price?: SortOrder
    bid?: SortOrder
    deposit?: SortOrder
    sold?: SortOrder
    claimed?: SortOrder
  }

  export type znote_auction_playerWhereUniqueInput = {
    id?: number
  }

  export type znote_auction_playerOrderByWithAggregationInput = {
    id?: SortOrder
    player_id?: SortOrder
    original_account_id?: SortOrder
    bidder_account_id?: SortOrder
    time_begin?: SortOrder
    time_end?: SortOrder
    price?: SortOrder
    bid?: SortOrder
    deposit?: SortOrder
    sold?: SortOrder
    claimed?: SortOrder
    _count?: znote_auction_playerCountOrderByAggregateInput
    _avg?: znote_auction_playerAvgOrderByAggregateInput
    _max?: znote_auction_playerMaxOrderByAggregateInput
    _min?: znote_auction_playerMinOrderByAggregateInput
    _sum?: znote_auction_playerSumOrderByAggregateInput
  }

  export type znote_auction_playerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_auction_playerScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_auction_playerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_auction_playerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    player_id?: IntWithAggregatesFilter | number
    original_account_id?: IntWithAggregatesFilter | number
    bidder_account_id?: IntWithAggregatesFilter | number
    time_begin?: IntWithAggregatesFilter | number
    time_end?: IntWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    bid?: IntWithAggregatesFilter | number
    deposit?: IntWithAggregatesFilter | number
    sold?: IntWithAggregatesFilter | number
    claimed?: IntWithAggregatesFilter | number
  }

  export type znote_changelogWhereInput = {
    AND?: Enumerable<znote_changelogWhereInput>
    OR?: Enumerable<znote_changelogWhereInput>
    NOT?: Enumerable<znote_changelogWhereInput>
    id?: IntFilter | number
    text?: StringFilter | string
    time?: IntFilter | number
    report_id?: IntFilter | number
    status?: IntFilter | number
  }

  export type znote_changelogOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    time?: SortOrder
    report_id?: SortOrder
    status?: SortOrder
  }

  export type znote_changelogWhereUniqueInput = {
    id?: number
  }

  export type znote_changelogOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    time?: SortOrder
    report_id?: SortOrder
    status?: SortOrder
    _count?: znote_changelogCountOrderByAggregateInput
    _avg?: znote_changelogAvgOrderByAggregateInput
    _max?: znote_changelogMaxOrderByAggregateInput
    _min?: znote_changelogMinOrderByAggregateInput
    _sum?: znote_changelogSumOrderByAggregateInput
  }

  export type znote_changelogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_changelogScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_changelogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_changelogScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    text?: StringWithAggregatesFilter | string
    time?: IntWithAggregatesFilter | number
    report_id?: IntWithAggregatesFilter | number
    status?: IntWithAggregatesFilter | number
  }

  export type znote_deleted_charactersWhereInput = {
    AND?: Enumerable<znote_deleted_charactersWhereInput>
    OR?: Enumerable<znote_deleted_charactersWhereInput>
    NOT?: Enumerable<znote_deleted_charactersWhereInput>
    id?: IntFilter | number
    original_account_id?: IntFilter | number
    character_name?: StringFilter | string
    time?: DateTimeFilter | Date | string
    done?: IntFilter | number
  }

  export type znote_deleted_charactersOrderByWithRelationInput = {
    id?: SortOrder
    original_account_id?: SortOrder
    character_name?: SortOrder
    time?: SortOrder
    done?: SortOrder
  }

  export type znote_deleted_charactersWhereUniqueInput = {
    id?: number
  }

  export type znote_deleted_charactersOrderByWithAggregationInput = {
    id?: SortOrder
    original_account_id?: SortOrder
    character_name?: SortOrder
    time?: SortOrder
    done?: SortOrder
    _count?: znote_deleted_charactersCountOrderByAggregateInput
    _avg?: znote_deleted_charactersAvgOrderByAggregateInput
    _max?: znote_deleted_charactersMaxOrderByAggregateInput
    _min?: znote_deleted_charactersMinOrderByAggregateInput
    _sum?: znote_deleted_charactersSumOrderByAggregateInput
  }

  export type znote_deleted_charactersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_deleted_charactersScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_deleted_charactersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_deleted_charactersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    original_account_id?: IntWithAggregatesFilter | number
    character_name?: StringWithAggregatesFilter | string
    time?: DateTimeWithAggregatesFilter | Date | string
    done?: IntWithAggregatesFilter | number
  }

  export type znote_forumWhereInput = {
    AND?: Enumerable<znote_forumWhereInput>
    OR?: Enumerable<znote_forumWhereInput>
    NOT?: Enumerable<znote_forumWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    access?: IntFilter | number
    closed?: IntFilter | number
    hidden?: IntFilter | number
    guild_id?: IntFilter | number
  }

  export type znote_forumOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    access?: SortOrder
    closed?: SortOrder
    hidden?: SortOrder
    guild_id?: SortOrder
  }

  export type znote_forumWhereUniqueInput = {
    id?: number
  }

  export type znote_forumOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    access?: SortOrder
    closed?: SortOrder
    hidden?: SortOrder
    guild_id?: SortOrder
    _count?: znote_forumCountOrderByAggregateInput
    _avg?: znote_forumAvgOrderByAggregateInput
    _max?: znote_forumMaxOrderByAggregateInput
    _min?: znote_forumMinOrderByAggregateInput
    _sum?: znote_forumSumOrderByAggregateInput
  }

  export type znote_forumScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_forumScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_forumScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_forumScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    access?: IntWithAggregatesFilter | number
    closed?: IntWithAggregatesFilter | number
    hidden?: IntWithAggregatesFilter | number
    guild_id?: IntWithAggregatesFilter | number
  }

  export type znote_forum_postsWhereInput = {
    AND?: Enumerable<znote_forum_postsWhereInput>
    OR?: Enumerable<znote_forum_postsWhereInput>
    NOT?: Enumerable<znote_forum_postsWhereInput>
    id?: IntFilter | number
    thread_id?: IntFilter | number
    player_id?: IntFilter | number
    player_name?: StringFilter | string
    text?: StringFilter | string
    created?: IntFilter | number
    updated?: IntFilter | number
  }

  export type znote_forum_postsOrderByWithRelationInput = {
    id?: SortOrder
    thread_id?: SortOrder
    player_id?: SortOrder
    player_name?: SortOrder
    text?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type znote_forum_postsWhereUniqueInput = {
    id?: number
  }

  export type znote_forum_postsOrderByWithAggregationInput = {
    id?: SortOrder
    thread_id?: SortOrder
    player_id?: SortOrder
    player_name?: SortOrder
    text?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: znote_forum_postsCountOrderByAggregateInput
    _avg?: znote_forum_postsAvgOrderByAggregateInput
    _max?: znote_forum_postsMaxOrderByAggregateInput
    _min?: znote_forum_postsMinOrderByAggregateInput
    _sum?: znote_forum_postsSumOrderByAggregateInput
  }

  export type znote_forum_postsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_forum_postsScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_forum_postsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_forum_postsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    thread_id?: IntWithAggregatesFilter | number
    player_id?: IntWithAggregatesFilter | number
    player_name?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
    created?: IntWithAggregatesFilter | number
    updated?: IntWithAggregatesFilter | number
  }

  export type znote_forum_threadsWhereInput = {
    AND?: Enumerable<znote_forum_threadsWhereInput>
    OR?: Enumerable<znote_forum_threadsWhereInput>
    NOT?: Enumerable<znote_forum_threadsWhereInput>
    id?: IntFilter | number
    forum_id?: IntFilter | number
    player_id?: IntFilter | number
    player_name?: StringFilter | string
    title?: StringFilter | string
    text?: StringFilter | string
    created?: IntFilter | number
    updated?: IntFilter | number
    sticky?: IntFilter | number
    hidden?: IntFilter | number
    closed?: IntFilter | number
  }

  export type znote_forum_threadsOrderByWithRelationInput = {
    id?: SortOrder
    forum_id?: SortOrder
    player_id?: SortOrder
    player_name?: SortOrder
    title?: SortOrder
    text?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    sticky?: SortOrder
    hidden?: SortOrder
    closed?: SortOrder
  }

  export type znote_forum_threadsWhereUniqueInput = {
    id?: number
  }

  export type znote_forum_threadsOrderByWithAggregationInput = {
    id?: SortOrder
    forum_id?: SortOrder
    player_id?: SortOrder
    player_name?: SortOrder
    title?: SortOrder
    text?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    sticky?: SortOrder
    hidden?: SortOrder
    closed?: SortOrder
    _count?: znote_forum_threadsCountOrderByAggregateInput
    _avg?: znote_forum_threadsAvgOrderByAggregateInput
    _max?: znote_forum_threadsMaxOrderByAggregateInput
    _min?: znote_forum_threadsMinOrderByAggregateInput
    _sum?: znote_forum_threadsSumOrderByAggregateInput
  }

  export type znote_forum_threadsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_forum_threadsScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_forum_threadsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_forum_threadsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    forum_id?: IntWithAggregatesFilter | number
    player_id?: IntWithAggregatesFilter | number
    player_name?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
    created?: IntWithAggregatesFilter | number
    updated?: IntWithAggregatesFilter | number
    sticky?: IntWithAggregatesFilter | number
    hidden?: IntWithAggregatesFilter | number
    closed?: IntWithAggregatesFilter | number
  }

  export type znote_global_storageWhereInput = {
    AND?: Enumerable<znote_global_storageWhereInput>
    OR?: Enumerable<znote_global_storageWhereInput>
    NOT?: Enumerable<znote_global_storageWhereInput>
    key?: StringFilter | string
    value?: StringFilter | string
  }

  export type znote_global_storageOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type znote_global_storageWhereUniqueInput = {
    key?: string
  }

  export type znote_global_storageOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    _count?: znote_global_storageCountOrderByAggregateInput
    _max?: znote_global_storageMaxOrderByAggregateInput
    _min?: znote_global_storageMinOrderByAggregateInput
  }

  export type znote_global_storageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_global_storageScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_global_storageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_global_storageScalarWhereWithAggregatesInput>
    key?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
  }

  export type znote_guild_warsWhereInput = {
    AND?: Enumerable<znote_guild_warsWhereInput>
    OR?: Enumerable<znote_guild_warsWhereInput>
    NOT?: Enumerable<znote_guild_warsWhereInput>
    id?: IntFilter | number
    limit?: IntFilter | number
  }

  export type znote_guild_warsOrderByWithRelationInput = {
    id?: SortOrder
    limit?: SortOrder
  }

  export type znote_guild_warsWhereUniqueInput = {
    id?: number
  }

  export type znote_guild_warsOrderByWithAggregationInput = {
    id?: SortOrder
    limit?: SortOrder
    _count?: znote_guild_warsCountOrderByAggregateInput
    _avg?: znote_guild_warsAvgOrderByAggregateInput
    _max?: znote_guild_warsMaxOrderByAggregateInput
    _min?: znote_guild_warsMinOrderByAggregateInput
    _sum?: znote_guild_warsSumOrderByAggregateInput
  }

  export type znote_guild_warsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_guild_warsScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_guild_warsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_guild_warsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    limit?: IntWithAggregatesFilter | number
  }

  export type znote_imagesWhereInput = {
    AND?: Enumerable<znote_imagesWhereInput>
    OR?: Enumerable<znote_imagesWhereInput>
    NOT?: Enumerable<znote_imagesWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    desc?: StringFilter | string
    date?: IntFilter | number
    status?: IntFilter | number
    image?: StringFilter | string
    delhash?: StringFilter | string
    account_id?: IntFilter | number
  }

  export type znote_imagesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    date?: SortOrder
    status?: SortOrder
    image?: SortOrder
    delhash?: SortOrder
    account_id?: SortOrder
  }

  export type znote_imagesWhereUniqueInput = {
    id?: number
  }

  export type znote_imagesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    date?: SortOrder
    status?: SortOrder
    image?: SortOrder
    delhash?: SortOrder
    account_id?: SortOrder
    _count?: znote_imagesCountOrderByAggregateInput
    _avg?: znote_imagesAvgOrderByAggregateInput
    _max?: znote_imagesMaxOrderByAggregateInput
    _min?: znote_imagesMinOrderByAggregateInput
    _sum?: znote_imagesSumOrderByAggregateInput
  }

  export type znote_imagesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_imagesScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_imagesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_imagesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    desc?: StringWithAggregatesFilter | string
    date?: IntWithAggregatesFilter | number
    status?: IntWithAggregatesFilter | number
    image?: StringWithAggregatesFilter | string
    delhash?: StringWithAggregatesFilter | string
    account_id?: IntWithAggregatesFilter | number
  }

  export type znote_newsWhereInput = {
    AND?: Enumerable<znote_newsWhereInput>
    OR?: Enumerable<znote_newsWhereInput>
    NOT?: Enumerable<znote_newsWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    text?: StringFilter | string
    date?: IntFilter | number
    pid?: IntFilter | number
  }

  export type znote_newsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    text?: SortOrder
    date?: SortOrder
    pid?: SortOrder
  }

  export type znote_newsWhereUniqueInput = {
    id?: number
  }

  export type znote_newsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    text?: SortOrder
    date?: SortOrder
    pid?: SortOrder
    _count?: znote_newsCountOrderByAggregateInput
    _avg?: znote_newsAvgOrderByAggregateInput
    _max?: znote_newsMaxOrderByAggregateInput
    _min?: znote_newsMinOrderByAggregateInput
    _sum?: znote_newsSumOrderByAggregateInput
  }

  export type znote_newsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_newsScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_newsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_newsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    text?: StringWithAggregatesFilter | string
    date?: IntWithAggregatesFilter | number
    pid?: IntWithAggregatesFilter | number
  }

  export type znote_paygolWhereInput = {
    AND?: Enumerable<znote_paygolWhereInput>
    OR?: Enumerable<znote_paygolWhereInput>
    NOT?: Enumerable<znote_paygolWhereInput>
    id?: IntFilter | number
    account_id?: IntFilter | number
    price?: IntFilter | number
    points?: IntFilter | number
    message_id?: StringFilter | string
    service_id?: StringFilter | string
    shortcode?: StringFilter | string
    keyword?: StringFilter | string
    message?: StringFilter | string
    sender?: StringFilter | string
    operator?: StringFilter | string
    country?: StringFilter | string
    currency?: StringFilter | string
  }

  export type znote_paygolOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    price?: SortOrder
    points?: SortOrder
    message_id?: SortOrder
    service_id?: SortOrder
    shortcode?: SortOrder
    keyword?: SortOrder
    message?: SortOrder
    sender?: SortOrder
    operator?: SortOrder
    country?: SortOrder
    currency?: SortOrder
  }

  export type znote_paygolWhereUniqueInput = {
    id?: number
  }

  export type znote_paygolOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    price?: SortOrder
    points?: SortOrder
    message_id?: SortOrder
    service_id?: SortOrder
    shortcode?: SortOrder
    keyword?: SortOrder
    message?: SortOrder
    sender?: SortOrder
    operator?: SortOrder
    country?: SortOrder
    currency?: SortOrder
    _count?: znote_paygolCountOrderByAggregateInput
    _avg?: znote_paygolAvgOrderByAggregateInput
    _max?: znote_paygolMaxOrderByAggregateInput
    _min?: znote_paygolMinOrderByAggregateInput
    _sum?: znote_paygolSumOrderByAggregateInput
  }

  export type znote_paygolScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_paygolScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_paygolScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_paygolScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    account_id?: IntWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    points?: IntWithAggregatesFilter | number
    message_id?: StringWithAggregatesFilter | string
    service_id?: StringWithAggregatesFilter | string
    shortcode?: StringWithAggregatesFilter | string
    keyword?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    sender?: StringWithAggregatesFilter | string
    operator?: StringWithAggregatesFilter | string
    country?: StringWithAggregatesFilter | string
    currency?: StringWithAggregatesFilter | string
  }

  export type znote_paypalWhereInput = {
    AND?: Enumerable<znote_paypalWhereInput>
    OR?: Enumerable<znote_paypalWhereInput>
    NOT?: Enumerable<znote_paypalWhereInput>
    id?: IntFilter | number
    txn_id?: StringFilter | string
    email?: StringFilter | string
    accid?: IntFilter | number
    price?: IntFilter | number
    points?: IntFilter | number
  }

  export type znote_paypalOrderByWithRelationInput = {
    id?: SortOrder
    txn_id?: SortOrder
    email?: SortOrder
    accid?: SortOrder
    price?: SortOrder
    points?: SortOrder
  }

  export type znote_paypalWhereUniqueInput = {
    id?: number
  }

  export type znote_paypalOrderByWithAggregationInput = {
    id?: SortOrder
    txn_id?: SortOrder
    email?: SortOrder
    accid?: SortOrder
    price?: SortOrder
    points?: SortOrder
    _count?: znote_paypalCountOrderByAggregateInput
    _avg?: znote_paypalAvgOrderByAggregateInput
    _max?: znote_paypalMaxOrderByAggregateInput
    _min?: znote_paypalMinOrderByAggregateInput
    _sum?: znote_paypalSumOrderByAggregateInput
  }

  export type znote_paypalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_paypalScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_paypalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_paypalScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    txn_id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    accid?: IntWithAggregatesFilter | number
    price?: IntWithAggregatesFilter | number
    points?: IntWithAggregatesFilter | number
  }

  export type znote_player_reportsWhereInput = {
    AND?: Enumerable<znote_player_reportsWhereInput>
    OR?: Enumerable<znote_player_reportsWhereInput>
    NOT?: Enumerable<znote_player_reportsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    posx?: IntFilter | number
    posy?: IntFilter | number
    posz?: IntFilter | number
    report_description?: StringFilter | string
    date?: IntFilter | number
    status?: IntFilter | number
  }

  export type znote_player_reportsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    report_description?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type znote_player_reportsWhereUniqueInput = {
    id?: number
  }

  export type znote_player_reportsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    report_description?: SortOrder
    date?: SortOrder
    status?: SortOrder
    _count?: znote_player_reportsCountOrderByAggregateInput
    _avg?: znote_player_reportsAvgOrderByAggregateInput
    _max?: znote_player_reportsMaxOrderByAggregateInput
    _min?: znote_player_reportsMinOrderByAggregateInput
    _sum?: znote_player_reportsSumOrderByAggregateInput
  }

  export type znote_player_reportsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_player_reportsScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_player_reportsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_player_reportsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    posx?: IntWithAggregatesFilter | number
    posy?: IntWithAggregatesFilter | number
    posz?: IntWithAggregatesFilter | number
    report_description?: StringWithAggregatesFilter | string
    date?: IntWithAggregatesFilter | number
    status?: IntWithAggregatesFilter | number
  }

  export type znote_playersWhereInput = {
    AND?: Enumerable<znote_playersWhereInput>
    OR?: Enumerable<znote_playersWhereInput>
    NOT?: Enumerable<znote_playersWhereInput>
    id?: IntFilter | number
    player_id?: IntFilter | number
    created?: IntFilter | number
    hide_char?: IntFilter | number
    comment?: StringFilter | string
  }

  export type znote_playersOrderByWithRelationInput = {
    id?: SortOrder
    player_id?: SortOrder
    created?: SortOrder
    hide_char?: SortOrder
    comment?: SortOrder
  }

  export type znote_playersWhereUniqueInput = {
    id?: number
  }

  export type znote_playersOrderByWithAggregationInput = {
    id?: SortOrder
    player_id?: SortOrder
    created?: SortOrder
    hide_char?: SortOrder
    comment?: SortOrder
    _count?: znote_playersCountOrderByAggregateInput
    _avg?: znote_playersAvgOrderByAggregateInput
    _max?: znote_playersMaxOrderByAggregateInput
    _min?: znote_playersMinOrderByAggregateInput
    _sum?: znote_playersSumOrderByAggregateInput
  }

  export type znote_playersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_playersScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_playersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_playersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    player_id?: IntWithAggregatesFilter | number
    created?: IntWithAggregatesFilter | number
    hide_char?: IntWithAggregatesFilter | number
    comment?: StringWithAggregatesFilter | string
  }

  export type znote_shopWhereInput = {
    AND?: Enumerable<znote_shopWhereInput>
    OR?: Enumerable<znote_shopWhereInput>
    NOT?: Enumerable<znote_shopWhereInput>
    id?: IntFilter | number
    type?: IntFilter | number
    itemid?: IntNullableFilter | number | null
    count?: IntFilter | number
    description?: StringFilter | string
    points?: IntFilter | number
  }

  export type znote_shopOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    itemid?: SortOrderInput | SortOrder
    count?: SortOrder
    description?: SortOrder
    points?: SortOrder
  }

  export type znote_shopWhereUniqueInput = {
    id?: number
  }

  export type znote_shopOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    itemid?: SortOrderInput | SortOrder
    count?: SortOrder
    description?: SortOrder
    points?: SortOrder
    _count?: znote_shopCountOrderByAggregateInput
    _avg?: znote_shopAvgOrderByAggregateInput
    _max?: znote_shopMaxOrderByAggregateInput
    _min?: znote_shopMinOrderByAggregateInput
    _sum?: znote_shopSumOrderByAggregateInput
  }

  export type znote_shopScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_shopScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_shopScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_shopScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: IntWithAggregatesFilter | number
    itemid?: IntNullableWithAggregatesFilter | number | null
    count?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    points?: IntWithAggregatesFilter | number
  }

  export type znote_shop_logsWhereInput = {
    AND?: Enumerable<znote_shop_logsWhereInput>
    OR?: Enumerable<znote_shop_logsWhereInput>
    NOT?: Enumerable<znote_shop_logsWhereInput>
    id?: IntFilter | number
    account_id?: IntFilter | number
    player_id?: IntFilter | number
    type?: IntFilter | number
    itemid?: IntFilter | number
    count?: IntFilter | number
    points?: IntFilter | number
    time?: IntFilter | number
  }

  export type znote_shop_logsOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    points?: SortOrder
    time?: SortOrder
  }

  export type znote_shop_logsWhereUniqueInput = {
    id?: number
  }

  export type znote_shop_logsOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    points?: SortOrder
    time?: SortOrder
    _count?: znote_shop_logsCountOrderByAggregateInput
    _avg?: znote_shop_logsAvgOrderByAggregateInput
    _max?: znote_shop_logsMaxOrderByAggregateInput
    _min?: znote_shop_logsMinOrderByAggregateInput
    _sum?: znote_shop_logsSumOrderByAggregateInput
  }

  export type znote_shop_logsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_shop_logsScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_shop_logsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_shop_logsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    account_id?: IntWithAggregatesFilter | number
    player_id?: IntWithAggregatesFilter | number
    type?: IntWithAggregatesFilter | number
    itemid?: IntWithAggregatesFilter | number
    count?: IntWithAggregatesFilter | number
    points?: IntWithAggregatesFilter | number
    time?: IntWithAggregatesFilter | number
  }

  export type znote_shop_ordersWhereInput = {
    AND?: Enumerable<znote_shop_ordersWhereInput>
    OR?: Enumerable<znote_shop_ordersWhereInput>
    NOT?: Enumerable<znote_shop_ordersWhereInput>
    id?: IntFilter | number
    account_id?: IntFilter | number
    type?: IntFilter | number
    itemid?: IntFilter | number
    count?: IntFilter | number
    time?: IntFilter | number
  }

  export type znote_shop_ordersOrderByWithRelationInput = {
    id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    time?: SortOrder
  }

  export type znote_shop_ordersWhereUniqueInput = {
    id?: number
  }

  export type znote_shop_ordersOrderByWithAggregationInput = {
    id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    time?: SortOrder
    _count?: znote_shop_ordersCountOrderByAggregateInput
    _avg?: znote_shop_ordersAvgOrderByAggregateInput
    _max?: znote_shop_ordersMaxOrderByAggregateInput
    _min?: znote_shop_ordersMinOrderByAggregateInput
    _sum?: znote_shop_ordersSumOrderByAggregateInput
  }

  export type znote_shop_ordersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_shop_ordersScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_shop_ordersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_shop_ordersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    account_id?: IntWithAggregatesFilter | number
    type?: IntWithAggregatesFilter | number
    itemid?: IntWithAggregatesFilter | number
    count?: IntWithAggregatesFilter | number
    time?: IntWithAggregatesFilter | number
  }

  export type znote_ticketsWhereInput = {
    AND?: Enumerable<znote_ticketsWhereInput>
    OR?: Enumerable<znote_ticketsWhereInput>
    NOT?: Enumerable<znote_ticketsWhereInput>
    id?: IntFilter | number
    owner?: IntFilter | number
    username?: StringFilter | string
    subject?: StringFilter | string
    message?: StringFilter | string
    ip?: BigIntFilter | bigint | number
    creation?: IntFilter | number
    status?: StringFilter | string
  }

  export type znote_ticketsOrderByWithRelationInput = {
    id?: SortOrder
    owner?: SortOrder
    username?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    ip?: SortOrder
    creation?: SortOrder
    status?: SortOrder
  }

  export type znote_ticketsWhereUniqueInput = {
    id?: number
  }

  export type znote_ticketsOrderByWithAggregationInput = {
    id?: SortOrder
    owner?: SortOrder
    username?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    ip?: SortOrder
    creation?: SortOrder
    status?: SortOrder
    _count?: znote_ticketsCountOrderByAggregateInput
    _avg?: znote_ticketsAvgOrderByAggregateInput
    _max?: znote_ticketsMaxOrderByAggregateInput
    _min?: znote_ticketsMinOrderByAggregateInput
    _sum?: znote_ticketsSumOrderByAggregateInput
  }

  export type znote_ticketsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_ticketsScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_ticketsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_ticketsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    owner?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    subject?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    ip?: BigIntWithAggregatesFilter | bigint | number
    creation?: IntWithAggregatesFilter | number
    status?: StringWithAggregatesFilter | string
  }

  export type znote_tickets_repliesWhereInput = {
    AND?: Enumerable<znote_tickets_repliesWhereInput>
    OR?: Enumerable<znote_tickets_repliesWhereInput>
    NOT?: Enumerable<znote_tickets_repliesWhereInput>
    id?: IntFilter | number
    tid?: IntFilter | number
    username?: StringFilter | string
    message?: StringFilter | string
    created?: IntFilter | number
  }

  export type znote_tickets_repliesOrderByWithRelationInput = {
    id?: SortOrder
    tid?: SortOrder
    username?: SortOrder
    message?: SortOrder
    created?: SortOrder
  }

  export type znote_tickets_repliesWhereUniqueInput = {
    id?: number
  }

  export type znote_tickets_repliesOrderByWithAggregationInput = {
    id?: SortOrder
    tid?: SortOrder
    username?: SortOrder
    message?: SortOrder
    created?: SortOrder
    _count?: znote_tickets_repliesCountOrderByAggregateInput
    _avg?: znote_tickets_repliesAvgOrderByAggregateInput
    _max?: znote_tickets_repliesMaxOrderByAggregateInput
    _min?: znote_tickets_repliesMinOrderByAggregateInput
    _sum?: znote_tickets_repliesSumOrderByAggregateInput
  }

  export type znote_tickets_repliesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_tickets_repliesScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_tickets_repliesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_tickets_repliesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    tid?: IntWithAggregatesFilter | number
    username?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    created?: IntWithAggregatesFilter | number
  }

  export type znote_visitorsWhereInput = {
    AND?: Enumerable<znote_visitorsWhereInput>
    OR?: Enumerable<znote_visitorsWhereInput>
    NOT?: Enumerable<znote_visitorsWhereInput>
    id?: IntFilter | number
    ip?: BigIntFilter | bigint | number
    value?: IntFilter | number
  }

  export type znote_visitorsOrderByWithRelationInput = {
    id?: SortOrder
    ip?: SortOrder
    value?: SortOrder
  }

  export type znote_visitorsWhereUniqueInput = {
    id?: number
  }

  export type znote_visitorsOrderByWithAggregationInput = {
    id?: SortOrder
    ip?: SortOrder
    value?: SortOrder
    _count?: znote_visitorsCountOrderByAggregateInput
    _avg?: znote_visitorsAvgOrderByAggregateInput
    _max?: znote_visitorsMaxOrderByAggregateInput
    _min?: znote_visitorsMinOrderByAggregateInput
    _sum?: znote_visitorsSumOrderByAggregateInput
  }

  export type znote_visitorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_visitorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_visitorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_visitorsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ip?: BigIntWithAggregatesFilter | bigint | number
    value?: IntWithAggregatesFilter | number
  }

  export type znote_visitors_detailsWhereInput = {
    AND?: Enumerable<znote_visitors_detailsWhereInput>
    OR?: Enumerable<znote_visitors_detailsWhereInput>
    NOT?: Enumerable<znote_visitors_detailsWhereInput>
    id?: IntFilter | number
    ip?: BigIntFilter | bigint | number
    time?: IntFilter | number
    type?: IntFilter | number
    account_id?: IntFilter | number
  }

  export type znote_visitors_detailsOrderByWithRelationInput = {
    id?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    type?: SortOrder
    account_id?: SortOrder
  }

  export type znote_visitors_detailsWhereUniqueInput = {
    id?: number
  }

  export type znote_visitors_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    type?: SortOrder
    account_id?: SortOrder
    _count?: znote_visitors_detailsCountOrderByAggregateInput
    _avg?: znote_visitors_detailsAvgOrderByAggregateInput
    _max?: znote_visitors_detailsMaxOrderByAggregateInput
    _min?: znote_visitors_detailsMinOrderByAggregateInput
    _sum?: znote_visitors_detailsSumOrderByAggregateInput
  }

  export type znote_visitors_detailsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<znote_visitors_detailsScalarWhereWithAggregatesInput>
    OR?: Enumerable<znote_visitors_detailsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<znote_visitors_detailsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ip?: BigIntWithAggregatesFilter | bigint | number
    time?: IntWithAggregatesFilter | number
    type?: IntWithAggregatesFilter | number
    account_id?: IntWithAggregatesFilter | number
  }

  export type AccountCreateInput = {
    name: string
    password: string
    secret?: string | null
    type?: number
    premium_ends_at?: number
    email?: string
    creation?: number
    premium_points?: number
    premdays: number
    wallet?: string | null
    alpha_key?: string | null
    account_ban_history?: account_ban_historyCreateNestedManyWithoutAccountsInput
    account_bans?: account_bansCreateNestedOneWithoutAccountsInput
    account_storage?: account_storageCreateNestedManyWithoutAccountsInput
    account_viplist?: account_viplistCreateNestedManyWithoutAccountsInput
    players?: PlayerCreateNestedManyWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: number
    name: string
    password: string
    secret?: string | null
    type?: number
    premium_ends_at?: number
    email?: string
    creation?: number
    premium_points?: number
    premdays: number
    wallet?: string | null
    alpha_key?: string | null
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutAccountsInput
    account_bans?: account_bansUncheckedCreateNestedOneWithoutAccountsInput
    account_storage?: account_storageUncheckedCreateNestedManyWithoutAccountsInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutAccountsInput
    players?: PlayerUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type AccountUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
    account_ban_history?: account_ban_historyUpdateManyWithoutAccountsNestedInput
    account_bans?: account_bansUpdateOneWithoutAccountsNestedInput
    account_storage?: account_storageUpdateManyWithoutAccountsNestedInput
    account_viplist?: account_viplistUpdateManyWithoutAccountsNestedInput
    players?: PlayerUpdateManyWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutAccountsNestedInput
    account_bans?: account_bansUncheckedUpdateOneWithoutAccountsNestedInput
    account_storage?: account_storageUncheckedUpdateManyWithoutAccountsNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutAccountsNestedInput
    players?: PlayerUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type AccountCreateManyInput = {
    id?: number
    name: string
    password: string
    secret?: string | null
    type?: number
    premium_ends_at?: number
    email?: string
    creation?: number
    premium_points?: number
    premdays: number
    wallet?: string | null
    alpha_key?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlayerCreateInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type PlayerCreateManyInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
  }

  export type PlayerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
  }

  export type HouseCreateInput = {
    owner: number
    paid?: number
    warnings?: number
    name: string
    rent?: number
    town_id?: number
    bid?: number
    bid_end?: number
    last_bid?: number
    highest_bidder?: number
    size?: number
    beds?: number
    land_zone?: string
    land_plot?: string
    bioma?: string
    land_size?: string
    plant?: string
    harvest?: string
    mining?: string
    livestock?: string
    fishing_boat?: string
    json_data?: NullableJsonNullValueInput | InputJsonValue
    enable?: boolean
  }

  export type HouseUncheckedCreateInput = {
    id?: number
    owner: number
    paid?: number
    warnings?: number
    name: string
    rent?: number
    town_id?: number
    bid?: number
    bid_end?: number
    last_bid?: number
    highest_bidder?: number
    size?: number
    beds?: number
    land_zone?: string
    land_plot?: string
    bioma?: string
    land_size?: string
    plant?: string
    harvest?: string
    mining?: string
    livestock?: string
    fishing_boat?: string
    json_data?: NullableJsonNullValueInput | InputJsonValue
    enable?: boolean
  }

  export type HouseUpdateInput = {
    owner?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rent?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    bid?: IntFieldUpdateOperationsInput | number
    bid_end?: IntFieldUpdateOperationsInput | number
    last_bid?: IntFieldUpdateOperationsInput | number
    highest_bidder?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    beds?: IntFieldUpdateOperationsInput | number
    land_zone?: StringFieldUpdateOperationsInput | string
    land_plot?: StringFieldUpdateOperationsInput | string
    bioma?: StringFieldUpdateOperationsInput | string
    land_size?: StringFieldUpdateOperationsInput | string
    plant?: StringFieldUpdateOperationsInput | string
    harvest?: StringFieldUpdateOperationsInput | string
    mining?: StringFieldUpdateOperationsInput | string
    livestock?: StringFieldUpdateOperationsInput | string
    fishing_boat?: StringFieldUpdateOperationsInput | string
    json_data?: NullableJsonNullValueInput | InputJsonValue
    enable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HouseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    owner?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rent?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    bid?: IntFieldUpdateOperationsInput | number
    bid_end?: IntFieldUpdateOperationsInput | number
    last_bid?: IntFieldUpdateOperationsInput | number
    highest_bidder?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    beds?: IntFieldUpdateOperationsInput | number
    land_zone?: StringFieldUpdateOperationsInput | string
    land_plot?: StringFieldUpdateOperationsInput | string
    bioma?: StringFieldUpdateOperationsInput | string
    land_size?: StringFieldUpdateOperationsInput | string
    plant?: StringFieldUpdateOperationsInput | string
    harvest?: StringFieldUpdateOperationsInput | string
    mining?: StringFieldUpdateOperationsInput | string
    livestock?: StringFieldUpdateOperationsInput | string
    fishing_boat?: StringFieldUpdateOperationsInput | string
    json_data?: NullableJsonNullValueInput | InputJsonValue
    enable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HouseCreateManyInput = {
    id?: number
    owner: number
    paid?: number
    warnings?: number
    name: string
    rent?: number
    town_id?: number
    bid?: number
    bid_end?: number
    last_bid?: number
    highest_bidder?: number
    size?: number
    beds?: number
    land_zone?: string
    land_plot?: string
    bioma?: string
    land_size?: string
    plant?: string
    harvest?: string
    mining?: string
    livestock?: string
    fishing_boat?: string
    json_data?: NullableJsonNullValueInput | InputJsonValue
    enable?: boolean
  }

  export type HouseUpdateManyMutationInput = {
    owner?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rent?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    bid?: IntFieldUpdateOperationsInput | number
    bid_end?: IntFieldUpdateOperationsInput | number
    last_bid?: IntFieldUpdateOperationsInput | number
    highest_bidder?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    beds?: IntFieldUpdateOperationsInput | number
    land_zone?: StringFieldUpdateOperationsInput | string
    land_plot?: StringFieldUpdateOperationsInput | string
    bioma?: StringFieldUpdateOperationsInput | string
    land_size?: StringFieldUpdateOperationsInput | string
    plant?: StringFieldUpdateOperationsInput | string
    harvest?: StringFieldUpdateOperationsInput | string
    mining?: StringFieldUpdateOperationsInput | string
    livestock?: StringFieldUpdateOperationsInput | string
    fishing_boat?: StringFieldUpdateOperationsInput | string
    json_data?: NullableJsonNullValueInput | InputJsonValue
    enable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HouseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    owner?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    warnings?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    rent?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    bid?: IntFieldUpdateOperationsInput | number
    bid_end?: IntFieldUpdateOperationsInput | number
    last_bid?: IntFieldUpdateOperationsInput | number
    highest_bidder?: IntFieldUpdateOperationsInput | number
    size?: IntFieldUpdateOperationsInput | number
    beds?: IntFieldUpdateOperationsInput | number
    land_zone?: StringFieldUpdateOperationsInput | string
    land_plot?: StringFieldUpdateOperationsInput | string
    bioma?: StringFieldUpdateOperationsInput | string
    land_size?: StringFieldUpdateOperationsInput | string
    plant?: StringFieldUpdateOperationsInput | string
    harvest?: StringFieldUpdateOperationsInput | string
    mining?: StringFieldUpdateOperationsInput | string
    livestock?: StringFieldUpdateOperationsInput | string
    fishing_boat?: StringFieldUpdateOperationsInput | string
    json_data?: NullableJsonNullValueInput | InputJsonValue
    enable?: BoolFieldUpdateOperationsInput | boolean
  }

  export type account_ban_historyCreateInput = {
    reason: string
    banned_at: bigint | number
    expired_at: bigint | number
    accounts: AccountCreateNestedOneWithoutAccount_ban_historyInput
    players: PlayerCreateNestedOneWithoutAccount_ban_historyInput
  }

  export type account_ban_historyUncheckedCreateInput = {
    id?: number
    account_id: number
    reason: string
    banned_at: bigint | number
    expired_at: bigint | number
    banned_by: number
  }

  export type account_ban_historyUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expired_at?: BigIntFieldUpdateOperationsInput | bigint | number
    accounts?: AccountUpdateOneRequiredWithoutAccount_ban_historyNestedInput
    players?: PlayerUpdateOneRequiredWithoutAccount_ban_historyNestedInput
  }

  export type account_ban_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expired_at?: BigIntFieldUpdateOperationsInput | bigint | number
    banned_by?: IntFieldUpdateOperationsInput | number
  }

  export type account_ban_historyCreateManyInput = {
    id?: number
    account_id: number
    reason: string
    banned_at: bigint | number
    expired_at: bigint | number
    banned_by: number
  }

  export type account_ban_historyUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expired_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type account_ban_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expired_at?: BigIntFieldUpdateOperationsInput | bigint | number
    banned_by?: IntFieldUpdateOperationsInput | number
  }

  export type account_bansCreateInput = {
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
    accounts: AccountCreateNestedOneWithoutAccount_bansInput
    players: PlayerCreateNestedOneWithoutAccount_bansInput
  }

  export type account_bansUncheckedCreateInput = {
    account_id: number
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
    banned_by: number
  }

  export type account_bansUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    accounts?: AccountUpdateOneRequiredWithoutAccount_bansNestedInput
    players?: PlayerUpdateOneRequiredWithoutAccount_bansNestedInput
  }

  export type account_bansUncheckedUpdateInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    banned_by?: IntFieldUpdateOperationsInput | number
  }

  export type account_bansCreateManyInput = {
    account_id: number
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
    banned_by: number
  }

  export type account_bansUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type account_bansUncheckedUpdateManyInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    banned_by?: IntFieldUpdateOperationsInput | number
  }

  export type account_storageCreateInput = {
    key: number
    value: number
    accounts: AccountCreateNestedOneWithoutAccount_storageInput
  }

  export type account_storageUncheckedCreateInput = {
    account_id: number
    key: number
    value: number
  }

  export type account_storageUpdateInput = {
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    accounts?: AccountUpdateOneRequiredWithoutAccount_storageNestedInput
  }

  export type account_storageUncheckedUpdateInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type account_storageCreateManyInput = {
    account_id: number
    key: number
    value: number
  }

  export type account_storageUpdateManyMutationInput = {
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type account_storageUncheckedUpdateManyInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type account_viplistCreateInput = {
    description?: string
    icon?: number
    notify?: boolean
    accounts: AccountCreateNestedOneWithoutAccount_viplistInput
    players: PlayerCreateNestedOneWithoutAccount_viplistInput
  }

  export type account_viplistUncheckedCreateInput = {
    account_id: number
    player_id: number
    description?: string
    icon?: number
    notify?: boolean
  }

  export type account_viplistUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    icon?: IntFieldUpdateOperationsInput | number
    notify?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateOneRequiredWithoutAccount_viplistNestedInput
    players?: PlayerUpdateOneRequiredWithoutAccount_viplistNestedInput
  }

  export type account_viplistUncheckedUpdateInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    icon?: IntFieldUpdateOperationsInput | number
    notify?: BoolFieldUpdateOperationsInput | boolean
  }

  export type account_viplistCreateManyInput = {
    account_id: number
    player_id: number
    description?: string
    icon?: number
    notify?: boolean
  }

  export type account_viplistUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    icon?: IntFieldUpdateOperationsInput | number
    notify?: BoolFieldUpdateOperationsInput | boolean
  }

  export type account_viplistUncheckedUpdateManyInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    icon?: IntFieldUpdateOperationsInput | number
    notify?: BoolFieldUpdateOperationsInput | boolean
  }

  export type guild_invitesCreateInput = {
    players?: PlayerCreateNestedOneWithoutGuild_invitesInput
    guilds?: guildsCreateNestedOneWithoutGuild_invitesInput
  }

  export type guild_invitesUncheckedCreateInput = {
    player_id?: number
    guild_id?: number
  }

  export type guild_invitesUpdateInput = {
    players?: PlayerUpdateOneRequiredWithoutGuild_invitesNestedInput
    guilds?: guildsUpdateOneRequiredWithoutGuild_invitesNestedInput
  }

  export type guild_invitesUncheckedUpdateInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    guild_id?: IntFieldUpdateOperationsInput | number
  }

  export type guild_invitesCreateManyInput = {
    player_id?: number
    guild_id?: number
  }

  export type guild_invitesUpdateManyMutationInput = {

  }

  export type guild_invitesUncheckedUpdateManyInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    guild_id?: IntFieldUpdateOperationsInput | number
  }

  export type guild_membershipCreateInput = {
    nick?: string
    players: PlayerCreateNestedOneWithoutGuild_membershipInput
    guilds: guildsCreateNestedOneWithoutGuild_membershipInput
    guild_ranks: guild_ranksCreateNestedOneWithoutGuild_membershipInput
  }

  export type guild_membershipUncheckedCreateInput = {
    player_id: number
    guild_id: number
    rank_id: number
    nick?: string
  }

  export type guild_membershipUpdateInput = {
    nick?: StringFieldUpdateOperationsInput | string
    players?: PlayerUpdateOneRequiredWithoutGuild_membershipNestedInput
    guilds?: guildsUpdateOneRequiredWithoutGuild_membershipNestedInput
    guild_ranks?: guild_ranksUpdateOneRequiredWithoutGuild_membershipNestedInput
  }

  export type guild_membershipUncheckedUpdateInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    guild_id?: IntFieldUpdateOperationsInput | number
    rank_id?: IntFieldUpdateOperationsInput | number
    nick?: StringFieldUpdateOperationsInput | string
  }

  export type guild_membershipCreateManyInput = {
    player_id: number
    guild_id: number
    rank_id: number
    nick?: string
  }

  export type guild_membershipUpdateManyMutationInput = {
    nick?: StringFieldUpdateOperationsInput | string
  }

  export type guild_membershipUncheckedUpdateManyInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    guild_id?: IntFieldUpdateOperationsInput | number
    rank_id?: IntFieldUpdateOperationsInput | number
    nick?: StringFieldUpdateOperationsInput | string
  }

  export type guild_ranksCreateInput = {
    name: string
    level: number
    guild_membership?: guild_membershipCreateNestedManyWithoutGuild_ranksInput
    guilds: guildsCreateNestedOneWithoutGuild_ranksInput
  }

  export type guild_ranksUncheckedCreateInput = {
    id?: number
    guild_id: number
    name: string
    level: number
    guild_membership?: guild_membershipUncheckedCreateNestedManyWithoutGuild_ranksInput
  }

  export type guild_ranksUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    guild_membership?: guild_membershipUpdateManyWithoutGuild_ranksNestedInput
    guilds?: guildsUpdateOneRequiredWithoutGuild_ranksNestedInput
  }

  export type guild_ranksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    guild_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    guild_membership?: guild_membershipUncheckedUpdateManyWithoutGuild_ranksNestedInput
  }

  export type guild_ranksCreateManyInput = {
    id?: number
    guild_id: number
    name: string
    level: number
  }

  export type guild_ranksUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type guild_ranksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    guild_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type guild_warsCreateInput = {
    guild1?: number
    guild2?: number
    name1: string
    name2: string
    status?: number
    started?: bigint | number
    ended?: bigint | number
    guildwar_kills?: guildwar_killsCreateNestedManyWithoutGuild_warsInput
  }

  export type guild_warsUncheckedCreateInput = {
    id?: number
    guild1?: number
    guild2?: number
    name1: string
    name2: string
    status?: number
    started?: bigint | number
    ended?: bigint | number
    guildwar_kills?: guildwar_killsUncheckedCreateNestedManyWithoutGuild_warsInput
  }

  export type guild_warsUpdateInput = {
    guild1?: IntFieldUpdateOperationsInput | number
    guild2?: IntFieldUpdateOperationsInput | number
    name1?: StringFieldUpdateOperationsInput | string
    name2?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    started?: BigIntFieldUpdateOperationsInput | bigint | number
    ended?: BigIntFieldUpdateOperationsInput | bigint | number
    guildwar_kills?: guildwar_killsUpdateManyWithoutGuild_warsNestedInput
  }

  export type guild_warsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    guild1?: IntFieldUpdateOperationsInput | number
    guild2?: IntFieldUpdateOperationsInput | number
    name1?: StringFieldUpdateOperationsInput | string
    name2?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    started?: BigIntFieldUpdateOperationsInput | bigint | number
    ended?: BigIntFieldUpdateOperationsInput | bigint | number
    guildwar_kills?: guildwar_killsUncheckedUpdateManyWithoutGuild_warsNestedInput
  }

  export type guild_warsCreateManyInput = {
    id?: number
    guild1?: number
    guild2?: number
    name1: string
    name2: string
    status?: number
    started?: bigint | number
    ended?: bigint | number
  }

  export type guild_warsUpdateManyMutationInput = {
    guild1?: IntFieldUpdateOperationsInput | number
    guild2?: IntFieldUpdateOperationsInput | number
    name1?: StringFieldUpdateOperationsInput | string
    name2?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    started?: BigIntFieldUpdateOperationsInput | bigint | number
    ended?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type guild_warsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    guild1?: IntFieldUpdateOperationsInput | number
    guild2?: IntFieldUpdateOperationsInput | number
    name1?: StringFieldUpdateOperationsInput | string
    name2?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    started?: BigIntFieldUpdateOperationsInput | bigint | number
    ended?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type guildsCreateInput = {
    name: string
    creationdata: number
    motd?: string
    guild_invites?: guild_invitesCreateNestedManyWithoutGuildsInput
    guild_membership?: guild_membershipCreateNestedManyWithoutGuildsInput
    guild_ranks?: guild_ranksCreateNestedManyWithoutGuildsInput
    players: PlayerCreateNestedOneWithoutGuildsInput
  }

  export type guildsUncheckedCreateInput = {
    id?: number
    name: string
    ownerid: number
    creationdata: number
    motd?: string
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutGuildsInput
    guild_membership?: guild_membershipUncheckedCreateNestedManyWithoutGuildsInput
    guild_ranks?: guild_ranksUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type guildsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    creationdata?: IntFieldUpdateOperationsInput | number
    motd?: StringFieldUpdateOperationsInput | string
    guild_invites?: guild_invitesUpdateManyWithoutGuildsNestedInput
    guild_membership?: guild_membershipUpdateManyWithoutGuildsNestedInput
    guild_ranks?: guild_ranksUpdateManyWithoutGuildsNestedInput
    players?: PlayerUpdateOneRequiredWithoutGuildsNestedInput
  }

  export type guildsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerid?: IntFieldUpdateOperationsInput | number
    creationdata?: IntFieldUpdateOperationsInput | number
    motd?: StringFieldUpdateOperationsInput | string
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutGuildsNestedInput
    guild_membership?: guild_membershipUncheckedUpdateManyWithoutGuildsNestedInput
    guild_ranks?: guild_ranksUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type guildsCreateManyInput = {
    id?: number
    name: string
    ownerid: number
    creationdata: number
    motd?: string
  }

  export type guildsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    creationdata?: IntFieldUpdateOperationsInput | number
    motd?: StringFieldUpdateOperationsInput | string
  }

  export type guildsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerid?: IntFieldUpdateOperationsInput | number
    creationdata?: IntFieldUpdateOperationsInput | number
    motd?: StringFieldUpdateOperationsInput | string
  }

  export type guildwar_killsCreateInput = {
    killer: string
    target: string
    killerguild?: number
    targetguild?: number
    time: bigint | number
    guild_wars?: guild_warsCreateNestedOneWithoutGuildwar_killsInput
  }

  export type guildwar_killsUncheckedCreateInput = {
    id?: number
    killer: string
    target: string
    killerguild?: number
    targetguild?: number
    warid?: number
    time: bigint | number
  }

  export type guildwar_killsUpdateInput = {
    killer?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    killerguild?: IntFieldUpdateOperationsInput | number
    targetguild?: IntFieldUpdateOperationsInput | number
    time?: BigIntFieldUpdateOperationsInput | bigint | number
    guild_wars?: guild_warsUpdateOneRequiredWithoutGuildwar_killsNestedInput
  }

  export type guildwar_killsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    killer?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    killerguild?: IntFieldUpdateOperationsInput | number
    targetguild?: IntFieldUpdateOperationsInput | number
    warid?: IntFieldUpdateOperationsInput | number
    time?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type guildwar_killsCreateManyInput = {
    id?: number
    killer: string
    target: string
    killerguild?: number
    targetguild?: number
    warid?: number
    time: bigint | number
  }

  export type guildwar_killsUpdateManyMutationInput = {
    killer?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    killerguild?: IntFieldUpdateOperationsInput | number
    targetguild?: IntFieldUpdateOperationsInput | number
    time?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type guildwar_killsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    killer?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    killerguild?: IntFieldUpdateOperationsInput | number
    targetguild?: IntFieldUpdateOperationsInput | number
    warid?: IntFieldUpdateOperationsInput | number
    time?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ip_bansCreateInput = {
    ip: number
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
    players: PlayerCreateNestedOneWithoutIp_bansInput
  }

  export type ip_bansUncheckedCreateInput = {
    ip: number
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
    banned_by: number
  }

  export type ip_bansUpdateInput = {
    ip?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    players?: PlayerUpdateOneRequiredWithoutIp_bansNestedInput
  }

  export type ip_bansUncheckedUpdateInput = {
    ip?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    banned_by?: IntFieldUpdateOperationsInput | number
  }

  export type ip_bansCreateManyInput = {
    ip: number
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
    banned_by: number
  }

  export type ip_bansUpdateManyMutationInput = {
    ip?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ip_bansUncheckedUpdateManyInput = {
    ip?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    banned_by?: IntFieldUpdateOperationsInput | number
  }

  export type market_historyCreateInput = {
    sale?: boolean
    itemtype: number
    amount: number
    price?: number
    expires_at: bigint | number
    inserted: bigint | number
    state: number
    players: PlayerCreateNestedOneWithoutMarket_historyInput
  }

  export type market_historyUncheckedCreateInput = {
    id?: number
    player_id: number
    sale?: boolean
    itemtype: number
    amount: number
    price?: number
    expires_at: bigint | number
    inserted: bigint | number
    state: number
  }

  export type market_historyUpdateInput = {
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    inserted?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: IntFieldUpdateOperationsInput | number
    players?: PlayerUpdateOneRequiredWithoutMarket_historyNestedInput
  }

  export type market_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    inserted?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: IntFieldUpdateOperationsInput | number
  }

  export type market_historyCreateManyInput = {
    id?: number
    player_id: number
    sale?: boolean
    itemtype: number
    amount: number
    price?: number
    expires_at: bigint | number
    inserted: bigint | number
    state: number
  }

  export type market_historyUpdateManyMutationInput = {
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    inserted?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: IntFieldUpdateOperationsInput | number
  }

  export type market_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    inserted?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: IntFieldUpdateOperationsInput | number
  }

  export type market_offersCreateInput = {
    sale?: boolean
    itemtype: number
    amount: number
    created: bigint | number
    anonymous?: boolean
    price?: number
    players: PlayerCreateNestedOneWithoutMarket_offersInput
  }

  export type market_offersUncheckedCreateInput = {
    id?: number
    player_id: number
    sale?: boolean
    itemtype: number
    amount: number
    created: bigint | number
    anonymous?: boolean
    price?: number
  }

  export type market_offersUpdateInput = {
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    created?: BigIntFieldUpdateOperationsInput | bigint | number
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    players?: PlayerUpdateOneRequiredWithoutMarket_offersNestedInput
  }

  export type market_offersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    created?: BigIntFieldUpdateOperationsInput | bigint | number
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
  }

  export type market_offersCreateManyInput = {
    id?: number
    player_id: number
    sale?: boolean
    itemtype: number
    amount: number
    created: bigint | number
    anonymous?: boolean
    price?: number
  }

  export type market_offersUpdateManyMutationInput = {
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    created?: BigIntFieldUpdateOperationsInput | bigint | number
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
  }

  export type market_offersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    created?: BigIntFieldUpdateOperationsInput | bigint | number
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
  }

  export type petsCreateInput = {
    id: number
    type: number
    rank: number
    stage: number
    name: string
    pet: string
    owner: string
    level: number
    experience: number
    addonItem: number
    strength: number
    wisdom: number
    agility: number
    sustain: number
    magicResistance: number
    lucky: number
    hungry: number
    hygiene?: number
    happiness: number
    health: bigint | number
    cooldowns: string
    world_id?: boolean
    wallet: string
  }

  export type petsUncheckedCreateInput = {
    id: number
    type: number
    rank: number
    stage: number
    name: string
    pet: string
    owner: string
    level: number
    experience: number
    addonItem: number
    strength: number
    wisdom: number
    agility: number
    sustain: number
    magicResistance: number
    lucky: number
    hungry: number
    hygiene?: number
    happiness: number
    health: bigint | number
    cooldowns: string
    world_id?: boolean
    wallet: string
  }

  export type petsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    stage?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    pet?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    addonItem?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    sustain?: IntFieldUpdateOperationsInput | number
    magicResistance?: IntFieldUpdateOperationsInput | number
    lucky?: IntFieldUpdateOperationsInput | number
    hungry?: IntFieldUpdateOperationsInput | number
    hygiene?: IntFieldUpdateOperationsInput | number
    happiness?: IntFieldUpdateOperationsInput | number
    health?: BigIntFieldUpdateOperationsInput | bigint | number
    cooldowns?: StringFieldUpdateOperationsInput | string
    world_id?: BoolFieldUpdateOperationsInput | boolean
    wallet?: StringFieldUpdateOperationsInput | string
  }

  export type petsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    stage?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    pet?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    addonItem?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    sustain?: IntFieldUpdateOperationsInput | number
    magicResistance?: IntFieldUpdateOperationsInput | number
    lucky?: IntFieldUpdateOperationsInput | number
    hungry?: IntFieldUpdateOperationsInput | number
    hygiene?: IntFieldUpdateOperationsInput | number
    happiness?: IntFieldUpdateOperationsInput | number
    health?: BigIntFieldUpdateOperationsInput | bigint | number
    cooldowns?: StringFieldUpdateOperationsInput | string
    world_id?: BoolFieldUpdateOperationsInput | boolean
    wallet?: StringFieldUpdateOperationsInput | string
  }

  export type petsCreateManyInput = {
    id: number
    type: number
    rank: number
    stage: number
    name: string
    pet: string
    owner: string
    level: number
    experience: number
    addonItem: number
    strength: number
    wisdom: number
    agility: number
    sustain: number
    magicResistance: number
    lucky: number
    hungry: number
    hygiene?: number
    happiness: number
    health: bigint | number
    cooldowns: string
    world_id?: boolean
    wallet: string
  }

  export type petsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    stage?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    pet?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    addonItem?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    sustain?: IntFieldUpdateOperationsInput | number
    magicResistance?: IntFieldUpdateOperationsInput | number
    lucky?: IntFieldUpdateOperationsInput | number
    hungry?: IntFieldUpdateOperationsInput | number
    hygiene?: IntFieldUpdateOperationsInput | number
    happiness?: IntFieldUpdateOperationsInput | number
    health?: BigIntFieldUpdateOperationsInput | bigint | number
    cooldowns?: StringFieldUpdateOperationsInput | string
    world_id?: BoolFieldUpdateOperationsInput | boolean
    wallet?: StringFieldUpdateOperationsInput | string
  }

  export type petsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    stage?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    pet?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    addonItem?: IntFieldUpdateOperationsInput | number
    strength?: IntFieldUpdateOperationsInput | number
    wisdom?: IntFieldUpdateOperationsInput | number
    agility?: IntFieldUpdateOperationsInput | number
    sustain?: IntFieldUpdateOperationsInput | number
    magicResistance?: IntFieldUpdateOperationsInput | number
    lucky?: IntFieldUpdateOperationsInput | number
    hungry?: IntFieldUpdateOperationsInput | number
    hygiene?: IntFieldUpdateOperationsInput | number
    happiness?: IntFieldUpdateOperationsInput | number
    health?: BigIntFieldUpdateOperationsInput | bigint | number
    cooldowns?: StringFieldUpdateOperationsInput | string
    world_id?: BoolFieldUpdateOperationsInput | boolean
    wallet?: StringFieldUpdateOperationsInput | string
  }

  export type player_depotitemsCreateInput = {
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
    players: PlayerCreateNestedOneWithoutPlayer_depotitemsInput
  }

  export type player_depotitemsUncheckedCreateInput = {
    player_id: number
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_depotitemsUpdateInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
    players?: PlayerUpdateOneRequiredWithoutPlayer_depotitemsNestedInput
  }

  export type player_depotitemsUncheckedUpdateInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_depotitemsCreateManyInput = {
    player_id: number
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_depotitemsUpdateManyMutationInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_depotitemsUncheckedUpdateManyInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_inboxitemsCreateInput = {
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
    players: PlayerCreateNestedOneWithoutPlayer_inboxitemsInput
  }

  export type player_inboxitemsUncheckedCreateInput = {
    player_id: number
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_inboxitemsUpdateInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
    players?: PlayerUpdateOneRequiredWithoutPlayer_inboxitemsNestedInput
  }

  export type player_inboxitemsUncheckedUpdateInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_inboxitemsCreateManyInput = {
    player_id: number
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_inboxitemsUpdateManyMutationInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_inboxitemsUncheckedUpdateManyInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_namelocksCreateInput = {
    reason: string
    namelocked_at: bigint | number
    players_player_namelocks_player_idToplayers: PlayerCreateNestedOneWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput
    players_player_namelocks_namelocked_byToplayers: PlayerCreateNestedOneWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput
  }

  export type player_namelocksUncheckedCreateInput = {
    player_id: number
    reason: string
    namelocked_at: bigint | number
    namelocked_by: number
  }

  export type player_namelocksUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    namelocked_at?: BigIntFieldUpdateOperationsInput | bigint | number
    players_player_namelocks_player_idToplayers?: PlayerUpdateOneRequiredWithoutPlayer_namelocks_player_namelocks_player_idToplayersNestedInput
    players_player_namelocks_namelocked_byToplayers?: PlayerUpdateOneRequiredWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersNestedInput
  }

  export type player_namelocksUncheckedUpdateInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    namelocked_at?: BigIntFieldUpdateOperationsInput | bigint | number
    namelocked_by?: IntFieldUpdateOperationsInput | number
  }

  export type player_namelocksCreateManyInput = {
    player_id: number
    reason: string
    namelocked_at: bigint | number
    namelocked_by: number
  }

  export type player_namelocksUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    namelocked_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type player_namelocksUncheckedUpdateManyInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    namelocked_at?: BigIntFieldUpdateOperationsInput | bigint | number
    namelocked_by?: IntFieldUpdateOperationsInput | number
  }

  export type player_storageCreateInput = {
    key?: number
    value?: number
    players?: PlayerCreateNestedOneWithoutPlayer_storageInput
  }

  export type player_storageUncheckedCreateInput = {
    player_id?: number
    key?: number
    value?: number
  }

  export type player_storageUpdateInput = {
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
    players?: PlayerUpdateOneRequiredWithoutPlayer_storageNestedInput
  }

  export type player_storageUncheckedUpdateInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type player_storageCreateManyInput = {
    player_id?: number
    key?: number
    value?: number
  }

  export type player_storageUpdateManyMutationInput = {
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type player_storageUncheckedUpdateManyInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type player_storeinboxitemsCreateInput = {
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
    players: PlayerCreateNestedOneWithoutPlayer_storeinboxitemsInput
  }

  export type player_storeinboxitemsUncheckedCreateInput = {
    player_id: number
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_storeinboxitemsUpdateInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
    players?: PlayerUpdateOneRequiredWithoutPlayer_storeinboxitemsNestedInput
  }

  export type player_storeinboxitemsUncheckedUpdateInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_storeinboxitemsCreateManyInput = {
    player_id: number
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_storeinboxitemsUpdateManyMutationInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_storeinboxitemsUncheckedUpdateManyInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type players_onlineCreateInput = {
    player_id: number
  }

  export type players_onlineUncheckedCreateInput = {
    player_id: number
  }

  export type players_onlineUpdateInput = {
    player_id?: IntFieldUpdateOperationsInput | number
  }

  export type players_onlineUncheckedUpdateInput = {
    player_id?: IntFieldUpdateOperationsInput | number
  }

  export type players_onlineCreateManyInput = {
    player_id: number
  }

  export type players_onlineUpdateManyMutationInput = {
    player_id?: IntFieldUpdateOperationsInput | number
  }

  export type players_onlineUncheckedUpdateManyInput = {
    player_id?: IntFieldUpdateOperationsInput | number
  }

  export type server_configCreateInput = {
    config: string
    value?: string
  }

  export type server_configUncheckedCreateInput = {
    config: string
    value?: string
  }

  export type server_configUpdateInput = {
    config?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type server_configUncheckedUpdateInput = {
    config?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type server_configCreateManyInput = {
    config: string
    value?: string
  }

  export type server_configUpdateManyMutationInput = {
    config?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type server_configUncheckedUpdateManyInput = {
    config?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type shop_historyCreateInput = {
    account: number
    player: number
    date: Date | string
    title: string
    cost: number
    details: string
  }

  export type shop_historyUncheckedCreateInput = {
    id?: number
    account: number
    player: number
    date: Date | string
    title: string
    cost: number
    details: string
  }

  export type shop_historyUpdateInput = {
    account?: IntFieldUpdateOperationsInput | number
    player?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
  }

  export type shop_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    account?: IntFieldUpdateOperationsInput | number
    player?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
  }

  export type shop_historyCreateManyInput = {
    id?: number
    account: number
    player: number
    date: Date | string
    title: string
    cost: number
    details: string
  }

  export type shop_historyUpdateManyMutationInput = {
    account?: IntFieldUpdateOperationsInput | number
    player?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
  }

  export type shop_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    account?: IntFieldUpdateOperationsInput | number
    player?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    cost?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
  }

  export type townsCreateInput = {
    name: string
    posx?: number
    posy?: number
    posz?: number
  }

  export type townsUncheckedCreateInput = {
    id?: number
    name: string
    posx?: number
    posy?: number
    posz?: number
  }

  export type townsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
  }

  export type townsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
  }

  export type townsCreateManyInput = {
    id?: number
    name: string
    posx?: number
    posy?: number
    posz?: number
  }

  export type townsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
  }

  export type townsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
  }

  export type znoteCreateInput = {
    version: string
    installed: number
    cached?: number | null
  }

  export type znoteUncheckedCreateInput = {
    id?: number
    version: string
    installed: number
    cached?: number | null
  }

  export type znoteUpdateInput = {
    version?: StringFieldUpdateOperationsInput | string
    installed?: IntFieldUpdateOperationsInput | number
    cached?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type znoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    installed?: IntFieldUpdateOperationsInput | number
    cached?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type znoteCreateManyInput = {
    id?: number
    version: string
    installed: number
    cached?: number | null
  }

  export type znoteUpdateManyMutationInput = {
    version?: StringFieldUpdateOperationsInput | string
    installed?: IntFieldUpdateOperationsInput | number
    cached?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type znoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    version?: StringFieldUpdateOperationsInput | string
    installed?: IntFieldUpdateOperationsInput | number
    cached?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type znote_accountsCreateInput = {
    account_id: number
    ip: bigint | number
    created: number
    points?: number | null
    cooldown?: number | null
    active?: number
    active_email?: number
    activekey?: number
    flag: string
    secret?: string | null
  }

  export type znote_accountsUncheckedCreateInput = {
    id?: number
    account_id: number
    ip: bigint | number
    created: number
    points?: number | null
    cooldown?: number | null
    active?: number
    active_email?: number
    activekey?: number
    flag: string
    secret?: string | null
  }

  export type znote_accountsUpdateInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    created?: IntFieldUpdateOperationsInput | number
    points?: NullableIntFieldUpdateOperationsInput | number | null
    cooldown?: NullableIntFieldUpdateOperationsInput | number | null
    active?: IntFieldUpdateOperationsInput | number
    active_email?: IntFieldUpdateOperationsInput | number
    activekey?: IntFieldUpdateOperationsInput | number
    flag?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type znote_accountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    created?: IntFieldUpdateOperationsInput | number
    points?: NullableIntFieldUpdateOperationsInput | number | null
    cooldown?: NullableIntFieldUpdateOperationsInput | number | null
    active?: IntFieldUpdateOperationsInput | number
    active_email?: IntFieldUpdateOperationsInput | number
    activekey?: IntFieldUpdateOperationsInput | number
    flag?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type znote_accountsCreateManyInput = {
    id?: number
    account_id: number
    ip: bigint | number
    created: number
    points?: number | null
    cooldown?: number | null
    active?: number
    active_email?: number
    activekey?: number
    flag: string
    secret?: string | null
  }

  export type znote_accountsUpdateManyMutationInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    created?: IntFieldUpdateOperationsInput | number
    points?: NullableIntFieldUpdateOperationsInput | number | null
    cooldown?: NullableIntFieldUpdateOperationsInput | number | null
    active?: IntFieldUpdateOperationsInput | number
    active_email?: IntFieldUpdateOperationsInput | number
    activekey?: IntFieldUpdateOperationsInput | number
    flag?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type znote_accountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    created?: IntFieldUpdateOperationsInput | number
    points?: NullableIntFieldUpdateOperationsInput | number | null
    cooldown?: NullableIntFieldUpdateOperationsInput | number | null
    active?: IntFieldUpdateOperationsInput | number
    active_email?: IntFieldUpdateOperationsInput | number
    activekey?: IntFieldUpdateOperationsInput | number
    flag?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type znote_auction_playerCreateInput = {
    player_id: number
    original_account_id: number
    bidder_account_id: number
    time_begin: number
    time_end: number
    price: number
    bid: number
    deposit: number
    sold: number
    claimed: number
  }

  export type znote_auction_playerUncheckedCreateInput = {
    id?: number
    player_id: number
    original_account_id: number
    bidder_account_id: number
    time_begin: number
    time_end: number
    price: number
    bid: number
    deposit: number
    sold: number
    claimed: number
  }

  export type znote_auction_playerUpdateInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    original_account_id?: IntFieldUpdateOperationsInput | number
    bidder_account_id?: IntFieldUpdateOperationsInput | number
    time_begin?: IntFieldUpdateOperationsInput | number
    time_end?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    bid?: IntFieldUpdateOperationsInput | number
    deposit?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    claimed?: IntFieldUpdateOperationsInput | number
  }

  export type znote_auction_playerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    original_account_id?: IntFieldUpdateOperationsInput | number
    bidder_account_id?: IntFieldUpdateOperationsInput | number
    time_begin?: IntFieldUpdateOperationsInput | number
    time_end?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    bid?: IntFieldUpdateOperationsInput | number
    deposit?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    claimed?: IntFieldUpdateOperationsInput | number
  }

  export type znote_auction_playerCreateManyInput = {
    id?: number
    player_id: number
    original_account_id: number
    bidder_account_id: number
    time_begin: number
    time_end: number
    price: number
    bid: number
    deposit: number
    sold: number
    claimed: number
  }

  export type znote_auction_playerUpdateManyMutationInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    original_account_id?: IntFieldUpdateOperationsInput | number
    bidder_account_id?: IntFieldUpdateOperationsInput | number
    time_begin?: IntFieldUpdateOperationsInput | number
    time_end?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    bid?: IntFieldUpdateOperationsInput | number
    deposit?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    claimed?: IntFieldUpdateOperationsInput | number
  }

  export type znote_auction_playerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    original_account_id?: IntFieldUpdateOperationsInput | number
    bidder_account_id?: IntFieldUpdateOperationsInput | number
    time_begin?: IntFieldUpdateOperationsInput | number
    time_end?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    bid?: IntFieldUpdateOperationsInput | number
    deposit?: IntFieldUpdateOperationsInput | number
    sold?: IntFieldUpdateOperationsInput | number
    claimed?: IntFieldUpdateOperationsInput | number
  }

  export type znote_changelogCreateInput = {
    text: string
    time: number
    report_id: number
    status?: number
  }

  export type znote_changelogUncheckedCreateInput = {
    id?: number
    text: string
    time: number
    report_id: number
    status?: number
  }

  export type znote_changelogUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
    report_id?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type znote_changelogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
    report_id?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type znote_changelogCreateManyInput = {
    id?: number
    text: string
    time: number
    report_id: number
    status?: number
  }

  export type znote_changelogUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
    report_id?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type znote_changelogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    time?: IntFieldUpdateOperationsInput | number
    report_id?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type znote_deleted_charactersCreateInput = {
    original_account_id: number
    character_name: string
    time: Date | string
    done: number
  }

  export type znote_deleted_charactersUncheckedCreateInput = {
    id?: number
    original_account_id: number
    character_name: string
    time: Date | string
    done: number
  }

  export type znote_deleted_charactersUpdateInput = {
    original_account_id?: IntFieldUpdateOperationsInput | number
    character_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    done?: IntFieldUpdateOperationsInput | number
  }

  export type znote_deleted_charactersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    original_account_id?: IntFieldUpdateOperationsInput | number
    character_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    done?: IntFieldUpdateOperationsInput | number
  }

  export type znote_deleted_charactersCreateManyInput = {
    id?: number
    original_account_id: number
    character_name: string
    time: Date | string
    done: number
  }

  export type znote_deleted_charactersUpdateManyMutationInput = {
    original_account_id?: IntFieldUpdateOperationsInput | number
    character_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    done?: IntFieldUpdateOperationsInput | number
  }

  export type znote_deleted_charactersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    original_account_id?: IntFieldUpdateOperationsInput | number
    character_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    done?: IntFieldUpdateOperationsInput | number
  }

  export type znote_forumCreateInput = {
    name: string
    access: number
    closed: number
    hidden: number
    guild_id: number
  }

  export type znote_forumUncheckedCreateInput = {
    id?: number
    name: string
    access: number
    closed: number
    hidden: number
    guild_id: number
  }

  export type znote_forumUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    access?: IntFieldUpdateOperationsInput | number
    closed?: IntFieldUpdateOperationsInput | number
    hidden?: IntFieldUpdateOperationsInput | number
    guild_id?: IntFieldUpdateOperationsInput | number
  }

  export type znote_forumUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    access?: IntFieldUpdateOperationsInput | number
    closed?: IntFieldUpdateOperationsInput | number
    hidden?: IntFieldUpdateOperationsInput | number
    guild_id?: IntFieldUpdateOperationsInput | number
  }

  export type znote_forumCreateManyInput = {
    id?: number
    name: string
    access: number
    closed: number
    hidden: number
    guild_id: number
  }

  export type znote_forumUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    access?: IntFieldUpdateOperationsInput | number
    closed?: IntFieldUpdateOperationsInput | number
    hidden?: IntFieldUpdateOperationsInput | number
    guild_id?: IntFieldUpdateOperationsInput | number
  }

  export type znote_forumUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    access?: IntFieldUpdateOperationsInput | number
    closed?: IntFieldUpdateOperationsInput | number
    hidden?: IntFieldUpdateOperationsInput | number
    guild_id?: IntFieldUpdateOperationsInput | number
  }

  export type znote_forum_postsCreateInput = {
    thread_id: number
    player_id: number
    player_name: string
    text: string
    created: number
    updated: number
  }

  export type znote_forum_postsUncheckedCreateInput = {
    id?: number
    thread_id: number
    player_id: number
    player_name: string
    text: string
    created: number
    updated: number
  }

  export type znote_forum_postsUpdateInput = {
    thread_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    player_name?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created?: IntFieldUpdateOperationsInput | number
    updated?: IntFieldUpdateOperationsInput | number
  }

  export type znote_forum_postsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    thread_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    player_name?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created?: IntFieldUpdateOperationsInput | number
    updated?: IntFieldUpdateOperationsInput | number
  }

  export type znote_forum_postsCreateManyInput = {
    id?: number
    thread_id: number
    player_id: number
    player_name: string
    text: string
    created: number
    updated: number
  }

  export type znote_forum_postsUpdateManyMutationInput = {
    thread_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    player_name?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created?: IntFieldUpdateOperationsInput | number
    updated?: IntFieldUpdateOperationsInput | number
  }

  export type znote_forum_postsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    thread_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    player_name?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created?: IntFieldUpdateOperationsInput | number
    updated?: IntFieldUpdateOperationsInput | number
  }

  export type znote_forum_threadsCreateInput = {
    forum_id: number
    player_id: number
    player_name: string
    title: string
    text: string
    created: number
    updated: number
    sticky: number
    hidden: number
    closed: number
  }

  export type znote_forum_threadsUncheckedCreateInput = {
    id?: number
    forum_id: number
    player_id: number
    player_name: string
    title: string
    text: string
    created: number
    updated: number
    sticky: number
    hidden: number
    closed: number
  }

  export type znote_forum_threadsUpdateInput = {
    forum_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    player_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created?: IntFieldUpdateOperationsInput | number
    updated?: IntFieldUpdateOperationsInput | number
    sticky?: IntFieldUpdateOperationsInput | number
    hidden?: IntFieldUpdateOperationsInput | number
    closed?: IntFieldUpdateOperationsInput | number
  }

  export type znote_forum_threadsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    forum_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    player_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created?: IntFieldUpdateOperationsInput | number
    updated?: IntFieldUpdateOperationsInput | number
    sticky?: IntFieldUpdateOperationsInput | number
    hidden?: IntFieldUpdateOperationsInput | number
    closed?: IntFieldUpdateOperationsInput | number
  }

  export type znote_forum_threadsCreateManyInput = {
    id?: number
    forum_id: number
    player_id: number
    player_name: string
    title: string
    text: string
    created: number
    updated: number
    sticky: number
    hidden: number
    closed: number
  }

  export type znote_forum_threadsUpdateManyMutationInput = {
    forum_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    player_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created?: IntFieldUpdateOperationsInput | number
    updated?: IntFieldUpdateOperationsInput | number
    sticky?: IntFieldUpdateOperationsInput | number
    hidden?: IntFieldUpdateOperationsInput | number
    closed?: IntFieldUpdateOperationsInput | number
  }

  export type znote_forum_threadsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    forum_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    player_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    created?: IntFieldUpdateOperationsInput | number
    updated?: IntFieldUpdateOperationsInput | number
    sticky?: IntFieldUpdateOperationsInput | number
    hidden?: IntFieldUpdateOperationsInput | number
    closed?: IntFieldUpdateOperationsInput | number
  }

  export type znote_global_storageCreateInput = {
    key: string
    value: string
  }

  export type znote_global_storageUncheckedCreateInput = {
    key: string
    value: string
  }

  export type znote_global_storageUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type znote_global_storageUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type znote_global_storageCreateManyInput = {
    key: string
    value: string
  }

  export type znote_global_storageUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type znote_global_storageUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type znote_guild_warsCreateInput = {
    limit?: number
  }

  export type znote_guild_warsUncheckedCreateInput = {
    id?: number
    limit?: number
  }

  export type znote_guild_warsUpdateInput = {
    limit?: IntFieldUpdateOperationsInput | number
  }

  export type znote_guild_warsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    limit?: IntFieldUpdateOperationsInput | number
  }

  export type znote_guild_warsCreateManyInput = {
    id?: number
    limit?: number
  }

  export type znote_guild_warsUpdateManyMutationInput = {
    limit?: IntFieldUpdateOperationsInput | number
  }

  export type znote_guild_warsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    limit?: IntFieldUpdateOperationsInput | number
  }

  export type znote_imagesCreateInput = {
    title: string
    desc: string
    date: number
    status: number
    image: string
    delhash: string
    account_id: number
  }

  export type znote_imagesUncheckedCreateInput = {
    id?: number
    title: string
    desc: string
    date: number
    status: number
    image: string
    delhash: string
    account_id: number
  }

  export type znote_imagesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    delhash?: StringFieldUpdateOperationsInput | string
    account_id?: IntFieldUpdateOperationsInput | number
  }

  export type znote_imagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    delhash?: StringFieldUpdateOperationsInput | string
    account_id?: IntFieldUpdateOperationsInput | number
  }

  export type znote_imagesCreateManyInput = {
    id?: number
    title: string
    desc: string
    date: number
    status: number
    image: string
    delhash: string
    account_id: number
  }

  export type znote_imagesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    delhash?: StringFieldUpdateOperationsInput | string
    account_id?: IntFieldUpdateOperationsInput | number
  }

  export type znote_imagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    desc?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    image?: StringFieldUpdateOperationsInput | string
    delhash?: StringFieldUpdateOperationsInput | string
    account_id?: IntFieldUpdateOperationsInput | number
  }

  export type znote_newsCreateInput = {
    title: string
    text: string
    date: number
    pid: number
  }

  export type znote_newsUncheckedCreateInput = {
    id?: number
    title: string
    text: string
    date: number
    pid: number
  }

  export type znote_newsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
  }

  export type znote_newsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
  }

  export type znote_newsCreateManyInput = {
    id?: number
    title: string
    text: string
    date: number
    pid: number
  }

  export type znote_newsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
  }

  export type znote_newsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
  }

  export type znote_paygolCreateInput = {
    account_id: number
    price: number
    points: number
    message_id: string
    service_id: string
    shortcode: string
    keyword: string
    message: string
    sender: string
    operator: string
    country: string
    currency: string
  }

  export type znote_paygolUncheckedCreateInput = {
    id?: number
    account_id: number
    price: number
    points: number
    message_id: string
    service_id: string
    shortcode: string
    keyword: string
    message: string
    sender: string
    operator: string
    country: string
    currency: string
  }

  export type znote_paygolUpdateInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    message_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    shortcode?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type znote_paygolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    message_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    shortcode?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type znote_paygolCreateManyInput = {
    id?: number
    account_id: number
    price: number
    points: number
    message_id: string
    service_id: string
    shortcode: string
    keyword: string
    message: string
    sender: string
    operator: string
    country: string
    currency: string
  }

  export type znote_paygolUpdateManyMutationInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    message_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    shortcode?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type znote_paygolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    message_id?: StringFieldUpdateOperationsInput | string
    service_id?: StringFieldUpdateOperationsInput | string
    shortcode?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    operator?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type znote_paypalCreateInput = {
    txn_id: string
    email: string
    accid: number
    price: number
    points: number
  }

  export type znote_paypalUncheckedCreateInput = {
    id?: number
    txn_id: string
    email: string
    accid: number
    price: number
    points: number
  }

  export type znote_paypalUpdateInput = {
    txn_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accid?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type znote_paypalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    txn_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accid?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type znote_paypalCreateManyInput = {
    id?: number
    txn_id: string
    email: string
    accid: number
    price: number
    points: number
  }

  export type znote_paypalUpdateManyMutationInput = {
    txn_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accid?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type znote_paypalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    txn_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    accid?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type znote_player_reportsCreateInput = {
    name: string
    posx: number
    posy: number
    posz: number
    report_description: string
    date: number
    status?: number
  }

  export type znote_player_reportsUncheckedCreateInput = {
    id?: number
    name: string
    posx: number
    posy: number
    posz: number
    report_description: string
    date: number
    status?: number
  }

  export type znote_player_reportsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    report_description?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type znote_player_reportsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    report_description?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type znote_player_reportsCreateManyInput = {
    id?: number
    name: string
    posx: number
    posy: number
    posz: number
    report_description: string
    date: number
    status?: number
  }

  export type znote_player_reportsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    report_description?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type znote_player_reportsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    report_description?: StringFieldUpdateOperationsInput | string
    date?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
  }

  export type znote_playersCreateInput = {
    player_id: number
    created: number
    hide_char: number
    comment: string
  }

  export type znote_playersUncheckedCreateInput = {
    id?: number
    player_id: number
    created: number
    hide_char: number
    comment: string
  }

  export type znote_playersUpdateInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    created?: IntFieldUpdateOperationsInput | number
    hide_char?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type znote_playersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    created?: IntFieldUpdateOperationsInput | number
    hide_char?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type znote_playersCreateManyInput = {
    id?: number
    player_id: number
    created: number
    hide_char: number
    comment: string
  }

  export type znote_playersUpdateManyMutationInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    created?: IntFieldUpdateOperationsInput | number
    hide_char?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type znote_playersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    created?: IntFieldUpdateOperationsInput | number
    hide_char?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
  }

  export type znote_shopCreateInput = {
    type: number
    itemid?: number | null
    count?: number
    description: string
    points?: number
  }

  export type znote_shopUncheckedCreateInput = {
    id?: number
    type: number
    itemid?: number | null
    count?: number
    description: string
    points?: number
  }

  export type znote_shopUpdateInput = {
    type?: IntFieldUpdateOperationsInput | number
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type znote_shopUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type znote_shopCreateManyInput = {
    id?: number
    type: number
    itemid?: number | null
    count?: number
    description: string
    points?: number
  }

  export type znote_shopUpdateManyMutationInput = {
    type?: IntFieldUpdateOperationsInput | number
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type znote_shopUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    itemid?: NullableIntFieldUpdateOperationsInput | number | null
    count?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
  }

  export type znote_shop_logsCreateInput = {
    account_id: number
    player_id: number
    type: number
    itemid: number
    count: number
    points: number
    time: number
  }

  export type znote_shop_logsUncheckedCreateInput = {
    id?: number
    account_id: number
    player_id: number
    type: number
    itemid: number
    count: number
    points: number
    time: number
  }

  export type znote_shop_logsUpdateInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type znote_shop_logsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type znote_shop_logsCreateManyInput = {
    id?: number
    account_id: number
    player_id: number
    type: number
    itemid: number
    count: number
    points: number
    time: number
  }

  export type znote_shop_logsUpdateManyMutationInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type znote_shop_logsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type znote_shop_ordersCreateInput = {
    account_id: number
    type: number
    itemid: number
    count: number
    time?: number
  }

  export type znote_shop_ordersUncheckedCreateInput = {
    id?: number
    account_id: number
    type: number
    itemid: number
    count: number
    time?: number
  }

  export type znote_shop_ordersUpdateInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type znote_shop_ordersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type znote_shop_ordersCreateManyInput = {
    id?: number
    account_id: number
    type: number
    itemid: number
    count: number
    time?: number
  }

  export type znote_shop_ordersUpdateManyMutationInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type znote_shop_ordersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    itemid?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    time?: IntFieldUpdateOperationsInput | number
  }

  export type znote_ticketsCreateInput = {
    owner: number
    username: string
    subject: string
    message: string
    ip: bigint | number
    creation: number
    status: string
  }

  export type znote_ticketsUncheckedCreateInput = {
    id?: number
    owner: number
    username: string
    subject: string
    message: string
    ip: bigint | number
    creation: number
    status: string
  }

  export type znote_ticketsUpdateInput = {
    owner?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    creation?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type znote_ticketsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    owner?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    creation?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type znote_ticketsCreateManyInput = {
    id?: number
    owner: number
    username: string
    subject: string
    message: string
    ip: bigint | number
    creation: number
    status: string
  }

  export type znote_ticketsUpdateManyMutationInput = {
    owner?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    creation?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type znote_ticketsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    owner?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    creation?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type znote_tickets_repliesCreateInput = {
    tid: number
    username: string
    message: string
    created: number
  }

  export type znote_tickets_repliesUncheckedCreateInput = {
    id?: number
    tid: number
    username: string
    message: string
    created: number
  }

  export type znote_tickets_repliesUpdateInput = {
    tid?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: IntFieldUpdateOperationsInput | number
  }

  export type znote_tickets_repliesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tid?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: IntFieldUpdateOperationsInput | number
  }

  export type znote_tickets_repliesCreateManyInput = {
    id?: number
    tid: number
    username: string
    message: string
    created: number
  }

  export type znote_tickets_repliesUpdateManyMutationInput = {
    tid?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: IntFieldUpdateOperationsInput | number
  }

  export type znote_tickets_repliesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tid?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created?: IntFieldUpdateOperationsInput | number
  }

  export type znote_visitorsCreateInput = {
    ip: bigint | number
    value: number
  }

  export type znote_visitorsUncheckedCreateInput = {
    id?: number
    ip: bigint | number
    value: number
  }

  export type znote_visitorsUpdateInput = {
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type znote_visitorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type znote_visitorsCreateManyInput = {
    id?: number
    ip: bigint | number
    value: number
  }

  export type znote_visitorsUpdateManyMutationInput = {
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type znote_visitorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type znote_visitors_detailsCreateInput = {
    ip: bigint | number
    time: number
    type: number
    account_id: number
  }

  export type znote_visitors_detailsUncheckedCreateInput = {
    id?: number
    ip: bigint | number
    time: number
    type: number
    account_id: number
  }

  export type znote_visitors_detailsUpdateInput = {
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    time?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
  }

  export type znote_visitors_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    time?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
  }

  export type znote_visitors_detailsCreateManyInput = {
    id?: number
    ip: bigint | number
    time: number
    type: number
    account_id: number
  }

  export type znote_visitors_detailsUpdateManyMutationInput = {
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    time?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
  }

  export type znote_visitors_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: BigIntFieldUpdateOperationsInput | bigint | number
    time?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type Account_ban_historyListRelationFilter = {
    every?: account_ban_historyWhereInput
    some?: account_ban_historyWhereInput
    none?: account_ban_historyWhereInput
  }

  export type Account_bansRelationFilter = {
    is?: account_bansWhereInput | null
    isNot?: account_bansWhereInput | null
  }

  export type Account_storageListRelationFilter = {
    every?: account_storageWhereInput
    some?: account_storageWhereInput
    none?: account_storageWhereInput
  }

  export type Account_viplistListRelationFilter = {
    every?: account_viplistWhereInput
    some?: account_viplistWhereInput
    none?: account_viplistWhereInput
  }

  export type PlayerListRelationFilter = {
    every?: PlayerWhereInput
    some?: PlayerWhereInput
    none?: PlayerWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type account_ban_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type account_storageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type account_viplistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    secret?: SortOrder
    type?: SortOrder
    premium_ends_at?: SortOrder
    email?: SortOrder
    creation?: SortOrder
    premium_points?: SortOrder
    premdays?: SortOrder
    wallet?: SortOrder
    alpha_key?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    premium_ends_at?: SortOrder
    creation?: SortOrder
    premium_points?: SortOrder
    premdays?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    secret?: SortOrder
    type?: SortOrder
    premium_ends_at?: SortOrder
    email?: SortOrder
    creation?: SortOrder
    premium_points?: SortOrder
    premdays?: SortOrder
    wallet?: SortOrder
    alpha_key?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    secret?: SortOrder
    type?: SortOrder
    premium_ends_at?: SortOrder
    email?: SortOrder
    creation?: SortOrder
    premium_points?: SortOrder
    premdays?: SortOrder
    wallet?: SortOrder
    alpha_key?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    premium_ends_at?: SortOrder
    creation?: SortOrder
    premium_points?: SortOrder
    premdays?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type BytesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer> | Buffer
    notIn?: Enumerable<Buffer> | Buffer
    not?: NestedBytesFilter | Buffer
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type Account_bansListRelationFilter = {
    every?: account_bansWhereInput
    some?: account_bansWhereInput
    none?: account_bansWhereInput
  }

  export type Guild_invitesListRelationFilter = {
    every?: guild_invitesWhereInput
    some?: guild_invitesWhereInput
    none?: guild_invitesWhereInput
  }

  export type Guild_membershipRelationFilter = {
    is?: guild_membershipWhereInput | null
    isNot?: guild_membershipWhereInput | null
  }

  export type GuildsRelationFilter = {
    is?: guildsWhereInput | null
    isNot?: guildsWhereInput | null
  }

  export type Ip_bansListRelationFilter = {
    every?: ip_bansWhereInput
    some?: ip_bansWhereInput
    none?: ip_bansWhereInput
  }

  export type Market_historyListRelationFilter = {
    every?: market_historyWhereInput
    some?: market_historyWhereInput
    none?: market_historyWhereInput
  }

  export type Market_offersListRelationFilter = {
    every?: market_offersWhereInput
    some?: market_offersWhereInput
    none?: market_offersWhereInput
  }

  export type Player_depotitemsListRelationFilter = {
    every?: player_depotitemsWhereInput
    some?: player_depotitemsWhereInput
    none?: player_depotitemsWhereInput
  }

  export type Player_inboxitemsListRelationFilter = {
    every?: player_inboxitemsWhereInput
    some?: player_inboxitemsWhereInput
    none?: player_inboxitemsWhereInput
  }

  export type Player_namelocksRelationFilter = {
    is?: player_namelocksWhereInput | null
    isNot?: player_namelocksWhereInput | null
  }

  export type Player_namelocksListRelationFilter = {
    every?: player_namelocksWhereInput
    some?: player_namelocksWhereInput
    none?: player_namelocksWhereInput
  }

  export type Player_storageListRelationFilter = {
    every?: player_storageWhereInput
    some?: player_storageWhereInput
    none?: player_storageWhereInput
  }

  export type Player_storeinboxitemsListRelationFilter = {
    every?: player_storeinboxitemsWhereInput
    some?: player_storeinboxitemsWhereInput
    none?: player_storeinboxitemsWhereInput
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type account_bansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type guild_invitesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ip_bansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type market_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type market_offersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type player_depotitemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type player_inboxitemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type player_namelocksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type player_storageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type player_storeinboxitemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    group_id?: SortOrder
    account_id?: SortOrder
    level?: SortOrder
    vocation?: SortOrder
    health?: SortOrder
    healthmax?: SortOrder
    experience?: SortOrder
    lookbody?: SortOrder
    lookfeet?: SortOrder
    lookhead?: SortOrder
    looklegs?: SortOrder
    looktype?: SortOrder
    lookaddons?: SortOrder
    direction?: SortOrder
    maglevel?: SortOrder
    mana?: SortOrder
    manamax?: SortOrder
    manaspent?: SortOrder
    soul?: SortOrder
    town_id?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    conditions?: SortOrder
    cap?: SortOrder
    sex?: SortOrder
    lastlogin?: SortOrder
    lastip?: SortOrder
    save?: SortOrder
    skull?: SortOrder
    skulltime?: SortOrder
    lastlogout?: SortOrder
    blessings?: SortOrder
    onlinetime?: SortOrder
    deletion?: SortOrder
    balance?: SortOrder
    offlinetraining_time?: SortOrder
    offlinetraining_skill?: SortOrder
    stamina?: SortOrder
    skill_fist?: SortOrder
    skill_fist_tries?: SortOrder
    skill_club?: SortOrder
    skill_club_tries?: SortOrder
    skill_sword?: SortOrder
    skill_sword_tries?: SortOrder
    skill_axe?: SortOrder
    skill_axe_tries?: SortOrder
    skill_dist?: SortOrder
    skill_dist_tries?: SortOrder
    skill_shielding?: SortOrder
    skill_shielding_tries?: SortOrder
    skill_fishing?: SortOrder
    skill_fishing_tries?: SortOrder
    stat_str?: SortOrder
    stat_int?: SortOrder
    stat_dex?: SortOrder
    stat_vit?: SortOrder
    stat_spr?: SortOrder
    stat_wis?: SortOrder
  }

  export type PlayerAvgOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    account_id?: SortOrder
    level?: SortOrder
    vocation?: SortOrder
    health?: SortOrder
    healthmax?: SortOrder
    experience?: SortOrder
    lookbody?: SortOrder
    lookfeet?: SortOrder
    lookhead?: SortOrder
    looklegs?: SortOrder
    looktype?: SortOrder
    lookaddons?: SortOrder
    direction?: SortOrder
    maglevel?: SortOrder
    mana?: SortOrder
    manamax?: SortOrder
    manaspent?: SortOrder
    soul?: SortOrder
    town_id?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    cap?: SortOrder
    sex?: SortOrder
    lastlogin?: SortOrder
    lastip?: SortOrder
    skulltime?: SortOrder
    lastlogout?: SortOrder
    blessings?: SortOrder
    onlinetime?: SortOrder
    deletion?: SortOrder
    balance?: SortOrder
    offlinetraining_time?: SortOrder
    offlinetraining_skill?: SortOrder
    stamina?: SortOrder
    skill_fist?: SortOrder
    skill_fist_tries?: SortOrder
    skill_club?: SortOrder
    skill_club_tries?: SortOrder
    skill_sword?: SortOrder
    skill_sword_tries?: SortOrder
    skill_axe?: SortOrder
    skill_axe_tries?: SortOrder
    skill_dist?: SortOrder
    skill_dist_tries?: SortOrder
    skill_shielding?: SortOrder
    skill_shielding_tries?: SortOrder
    skill_fishing?: SortOrder
    skill_fishing_tries?: SortOrder
    stat_str?: SortOrder
    stat_int?: SortOrder
    stat_dex?: SortOrder
    stat_vit?: SortOrder
    stat_spr?: SortOrder
    stat_wis?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    group_id?: SortOrder
    account_id?: SortOrder
    level?: SortOrder
    vocation?: SortOrder
    health?: SortOrder
    healthmax?: SortOrder
    experience?: SortOrder
    lookbody?: SortOrder
    lookfeet?: SortOrder
    lookhead?: SortOrder
    looklegs?: SortOrder
    looktype?: SortOrder
    lookaddons?: SortOrder
    direction?: SortOrder
    maglevel?: SortOrder
    mana?: SortOrder
    manamax?: SortOrder
    manaspent?: SortOrder
    soul?: SortOrder
    town_id?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    conditions?: SortOrder
    cap?: SortOrder
    sex?: SortOrder
    lastlogin?: SortOrder
    lastip?: SortOrder
    save?: SortOrder
    skull?: SortOrder
    skulltime?: SortOrder
    lastlogout?: SortOrder
    blessings?: SortOrder
    onlinetime?: SortOrder
    deletion?: SortOrder
    balance?: SortOrder
    offlinetraining_time?: SortOrder
    offlinetraining_skill?: SortOrder
    stamina?: SortOrder
    skill_fist?: SortOrder
    skill_fist_tries?: SortOrder
    skill_club?: SortOrder
    skill_club_tries?: SortOrder
    skill_sword?: SortOrder
    skill_sword_tries?: SortOrder
    skill_axe?: SortOrder
    skill_axe_tries?: SortOrder
    skill_dist?: SortOrder
    skill_dist_tries?: SortOrder
    skill_shielding?: SortOrder
    skill_shielding_tries?: SortOrder
    skill_fishing?: SortOrder
    skill_fishing_tries?: SortOrder
    stat_str?: SortOrder
    stat_int?: SortOrder
    stat_dex?: SortOrder
    stat_vit?: SortOrder
    stat_spr?: SortOrder
    stat_wis?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    group_id?: SortOrder
    account_id?: SortOrder
    level?: SortOrder
    vocation?: SortOrder
    health?: SortOrder
    healthmax?: SortOrder
    experience?: SortOrder
    lookbody?: SortOrder
    lookfeet?: SortOrder
    lookhead?: SortOrder
    looklegs?: SortOrder
    looktype?: SortOrder
    lookaddons?: SortOrder
    direction?: SortOrder
    maglevel?: SortOrder
    mana?: SortOrder
    manamax?: SortOrder
    manaspent?: SortOrder
    soul?: SortOrder
    town_id?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    conditions?: SortOrder
    cap?: SortOrder
    sex?: SortOrder
    lastlogin?: SortOrder
    lastip?: SortOrder
    save?: SortOrder
    skull?: SortOrder
    skulltime?: SortOrder
    lastlogout?: SortOrder
    blessings?: SortOrder
    onlinetime?: SortOrder
    deletion?: SortOrder
    balance?: SortOrder
    offlinetraining_time?: SortOrder
    offlinetraining_skill?: SortOrder
    stamina?: SortOrder
    skill_fist?: SortOrder
    skill_fist_tries?: SortOrder
    skill_club?: SortOrder
    skill_club_tries?: SortOrder
    skill_sword?: SortOrder
    skill_sword_tries?: SortOrder
    skill_axe?: SortOrder
    skill_axe_tries?: SortOrder
    skill_dist?: SortOrder
    skill_dist_tries?: SortOrder
    skill_shielding?: SortOrder
    skill_shielding_tries?: SortOrder
    skill_fishing?: SortOrder
    skill_fishing_tries?: SortOrder
    stat_str?: SortOrder
    stat_int?: SortOrder
    stat_dex?: SortOrder
    stat_vit?: SortOrder
    stat_spr?: SortOrder
    stat_wis?: SortOrder
  }

  export type PlayerSumOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    account_id?: SortOrder
    level?: SortOrder
    vocation?: SortOrder
    health?: SortOrder
    healthmax?: SortOrder
    experience?: SortOrder
    lookbody?: SortOrder
    lookfeet?: SortOrder
    lookhead?: SortOrder
    looklegs?: SortOrder
    looktype?: SortOrder
    lookaddons?: SortOrder
    direction?: SortOrder
    maglevel?: SortOrder
    mana?: SortOrder
    manamax?: SortOrder
    manaspent?: SortOrder
    soul?: SortOrder
    town_id?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    cap?: SortOrder
    sex?: SortOrder
    lastlogin?: SortOrder
    lastip?: SortOrder
    skulltime?: SortOrder
    lastlogout?: SortOrder
    blessings?: SortOrder
    onlinetime?: SortOrder
    deletion?: SortOrder
    balance?: SortOrder
    offlinetraining_time?: SortOrder
    offlinetraining_skill?: SortOrder
    stamina?: SortOrder
    skill_fist?: SortOrder
    skill_fist_tries?: SortOrder
    skill_club?: SortOrder
    skill_club_tries?: SortOrder
    skill_sword?: SortOrder
    skill_sword_tries?: SortOrder
    skill_axe?: SortOrder
    skill_axe_tries?: SortOrder
    skill_dist?: SortOrder
    skill_dist_tries?: SortOrder
    skill_shielding?: SortOrder
    skill_shielding_tries?: SortOrder
    skill_fishing?: SortOrder
    skill_fishing_tries?: SortOrder
    stat_str?: SortOrder
    stat_int?: SortOrder
    stat_dex?: SortOrder
    stat_vit?: SortOrder
    stat_spr?: SortOrder
    stat_wis?: SortOrder
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type BytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer> | Buffer
    notIn?: Enumerable<Buffer> | Buffer
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type HouseCountOrderByAggregateInput = {
    id?: SortOrder
    owner?: SortOrder
    paid?: SortOrder
    warnings?: SortOrder
    name?: SortOrder
    rent?: SortOrder
    town_id?: SortOrder
    bid?: SortOrder
    bid_end?: SortOrder
    last_bid?: SortOrder
    highest_bidder?: SortOrder
    size?: SortOrder
    beds?: SortOrder
    land_zone?: SortOrder
    land_plot?: SortOrder
    bioma?: SortOrder
    land_size?: SortOrder
    plant?: SortOrder
    harvest?: SortOrder
    mining?: SortOrder
    livestock?: SortOrder
    fishing_boat?: SortOrder
    json_data?: SortOrder
    enable?: SortOrder
  }

  export type HouseAvgOrderByAggregateInput = {
    id?: SortOrder
    owner?: SortOrder
    paid?: SortOrder
    warnings?: SortOrder
    rent?: SortOrder
    town_id?: SortOrder
    bid?: SortOrder
    bid_end?: SortOrder
    last_bid?: SortOrder
    highest_bidder?: SortOrder
    size?: SortOrder
    beds?: SortOrder
  }

  export type HouseMaxOrderByAggregateInput = {
    id?: SortOrder
    owner?: SortOrder
    paid?: SortOrder
    warnings?: SortOrder
    name?: SortOrder
    rent?: SortOrder
    town_id?: SortOrder
    bid?: SortOrder
    bid_end?: SortOrder
    last_bid?: SortOrder
    highest_bidder?: SortOrder
    size?: SortOrder
    beds?: SortOrder
    land_zone?: SortOrder
    land_plot?: SortOrder
    bioma?: SortOrder
    land_size?: SortOrder
    plant?: SortOrder
    harvest?: SortOrder
    mining?: SortOrder
    livestock?: SortOrder
    fishing_boat?: SortOrder
    enable?: SortOrder
  }

  export type HouseMinOrderByAggregateInput = {
    id?: SortOrder
    owner?: SortOrder
    paid?: SortOrder
    warnings?: SortOrder
    name?: SortOrder
    rent?: SortOrder
    town_id?: SortOrder
    bid?: SortOrder
    bid_end?: SortOrder
    last_bid?: SortOrder
    highest_bidder?: SortOrder
    size?: SortOrder
    beds?: SortOrder
    land_zone?: SortOrder
    land_plot?: SortOrder
    bioma?: SortOrder
    land_size?: SortOrder
    plant?: SortOrder
    harvest?: SortOrder
    mining?: SortOrder
    livestock?: SortOrder
    fishing_boat?: SortOrder
    enable?: SortOrder
  }

  export type HouseSumOrderByAggregateInput = {
    id?: SortOrder
    owner?: SortOrder
    paid?: SortOrder
    warnings?: SortOrder
    rent?: SortOrder
    town_id?: SortOrder
    bid?: SortOrder
    bid_end?: SortOrder
    last_bid?: SortOrder
    highest_bidder?: SortOrder
    size?: SortOrder
    beds?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type PlayerRelationFilter = {
    is?: PlayerWhereInput | null
    isNot?: PlayerWhereInput | null
  }

  export type account_ban_historyCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expired_at?: SortOrder
    banned_by?: SortOrder
  }

  export type account_ban_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    banned_at?: SortOrder
    expired_at?: SortOrder
    banned_by?: SortOrder
  }

  export type account_ban_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expired_at?: SortOrder
    banned_by?: SortOrder
  }

  export type account_ban_historyMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expired_at?: SortOrder
    banned_by?: SortOrder
  }

  export type account_ban_historySumOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    banned_at?: SortOrder
    expired_at?: SortOrder
    banned_by?: SortOrder
  }

  export type account_bansCountOrderByAggregateInput = {
    account_id?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
  }

  export type account_bansAvgOrderByAggregateInput = {
    account_id?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
  }

  export type account_bansMaxOrderByAggregateInput = {
    account_id?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
  }

  export type account_bansMinOrderByAggregateInput = {
    account_id?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
  }

  export type account_bansSumOrderByAggregateInput = {
    account_id?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
  }

  export type account_storageAccount_idKeyCompoundUniqueInput = {
    account_id: number
    key: number
  }

  export type account_storageCountOrderByAggregateInput = {
    account_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type account_storageAvgOrderByAggregateInput = {
    account_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type account_storageMaxOrderByAggregateInput = {
    account_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type account_storageMinOrderByAggregateInput = {
    account_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type account_storageSumOrderByAggregateInput = {
    account_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type account_viplistAccount_idPlayer_idCompoundUniqueInput = {
    account_id: number
    player_id: number
  }

  export type account_viplistCountOrderByAggregateInput = {
    account_id?: SortOrder
    player_id?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    notify?: SortOrder
  }

  export type account_viplistAvgOrderByAggregateInput = {
    account_id?: SortOrder
    player_id?: SortOrder
    icon?: SortOrder
  }

  export type account_viplistMaxOrderByAggregateInput = {
    account_id?: SortOrder
    player_id?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    notify?: SortOrder
  }

  export type account_viplistMinOrderByAggregateInput = {
    account_id?: SortOrder
    player_id?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    notify?: SortOrder
  }

  export type account_viplistSumOrderByAggregateInput = {
    account_id?: SortOrder
    player_id?: SortOrder
    icon?: SortOrder
  }

  export type guild_invitesPlayer_idGuild_idCompoundUniqueInput = {
    player_id: number
    guild_id: number
  }

  export type guild_invitesCountOrderByAggregateInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
  }

  export type guild_invitesAvgOrderByAggregateInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
  }

  export type guild_invitesMaxOrderByAggregateInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
  }

  export type guild_invitesMinOrderByAggregateInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
  }

  export type guild_invitesSumOrderByAggregateInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
  }

  export type Guild_ranksRelationFilter = {
    is?: guild_ranksWhereInput | null
    isNot?: guild_ranksWhereInput | null
  }

  export type guild_membershipCountOrderByAggregateInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
    rank_id?: SortOrder
    nick?: SortOrder
  }

  export type guild_membershipAvgOrderByAggregateInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
    rank_id?: SortOrder
  }

  export type guild_membershipMaxOrderByAggregateInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
    rank_id?: SortOrder
    nick?: SortOrder
  }

  export type guild_membershipMinOrderByAggregateInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
    rank_id?: SortOrder
    nick?: SortOrder
  }

  export type guild_membershipSumOrderByAggregateInput = {
    player_id?: SortOrder
    guild_id?: SortOrder
    rank_id?: SortOrder
  }

  export type Guild_membershipListRelationFilter = {
    every?: guild_membershipWhereInput
    some?: guild_membershipWhereInput
    none?: guild_membershipWhereInput
  }

  export type guild_membershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type guild_ranksCountOrderByAggregateInput = {
    id?: SortOrder
    guild_id?: SortOrder
    name?: SortOrder
    level?: SortOrder
  }

  export type guild_ranksAvgOrderByAggregateInput = {
    id?: SortOrder
    guild_id?: SortOrder
    level?: SortOrder
  }

  export type guild_ranksMaxOrderByAggregateInput = {
    id?: SortOrder
    guild_id?: SortOrder
    name?: SortOrder
    level?: SortOrder
  }

  export type guild_ranksMinOrderByAggregateInput = {
    id?: SortOrder
    guild_id?: SortOrder
    name?: SortOrder
    level?: SortOrder
  }

  export type guild_ranksSumOrderByAggregateInput = {
    id?: SortOrder
    guild_id?: SortOrder
    level?: SortOrder
  }

  export type Guildwar_killsListRelationFilter = {
    every?: guildwar_killsWhereInput
    some?: guildwar_killsWhereInput
    none?: guildwar_killsWhereInput
  }

  export type guildwar_killsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type guild_warsCountOrderByAggregateInput = {
    id?: SortOrder
    guild1?: SortOrder
    guild2?: SortOrder
    name1?: SortOrder
    name2?: SortOrder
    status?: SortOrder
    started?: SortOrder
    ended?: SortOrder
  }

  export type guild_warsAvgOrderByAggregateInput = {
    id?: SortOrder
    guild1?: SortOrder
    guild2?: SortOrder
    status?: SortOrder
    started?: SortOrder
    ended?: SortOrder
  }

  export type guild_warsMaxOrderByAggregateInput = {
    id?: SortOrder
    guild1?: SortOrder
    guild2?: SortOrder
    name1?: SortOrder
    name2?: SortOrder
    status?: SortOrder
    started?: SortOrder
    ended?: SortOrder
  }

  export type guild_warsMinOrderByAggregateInput = {
    id?: SortOrder
    guild1?: SortOrder
    guild2?: SortOrder
    name1?: SortOrder
    name2?: SortOrder
    status?: SortOrder
    started?: SortOrder
    ended?: SortOrder
  }

  export type guild_warsSumOrderByAggregateInput = {
    id?: SortOrder
    guild1?: SortOrder
    guild2?: SortOrder
    status?: SortOrder
    started?: SortOrder
    ended?: SortOrder
  }

  export type Guild_ranksListRelationFilter = {
    every?: guild_ranksWhereInput
    some?: guild_ranksWhereInput
    none?: guild_ranksWhereInput
  }

  export type guild_ranksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type guildsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerid?: SortOrder
    creationdata?: SortOrder
    motd?: SortOrder
  }

  export type guildsAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerid?: SortOrder
    creationdata?: SortOrder
  }

  export type guildsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerid?: SortOrder
    creationdata?: SortOrder
    motd?: SortOrder
  }

  export type guildsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerid?: SortOrder
    creationdata?: SortOrder
    motd?: SortOrder
  }

  export type guildsSumOrderByAggregateInput = {
    id?: SortOrder
    ownerid?: SortOrder
    creationdata?: SortOrder
  }

  export type Guild_warsRelationFilter = {
    is?: guild_warsWhereInput | null
    isNot?: guild_warsWhereInput | null
  }

  export type guildwar_killsCountOrderByAggregateInput = {
    id?: SortOrder
    killer?: SortOrder
    target?: SortOrder
    killerguild?: SortOrder
    targetguild?: SortOrder
    warid?: SortOrder
    time?: SortOrder
  }

  export type guildwar_killsAvgOrderByAggregateInput = {
    id?: SortOrder
    killerguild?: SortOrder
    targetguild?: SortOrder
    warid?: SortOrder
    time?: SortOrder
  }

  export type guildwar_killsMaxOrderByAggregateInput = {
    id?: SortOrder
    killer?: SortOrder
    target?: SortOrder
    killerguild?: SortOrder
    targetguild?: SortOrder
    warid?: SortOrder
    time?: SortOrder
  }

  export type guildwar_killsMinOrderByAggregateInput = {
    id?: SortOrder
    killer?: SortOrder
    target?: SortOrder
    killerguild?: SortOrder
    targetguild?: SortOrder
    warid?: SortOrder
    time?: SortOrder
  }

  export type guildwar_killsSumOrderByAggregateInput = {
    id?: SortOrder
    killerguild?: SortOrder
    targetguild?: SortOrder
    warid?: SortOrder
    time?: SortOrder
  }

  export type ip_bansCountOrderByAggregateInput = {
    ip?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
  }

  export type ip_bansAvgOrderByAggregateInput = {
    ip?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
  }

  export type ip_bansMaxOrderByAggregateInput = {
    ip?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
  }

  export type ip_bansMinOrderByAggregateInput = {
    ip?: SortOrder
    reason?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
  }

  export type ip_bansSumOrderByAggregateInput = {
    ip?: SortOrder
    banned_at?: SortOrder
    expires_at?: SortOrder
    banned_by?: SortOrder
  }

  export type market_historyCountOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    sale?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    expires_at?: SortOrder
    inserted?: SortOrder
    state?: SortOrder
  }

  export type market_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    expires_at?: SortOrder
    inserted?: SortOrder
    state?: SortOrder
  }

  export type market_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    sale?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    expires_at?: SortOrder
    inserted?: SortOrder
    state?: SortOrder
  }

  export type market_historyMinOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    sale?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    expires_at?: SortOrder
    inserted?: SortOrder
    state?: SortOrder
  }

  export type market_historySumOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    expires_at?: SortOrder
    inserted?: SortOrder
    state?: SortOrder
  }

  export type market_offersCountOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    sale?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    created?: SortOrder
    anonymous?: SortOrder
    price?: SortOrder
  }

  export type market_offersAvgOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    created?: SortOrder
    price?: SortOrder
  }

  export type market_offersMaxOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    sale?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    created?: SortOrder
    anonymous?: SortOrder
    price?: SortOrder
  }

  export type market_offersMinOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    sale?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    created?: SortOrder
    anonymous?: SortOrder
    price?: SortOrder
  }

  export type market_offersSumOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    itemtype?: SortOrder
    amount?: SortOrder
    created?: SortOrder
    price?: SortOrder
  }

  export type petsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    rank?: SortOrder
    stage?: SortOrder
    name?: SortOrder
    pet?: SortOrder
    owner?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    addonItem?: SortOrder
    strength?: SortOrder
    wisdom?: SortOrder
    agility?: SortOrder
    sustain?: SortOrder
    magicResistance?: SortOrder
    lucky?: SortOrder
    hungry?: SortOrder
    hygiene?: SortOrder
    happiness?: SortOrder
    health?: SortOrder
    cooldowns?: SortOrder
    world_id?: SortOrder
    wallet?: SortOrder
  }

  export type petsAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    rank?: SortOrder
    stage?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    addonItem?: SortOrder
    strength?: SortOrder
    wisdom?: SortOrder
    agility?: SortOrder
    sustain?: SortOrder
    magicResistance?: SortOrder
    lucky?: SortOrder
    hungry?: SortOrder
    hygiene?: SortOrder
    happiness?: SortOrder
    health?: SortOrder
  }

  export type petsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    rank?: SortOrder
    stage?: SortOrder
    name?: SortOrder
    pet?: SortOrder
    owner?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    addonItem?: SortOrder
    strength?: SortOrder
    wisdom?: SortOrder
    agility?: SortOrder
    sustain?: SortOrder
    magicResistance?: SortOrder
    lucky?: SortOrder
    hungry?: SortOrder
    hygiene?: SortOrder
    happiness?: SortOrder
    health?: SortOrder
    cooldowns?: SortOrder
    world_id?: SortOrder
    wallet?: SortOrder
  }

  export type petsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    rank?: SortOrder
    stage?: SortOrder
    name?: SortOrder
    pet?: SortOrder
    owner?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    addonItem?: SortOrder
    strength?: SortOrder
    wisdom?: SortOrder
    agility?: SortOrder
    sustain?: SortOrder
    magicResistance?: SortOrder
    lucky?: SortOrder
    hungry?: SortOrder
    hygiene?: SortOrder
    happiness?: SortOrder
    health?: SortOrder
    cooldowns?: SortOrder
    world_id?: SortOrder
    wallet?: SortOrder
  }

  export type petsSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    rank?: SortOrder
    stage?: SortOrder
    level?: SortOrder
    experience?: SortOrder
    addonItem?: SortOrder
    strength?: SortOrder
    wisdom?: SortOrder
    agility?: SortOrder
    sustain?: SortOrder
    magicResistance?: SortOrder
    lucky?: SortOrder
    hungry?: SortOrder
    hygiene?: SortOrder
    happiness?: SortOrder
    health?: SortOrder
  }

  export type player_depotitemsPlayer_idSidCompoundUniqueInput = {
    player_id: number
    sid: number
  }

  export type player_depotitemsCountOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
    json_data?: SortOrder
  }

  export type player_depotitemsAvgOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
  }

  export type player_depotitemsMaxOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
  }

  export type player_depotitemsMinOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
  }

  export type player_depotitemsSumOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
  }

  export type player_inboxitemsPlayer_idSidCompoundUniqueInput = {
    player_id: number
    sid: number
  }

  export type player_inboxitemsCountOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
    json_data?: SortOrder
  }

  export type player_inboxitemsAvgOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
  }

  export type player_inboxitemsMaxOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
  }

  export type player_inboxitemsMinOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
  }

  export type player_inboxitemsSumOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
  }

  export type player_namelocksCountOrderByAggregateInput = {
    player_id?: SortOrder
    reason?: SortOrder
    namelocked_at?: SortOrder
    namelocked_by?: SortOrder
  }

  export type player_namelocksAvgOrderByAggregateInput = {
    player_id?: SortOrder
    namelocked_at?: SortOrder
    namelocked_by?: SortOrder
  }

  export type player_namelocksMaxOrderByAggregateInput = {
    player_id?: SortOrder
    reason?: SortOrder
    namelocked_at?: SortOrder
    namelocked_by?: SortOrder
  }

  export type player_namelocksMinOrderByAggregateInput = {
    player_id?: SortOrder
    reason?: SortOrder
    namelocked_at?: SortOrder
    namelocked_by?: SortOrder
  }

  export type player_namelocksSumOrderByAggregateInput = {
    player_id?: SortOrder
    namelocked_at?: SortOrder
    namelocked_by?: SortOrder
  }

  export type player_storagePlayer_idKeyCompoundUniqueInput = {
    player_id: number
    key: number
  }

  export type player_storageCountOrderByAggregateInput = {
    player_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type player_storageAvgOrderByAggregateInput = {
    player_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type player_storageMaxOrderByAggregateInput = {
    player_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type player_storageMinOrderByAggregateInput = {
    player_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type player_storageSumOrderByAggregateInput = {
    player_id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type player_storeinboxitemsPlayer_idSidCompoundUniqueInput = {
    player_id: number
    sid: number
  }

  export type player_storeinboxitemsCountOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
    json_data?: SortOrder
  }

  export type player_storeinboxitemsAvgOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
  }

  export type player_storeinboxitemsMaxOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
  }

  export type player_storeinboxitemsMinOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
    attributes?: SortOrder
  }

  export type player_storeinboxitemsSumOrderByAggregateInput = {
    player_id?: SortOrder
    sid?: SortOrder
    pid?: SortOrder
    itemtype?: SortOrder
    count?: SortOrder
  }

  export type players_onlineCountOrderByAggregateInput = {
    player_id?: SortOrder
  }

  export type players_onlineAvgOrderByAggregateInput = {
    player_id?: SortOrder
  }

  export type players_onlineMaxOrderByAggregateInput = {
    player_id?: SortOrder
  }

  export type players_onlineMinOrderByAggregateInput = {
    player_id?: SortOrder
  }

  export type players_onlineSumOrderByAggregateInput = {
    player_id?: SortOrder
  }

  export type server_configCountOrderByAggregateInput = {
    config?: SortOrder
    value?: SortOrder
  }

  export type server_configMaxOrderByAggregateInput = {
    config?: SortOrder
    value?: SortOrder
  }

  export type server_configMinOrderByAggregateInput = {
    config?: SortOrder
    value?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type shop_historyCountOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    player?: SortOrder
    date?: SortOrder
    title?: SortOrder
    cost?: SortOrder
    details?: SortOrder
  }

  export type shop_historyAvgOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    player?: SortOrder
    cost?: SortOrder
  }

  export type shop_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    player?: SortOrder
    date?: SortOrder
    title?: SortOrder
    cost?: SortOrder
    details?: SortOrder
  }

  export type shop_historyMinOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    player?: SortOrder
    date?: SortOrder
    title?: SortOrder
    cost?: SortOrder
    details?: SortOrder
  }

  export type shop_historySumOrderByAggregateInput = {
    id?: SortOrder
    account?: SortOrder
    player?: SortOrder
    cost?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type townsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
  }

  export type townsAvgOrderByAggregateInput = {
    id?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
  }

  export type townsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
  }

  export type townsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
  }

  export type townsSumOrderByAggregateInput = {
    id?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type znoteCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    installed?: SortOrder
    cached?: SortOrder
  }

  export type znoteAvgOrderByAggregateInput = {
    id?: SortOrder
    installed?: SortOrder
    cached?: SortOrder
  }

  export type znoteMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    installed?: SortOrder
    cached?: SortOrder
  }

  export type znoteMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    installed?: SortOrder
    cached?: SortOrder
  }

  export type znoteSumOrderByAggregateInput = {
    id?: SortOrder
    installed?: SortOrder
    cached?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type znote_accountsCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    ip?: SortOrder
    created?: SortOrder
    points?: SortOrder
    cooldown?: SortOrder
    active?: SortOrder
    active_email?: SortOrder
    activekey?: SortOrder
    flag?: SortOrder
    secret?: SortOrder
  }

  export type znote_accountsAvgOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    ip?: SortOrder
    created?: SortOrder
    points?: SortOrder
    cooldown?: SortOrder
    active?: SortOrder
    active_email?: SortOrder
    activekey?: SortOrder
  }

  export type znote_accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    ip?: SortOrder
    created?: SortOrder
    points?: SortOrder
    cooldown?: SortOrder
    active?: SortOrder
    active_email?: SortOrder
    activekey?: SortOrder
    flag?: SortOrder
    secret?: SortOrder
  }

  export type znote_accountsMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    ip?: SortOrder
    created?: SortOrder
    points?: SortOrder
    cooldown?: SortOrder
    active?: SortOrder
    active_email?: SortOrder
    activekey?: SortOrder
    flag?: SortOrder
    secret?: SortOrder
  }

  export type znote_accountsSumOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    ip?: SortOrder
    created?: SortOrder
    points?: SortOrder
    cooldown?: SortOrder
    active?: SortOrder
    active_email?: SortOrder
    activekey?: SortOrder
  }

  export type znote_auction_playerCountOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    original_account_id?: SortOrder
    bidder_account_id?: SortOrder
    time_begin?: SortOrder
    time_end?: SortOrder
    price?: SortOrder
    bid?: SortOrder
    deposit?: SortOrder
    sold?: SortOrder
    claimed?: SortOrder
  }

  export type znote_auction_playerAvgOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    original_account_id?: SortOrder
    bidder_account_id?: SortOrder
    time_begin?: SortOrder
    time_end?: SortOrder
    price?: SortOrder
    bid?: SortOrder
    deposit?: SortOrder
    sold?: SortOrder
    claimed?: SortOrder
  }

  export type znote_auction_playerMaxOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    original_account_id?: SortOrder
    bidder_account_id?: SortOrder
    time_begin?: SortOrder
    time_end?: SortOrder
    price?: SortOrder
    bid?: SortOrder
    deposit?: SortOrder
    sold?: SortOrder
    claimed?: SortOrder
  }

  export type znote_auction_playerMinOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    original_account_id?: SortOrder
    bidder_account_id?: SortOrder
    time_begin?: SortOrder
    time_end?: SortOrder
    price?: SortOrder
    bid?: SortOrder
    deposit?: SortOrder
    sold?: SortOrder
    claimed?: SortOrder
  }

  export type znote_auction_playerSumOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    original_account_id?: SortOrder
    bidder_account_id?: SortOrder
    time_begin?: SortOrder
    time_end?: SortOrder
    price?: SortOrder
    bid?: SortOrder
    deposit?: SortOrder
    sold?: SortOrder
    claimed?: SortOrder
  }

  export type znote_changelogCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    time?: SortOrder
    report_id?: SortOrder
    status?: SortOrder
  }

  export type znote_changelogAvgOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    report_id?: SortOrder
    status?: SortOrder
  }

  export type znote_changelogMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    time?: SortOrder
    report_id?: SortOrder
    status?: SortOrder
  }

  export type znote_changelogMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    time?: SortOrder
    report_id?: SortOrder
    status?: SortOrder
  }

  export type znote_changelogSumOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    report_id?: SortOrder
    status?: SortOrder
  }

  export type znote_deleted_charactersCountOrderByAggregateInput = {
    id?: SortOrder
    original_account_id?: SortOrder
    character_name?: SortOrder
    time?: SortOrder
    done?: SortOrder
  }

  export type znote_deleted_charactersAvgOrderByAggregateInput = {
    id?: SortOrder
    original_account_id?: SortOrder
    done?: SortOrder
  }

  export type znote_deleted_charactersMaxOrderByAggregateInput = {
    id?: SortOrder
    original_account_id?: SortOrder
    character_name?: SortOrder
    time?: SortOrder
    done?: SortOrder
  }

  export type znote_deleted_charactersMinOrderByAggregateInput = {
    id?: SortOrder
    original_account_id?: SortOrder
    character_name?: SortOrder
    time?: SortOrder
    done?: SortOrder
  }

  export type znote_deleted_charactersSumOrderByAggregateInput = {
    id?: SortOrder
    original_account_id?: SortOrder
    done?: SortOrder
  }

  export type znote_forumCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    access?: SortOrder
    closed?: SortOrder
    hidden?: SortOrder
    guild_id?: SortOrder
  }

  export type znote_forumAvgOrderByAggregateInput = {
    id?: SortOrder
    access?: SortOrder
    closed?: SortOrder
    hidden?: SortOrder
    guild_id?: SortOrder
  }

  export type znote_forumMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    access?: SortOrder
    closed?: SortOrder
    hidden?: SortOrder
    guild_id?: SortOrder
  }

  export type znote_forumMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    access?: SortOrder
    closed?: SortOrder
    hidden?: SortOrder
    guild_id?: SortOrder
  }

  export type znote_forumSumOrderByAggregateInput = {
    id?: SortOrder
    access?: SortOrder
    closed?: SortOrder
    hidden?: SortOrder
    guild_id?: SortOrder
  }

  export type znote_forum_postsCountOrderByAggregateInput = {
    id?: SortOrder
    thread_id?: SortOrder
    player_id?: SortOrder
    player_name?: SortOrder
    text?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type znote_forum_postsAvgOrderByAggregateInput = {
    id?: SortOrder
    thread_id?: SortOrder
    player_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type znote_forum_postsMaxOrderByAggregateInput = {
    id?: SortOrder
    thread_id?: SortOrder
    player_id?: SortOrder
    player_name?: SortOrder
    text?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type znote_forum_postsMinOrderByAggregateInput = {
    id?: SortOrder
    thread_id?: SortOrder
    player_id?: SortOrder
    player_name?: SortOrder
    text?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type znote_forum_postsSumOrderByAggregateInput = {
    id?: SortOrder
    thread_id?: SortOrder
    player_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type znote_forum_threadsCountOrderByAggregateInput = {
    id?: SortOrder
    forum_id?: SortOrder
    player_id?: SortOrder
    player_name?: SortOrder
    title?: SortOrder
    text?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    sticky?: SortOrder
    hidden?: SortOrder
    closed?: SortOrder
  }

  export type znote_forum_threadsAvgOrderByAggregateInput = {
    id?: SortOrder
    forum_id?: SortOrder
    player_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    sticky?: SortOrder
    hidden?: SortOrder
    closed?: SortOrder
  }

  export type znote_forum_threadsMaxOrderByAggregateInput = {
    id?: SortOrder
    forum_id?: SortOrder
    player_id?: SortOrder
    player_name?: SortOrder
    title?: SortOrder
    text?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    sticky?: SortOrder
    hidden?: SortOrder
    closed?: SortOrder
  }

  export type znote_forum_threadsMinOrderByAggregateInput = {
    id?: SortOrder
    forum_id?: SortOrder
    player_id?: SortOrder
    player_name?: SortOrder
    title?: SortOrder
    text?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    sticky?: SortOrder
    hidden?: SortOrder
    closed?: SortOrder
  }

  export type znote_forum_threadsSumOrderByAggregateInput = {
    id?: SortOrder
    forum_id?: SortOrder
    player_id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    sticky?: SortOrder
    hidden?: SortOrder
    closed?: SortOrder
  }

  export type znote_global_storageCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type znote_global_storageMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type znote_global_storageMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type znote_guild_warsCountOrderByAggregateInput = {
    id?: SortOrder
    limit?: SortOrder
  }

  export type znote_guild_warsAvgOrderByAggregateInput = {
    id?: SortOrder
    limit?: SortOrder
  }

  export type znote_guild_warsMaxOrderByAggregateInput = {
    id?: SortOrder
    limit?: SortOrder
  }

  export type znote_guild_warsMinOrderByAggregateInput = {
    id?: SortOrder
    limit?: SortOrder
  }

  export type znote_guild_warsSumOrderByAggregateInput = {
    id?: SortOrder
    limit?: SortOrder
  }

  export type znote_imagesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    date?: SortOrder
    status?: SortOrder
    image?: SortOrder
    delhash?: SortOrder
    account_id?: SortOrder
  }

  export type znote_imagesAvgOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    account_id?: SortOrder
  }

  export type znote_imagesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    date?: SortOrder
    status?: SortOrder
    image?: SortOrder
    delhash?: SortOrder
    account_id?: SortOrder
  }

  export type znote_imagesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    date?: SortOrder
    status?: SortOrder
    image?: SortOrder
    delhash?: SortOrder
    account_id?: SortOrder
  }

  export type znote_imagesSumOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    account_id?: SortOrder
  }

  export type znote_newsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    text?: SortOrder
    date?: SortOrder
    pid?: SortOrder
  }

  export type znote_newsAvgOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    pid?: SortOrder
  }

  export type znote_newsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    text?: SortOrder
    date?: SortOrder
    pid?: SortOrder
  }

  export type znote_newsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    text?: SortOrder
    date?: SortOrder
    pid?: SortOrder
  }

  export type znote_newsSumOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    pid?: SortOrder
  }

  export type znote_paygolCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    price?: SortOrder
    points?: SortOrder
    message_id?: SortOrder
    service_id?: SortOrder
    shortcode?: SortOrder
    keyword?: SortOrder
    message?: SortOrder
    sender?: SortOrder
    operator?: SortOrder
    country?: SortOrder
    currency?: SortOrder
  }

  export type znote_paygolAvgOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    price?: SortOrder
    points?: SortOrder
  }

  export type znote_paygolMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    price?: SortOrder
    points?: SortOrder
    message_id?: SortOrder
    service_id?: SortOrder
    shortcode?: SortOrder
    keyword?: SortOrder
    message?: SortOrder
    sender?: SortOrder
    operator?: SortOrder
    country?: SortOrder
    currency?: SortOrder
  }

  export type znote_paygolMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    price?: SortOrder
    points?: SortOrder
    message_id?: SortOrder
    service_id?: SortOrder
    shortcode?: SortOrder
    keyword?: SortOrder
    message?: SortOrder
    sender?: SortOrder
    operator?: SortOrder
    country?: SortOrder
    currency?: SortOrder
  }

  export type znote_paygolSumOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    price?: SortOrder
    points?: SortOrder
  }

  export type znote_paypalCountOrderByAggregateInput = {
    id?: SortOrder
    txn_id?: SortOrder
    email?: SortOrder
    accid?: SortOrder
    price?: SortOrder
    points?: SortOrder
  }

  export type znote_paypalAvgOrderByAggregateInput = {
    id?: SortOrder
    accid?: SortOrder
    price?: SortOrder
    points?: SortOrder
  }

  export type znote_paypalMaxOrderByAggregateInput = {
    id?: SortOrder
    txn_id?: SortOrder
    email?: SortOrder
    accid?: SortOrder
    price?: SortOrder
    points?: SortOrder
  }

  export type znote_paypalMinOrderByAggregateInput = {
    id?: SortOrder
    txn_id?: SortOrder
    email?: SortOrder
    accid?: SortOrder
    price?: SortOrder
    points?: SortOrder
  }

  export type znote_paypalSumOrderByAggregateInput = {
    id?: SortOrder
    accid?: SortOrder
    price?: SortOrder
    points?: SortOrder
  }

  export type znote_player_reportsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    report_description?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type znote_player_reportsAvgOrderByAggregateInput = {
    id?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type znote_player_reportsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    report_description?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type znote_player_reportsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    report_description?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type znote_player_reportsSumOrderByAggregateInput = {
    id?: SortOrder
    posx?: SortOrder
    posy?: SortOrder
    posz?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type znote_playersCountOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    created?: SortOrder
    hide_char?: SortOrder
    comment?: SortOrder
  }

  export type znote_playersAvgOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    created?: SortOrder
    hide_char?: SortOrder
  }

  export type znote_playersMaxOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    created?: SortOrder
    hide_char?: SortOrder
    comment?: SortOrder
  }

  export type znote_playersMinOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    created?: SortOrder
    hide_char?: SortOrder
    comment?: SortOrder
  }

  export type znote_playersSumOrderByAggregateInput = {
    id?: SortOrder
    player_id?: SortOrder
    created?: SortOrder
    hide_char?: SortOrder
  }

  export type znote_shopCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    description?: SortOrder
    points?: SortOrder
  }

  export type znote_shopAvgOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    points?: SortOrder
  }

  export type znote_shopMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    description?: SortOrder
    points?: SortOrder
  }

  export type znote_shopMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    description?: SortOrder
    points?: SortOrder
  }

  export type znote_shopSumOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    points?: SortOrder
  }

  export type znote_shop_logsCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    points?: SortOrder
    time?: SortOrder
  }

  export type znote_shop_logsAvgOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    points?: SortOrder
    time?: SortOrder
  }

  export type znote_shop_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    points?: SortOrder
    time?: SortOrder
  }

  export type znote_shop_logsMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    points?: SortOrder
    time?: SortOrder
  }

  export type znote_shop_logsSumOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    points?: SortOrder
    time?: SortOrder
  }

  export type znote_shop_ordersCountOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    time?: SortOrder
  }

  export type znote_shop_ordersAvgOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    time?: SortOrder
  }

  export type znote_shop_ordersMaxOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    time?: SortOrder
  }

  export type znote_shop_ordersMinOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    time?: SortOrder
  }

  export type znote_shop_ordersSumOrderByAggregateInput = {
    id?: SortOrder
    account_id?: SortOrder
    type?: SortOrder
    itemid?: SortOrder
    count?: SortOrder
    time?: SortOrder
  }

  export type znote_ticketsCountOrderByAggregateInput = {
    id?: SortOrder
    owner?: SortOrder
    username?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    ip?: SortOrder
    creation?: SortOrder
    status?: SortOrder
  }

  export type znote_ticketsAvgOrderByAggregateInput = {
    id?: SortOrder
    owner?: SortOrder
    ip?: SortOrder
    creation?: SortOrder
  }

  export type znote_ticketsMaxOrderByAggregateInput = {
    id?: SortOrder
    owner?: SortOrder
    username?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    ip?: SortOrder
    creation?: SortOrder
    status?: SortOrder
  }

  export type znote_ticketsMinOrderByAggregateInput = {
    id?: SortOrder
    owner?: SortOrder
    username?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    ip?: SortOrder
    creation?: SortOrder
    status?: SortOrder
  }

  export type znote_ticketsSumOrderByAggregateInput = {
    id?: SortOrder
    owner?: SortOrder
    ip?: SortOrder
    creation?: SortOrder
  }

  export type znote_tickets_repliesCountOrderByAggregateInput = {
    id?: SortOrder
    tid?: SortOrder
    username?: SortOrder
    message?: SortOrder
    created?: SortOrder
  }

  export type znote_tickets_repliesAvgOrderByAggregateInput = {
    id?: SortOrder
    tid?: SortOrder
    created?: SortOrder
  }

  export type znote_tickets_repliesMaxOrderByAggregateInput = {
    id?: SortOrder
    tid?: SortOrder
    username?: SortOrder
    message?: SortOrder
    created?: SortOrder
  }

  export type znote_tickets_repliesMinOrderByAggregateInput = {
    id?: SortOrder
    tid?: SortOrder
    username?: SortOrder
    message?: SortOrder
    created?: SortOrder
  }

  export type znote_tickets_repliesSumOrderByAggregateInput = {
    id?: SortOrder
    tid?: SortOrder
    created?: SortOrder
  }

  export type znote_visitorsCountOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    value?: SortOrder
  }

  export type znote_visitorsAvgOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    value?: SortOrder
  }

  export type znote_visitorsMaxOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    value?: SortOrder
  }

  export type znote_visitorsMinOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    value?: SortOrder
  }

  export type znote_visitorsSumOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    value?: SortOrder
  }

  export type znote_visitors_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    type?: SortOrder
    account_id?: SortOrder
  }

  export type znote_visitors_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    type?: SortOrder
    account_id?: SortOrder
  }

  export type znote_visitors_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    type?: SortOrder
    account_id?: SortOrder
  }

  export type znote_visitors_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    type?: SortOrder
    account_id?: SortOrder
  }

  export type znote_visitors_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    time?: SortOrder
    type?: SortOrder
    account_id?: SortOrder
  }

  export type account_ban_historyCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<account_ban_historyCreateWithoutAccountsInput>, Enumerable<account_ban_historyUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<account_ban_historyCreateOrConnectWithoutAccountsInput>
    createMany?: account_ban_historyCreateManyAccountsInputEnvelope
    connect?: Enumerable<account_ban_historyWhereUniqueInput>
  }

  export type account_bansCreateNestedOneWithoutAccountsInput = {
    create?: XOR<account_bansCreateWithoutAccountsInput, account_bansUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: account_bansCreateOrConnectWithoutAccountsInput
    connect?: account_bansWhereUniqueInput
  }

  export type account_storageCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<account_storageCreateWithoutAccountsInput>, Enumerable<account_storageUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<account_storageCreateOrConnectWithoutAccountsInput>
    createMany?: account_storageCreateManyAccountsInputEnvelope
    connect?: Enumerable<account_storageWhereUniqueInput>
  }

  export type account_viplistCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<account_viplistCreateWithoutAccountsInput>, Enumerable<account_viplistUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<account_viplistCreateOrConnectWithoutAccountsInput>
    createMany?: account_viplistCreateManyAccountsInputEnvelope
    connect?: Enumerable<account_viplistWhereUniqueInput>
  }

  export type PlayerCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutAccountsInput>, Enumerable<PlayerUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutAccountsInput>
    createMany?: PlayerCreateManyAccountsInputEnvelope
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type account_ban_historyUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<account_ban_historyCreateWithoutAccountsInput>, Enumerable<account_ban_historyUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<account_ban_historyCreateOrConnectWithoutAccountsInput>
    createMany?: account_ban_historyCreateManyAccountsInputEnvelope
    connect?: Enumerable<account_ban_historyWhereUniqueInput>
  }

  export type account_bansUncheckedCreateNestedOneWithoutAccountsInput = {
    create?: XOR<account_bansCreateWithoutAccountsInput, account_bansUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: account_bansCreateOrConnectWithoutAccountsInput
    connect?: account_bansWhereUniqueInput
  }

  export type account_storageUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<account_storageCreateWithoutAccountsInput>, Enumerable<account_storageUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<account_storageCreateOrConnectWithoutAccountsInput>
    createMany?: account_storageCreateManyAccountsInputEnvelope
    connect?: Enumerable<account_storageWhereUniqueInput>
  }

  export type account_viplistUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<account_viplistCreateWithoutAccountsInput>, Enumerable<account_viplistUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<account_viplistCreateOrConnectWithoutAccountsInput>
    createMany?: account_viplistCreateManyAccountsInputEnvelope
    connect?: Enumerable<account_viplistWhereUniqueInput>
  }

  export type PlayerUncheckedCreateNestedManyWithoutAccountsInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutAccountsInput>, Enumerable<PlayerUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutAccountsInput>
    createMany?: PlayerCreateManyAccountsInputEnvelope
    connect?: Enumerable<PlayerWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type account_ban_historyUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<account_ban_historyCreateWithoutAccountsInput>, Enumerable<account_ban_historyUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<account_ban_historyCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<account_ban_historyUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: account_ban_historyCreateManyAccountsInputEnvelope
    set?: Enumerable<account_ban_historyWhereUniqueInput>
    disconnect?: Enumerable<account_ban_historyWhereUniqueInput>
    delete?: Enumerable<account_ban_historyWhereUniqueInput>
    connect?: Enumerable<account_ban_historyWhereUniqueInput>
    update?: Enumerable<account_ban_historyUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<account_ban_historyUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<account_ban_historyScalarWhereInput>
  }

  export type account_bansUpdateOneWithoutAccountsNestedInput = {
    create?: XOR<account_bansCreateWithoutAccountsInput, account_bansUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: account_bansCreateOrConnectWithoutAccountsInput
    upsert?: account_bansUpsertWithoutAccountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: account_bansWhereUniqueInput
    update?: XOR<account_bansUpdateWithoutAccountsInput, account_bansUncheckedUpdateWithoutAccountsInput>
  }

  export type account_storageUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<account_storageCreateWithoutAccountsInput>, Enumerable<account_storageUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<account_storageCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<account_storageUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: account_storageCreateManyAccountsInputEnvelope
    set?: Enumerable<account_storageWhereUniqueInput>
    disconnect?: Enumerable<account_storageWhereUniqueInput>
    delete?: Enumerable<account_storageWhereUniqueInput>
    connect?: Enumerable<account_storageWhereUniqueInput>
    update?: Enumerable<account_storageUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<account_storageUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<account_storageScalarWhereInput>
  }

  export type account_viplistUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<account_viplistCreateWithoutAccountsInput>, Enumerable<account_viplistUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<account_viplistCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<account_viplistUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: account_viplistCreateManyAccountsInputEnvelope
    set?: Enumerable<account_viplistWhereUniqueInput>
    disconnect?: Enumerable<account_viplistWhereUniqueInput>
    delete?: Enumerable<account_viplistWhereUniqueInput>
    connect?: Enumerable<account_viplistWhereUniqueInput>
    update?: Enumerable<account_viplistUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<account_viplistUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<account_viplistScalarWhereInput>
  }

  export type PlayerUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutAccountsInput>, Enumerable<PlayerUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: PlayerCreateManyAccountsInputEnvelope
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type account_ban_historyUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<account_ban_historyCreateWithoutAccountsInput>, Enumerable<account_ban_historyUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<account_ban_historyCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<account_ban_historyUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: account_ban_historyCreateManyAccountsInputEnvelope
    set?: Enumerable<account_ban_historyWhereUniqueInput>
    disconnect?: Enumerable<account_ban_historyWhereUniqueInput>
    delete?: Enumerable<account_ban_historyWhereUniqueInput>
    connect?: Enumerable<account_ban_historyWhereUniqueInput>
    update?: Enumerable<account_ban_historyUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<account_ban_historyUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<account_ban_historyScalarWhereInput>
  }

  export type account_bansUncheckedUpdateOneWithoutAccountsNestedInput = {
    create?: XOR<account_bansCreateWithoutAccountsInput, account_bansUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: account_bansCreateOrConnectWithoutAccountsInput
    upsert?: account_bansUpsertWithoutAccountsInput
    disconnect?: boolean
    delete?: boolean
    connect?: account_bansWhereUniqueInput
    update?: XOR<account_bansUpdateWithoutAccountsInput, account_bansUncheckedUpdateWithoutAccountsInput>
  }

  export type account_storageUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<account_storageCreateWithoutAccountsInput>, Enumerable<account_storageUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<account_storageCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<account_storageUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: account_storageCreateManyAccountsInputEnvelope
    set?: Enumerable<account_storageWhereUniqueInput>
    disconnect?: Enumerable<account_storageWhereUniqueInput>
    delete?: Enumerable<account_storageWhereUniqueInput>
    connect?: Enumerable<account_storageWhereUniqueInput>
    update?: Enumerable<account_storageUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<account_storageUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<account_storageScalarWhereInput>
  }

  export type account_viplistUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<account_viplistCreateWithoutAccountsInput>, Enumerable<account_viplistUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<account_viplistCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<account_viplistUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: account_viplistCreateManyAccountsInputEnvelope
    set?: Enumerable<account_viplistWhereUniqueInput>
    disconnect?: Enumerable<account_viplistWhereUniqueInput>
    delete?: Enumerable<account_viplistWhereUniqueInput>
    connect?: Enumerable<account_viplistWhereUniqueInput>
    update?: Enumerable<account_viplistUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<account_viplistUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<account_viplistScalarWhereInput>
  }

  export type PlayerUncheckedUpdateManyWithoutAccountsNestedInput = {
    create?: XOR<Enumerable<PlayerCreateWithoutAccountsInput>, Enumerable<PlayerUncheckedCreateWithoutAccountsInput>>
    connectOrCreate?: Enumerable<PlayerCreateOrConnectWithoutAccountsInput>
    upsert?: Enumerable<PlayerUpsertWithWhereUniqueWithoutAccountsInput>
    createMany?: PlayerCreateManyAccountsInputEnvelope
    set?: Enumerable<PlayerWhereUniqueInput>
    disconnect?: Enumerable<PlayerWhereUniqueInput>
    delete?: Enumerable<PlayerWhereUniqueInput>
    connect?: Enumerable<PlayerWhereUniqueInput>
    update?: Enumerable<PlayerUpdateWithWhereUniqueWithoutAccountsInput>
    updateMany?: Enumerable<PlayerUpdateManyWithWhereWithoutAccountsInput>
    deleteMany?: Enumerable<PlayerScalarWhereInput>
  }

  export type account_ban_historyCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<account_ban_historyCreateWithoutPlayersInput>, Enumerable<account_ban_historyUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<account_ban_historyCreateOrConnectWithoutPlayersInput>
    createMany?: account_ban_historyCreateManyPlayersInputEnvelope
    connect?: Enumerable<account_ban_historyWhereUniqueInput>
  }

  export type account_bansCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<account_bansCreateWithoutPlayersInput>, Enumerable<account_bansUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<account_bansCreateOrConnectWithoutPlayersInput>
    createMany?: account_bansCreateManyPlayersInputEnvelope
    connect?: Enumerable<account_bansWhereUniqueInput>
  }

  export type account_viplistCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<account_viplistCreateWithoutPlayersInput>, Enumerable<account_viplistUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<account_viplistCreateOrConnectWithoutPlayersInput>
    createMany?: account_viplistCreateManyPlayersInputEnvelope
    connect?: Enumerable<account_viplistWhereUniqueInput>
  }

  export type guild_invitesCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<guild_invitesCreateWithoutPlayersInput>, Enumerable<guild_invitesUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<guild_invitesCreateOrConnectWithoutPlayersInput>
    createMany?: guild_invitesCreateManyPlayersInputEnvelope
    connect?: Enumerable<guild_invitesWhereUniqueInput>
  }

  export type guild_membershipCreateNestedOneWithoutPlayersInput = {
    create?: XOR<guild_membershipCreateWithoutPlayersInput, guild_membershipUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: guild_membershipCreateOrConnectWithoutPlayersInput
    connect?: guild_membershipWhereUniqueInput
  }

  export type guildsCreateNestedOneWithoutPlayersInput = {
    create?: XOR<guildsCreateWithoutPlayersInput, guildsUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: guildsCreateOrConnectWithoutPlayersInput
    connect?: guildsWhereUniqueInput
  }

  export type ip_bansCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<ip_bansCreateWithoutPlayersInput>, Enumerable<ip_bansUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<ip_bansCreateOrConnectWithoutPlayersInput>
    createMany?: ip_bansCreateManyPlayersInputEnvelope
    connect?: Enumerable<ip_bansWhereUniqueInput>
  }

  export type market_historyCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<market_historyCreateWithoutPlayersInput>, Enumerable<market_historyUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<market_historyCreateOrConnectWithoutPlayersInput>
    createMany?: market_historyCreateManyPlayersInputEnvelope
    connect?: Enumerable<market_historyWhereUniqueInput>
  }

  export type market_offersCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<market_offersCreateWithoutPlayersInput>, Enumerable<market_offersUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<market_offersCreateOrConnectWithoutPlayersInput>
    createMany?: market_offersCreateManyPlayersInputEnvelope
    connect?: Enumerable<market_offersWhereUniqueInput>
  }

  export type player_depotitemsCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<player_depotitemsCreateWithoutPlayersInput>, Enumerable<player_depotitemsUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_depotitemsCreateOrConnectWithoutPlayersInput>
    createMany?: player_depotitemsCreateManyPlayersInputEnvelope
    connect?: Enumerable<player_depotitemsWhereUniqueInput>
  }

  export type player_inboxitemsCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<player_inboxitemsCreateWithoutPlayersInput>, Enumerable<player_inboxitemsUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_inboxitemsCreateOrConnectWithoutPlayersInput>
    createMany?: player_inboxitemsCreateManyPlayersInputEnvelope
    connect?: Enumerable<player_inboxitemsWhereUniqueInput>
  }

  export type player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput = {
    create?: XOR<player_namelocksCreateWithoutPlayers_player_namelocks_player_idToplayersInput, player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_player_idToplayersInput>
    connectOrCreate?: player_namelocksCreateOrConnectWithoutPlayers_player_namelocks_player_idToplayersInput
    connect?: player_namelocksWhereUniqueInput
  }

  export type player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput = {
    create?: XOR<Enumerable<player_namelocksCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput>, Enumerable<player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput>>
    connectOrCreate?: Enumerable<player_namelocksCreateOrConnectWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
    createMany?: player_namelocksCreateManyPlayers_player_namelocks_namelocked_byToplayersInputEnvelope
    connect?: Enumerable<player_namelocksWhereUniqueInput>
  }

  export type player_storageCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<player_storageCreateWithoutPlayersInput>, Enumerable<player_storageUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_storageCreateOrConnectWithoutPlayersInput>
    createMany?: player_storageCreateManyPlayersInputEnvelope
    connect?: Enumerable<player_storageWhereUniqueInput>
  }

  export type player_storeinboxitemsCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<player_storeinboxitemsCreateWithoutPlayersInput>, Enumerable<player_storeinboxitemsUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_storeinboxitemsCreateOrConnectWithoutPlayersInput>
    createMany?: player_storeinboxitemsCreateManyPlayersInputEnvelope
    connect?: Enumerable<player_storeinboxitemsWhereUniqueInput>
  }

  export type AccountCreateNestedOneWithoutPlayersInput = {
    create?: XOR<AccountCreateWithoutPlayersInput, AccountUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPlayersInput
    connect?: AccountWhereUniqueInput
  }

  export type account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<account_ban_historyCreateWithoutPlayersInput>, Enumerable<account_ban_historyUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<account_ban_historyCreateOrConnectWithoutPlayersInput>
    createMany?: account_ban_historyCreateManyPlayersInputEnvelope
    connect?: Enumerable<account_ban_historyWhereUniqueInput>
  }

  export type account_bansUncheckedCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<account_bansCreateWithoutPlayersInput>, Enumerable<account_bansUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<account_bansCreateOrConnectWithoutPlayersInput>
    createMany?: account_bansCreateManyPlayersInputEnvelope
    connect?: Enumerable<account_bansWhereUniqueInput>
  }

  export type account_viplistUncheckedCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<account_viplistCreateWithoutPlayersInput>, Enumerable<account_viplistUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<account_viplistCreateOrConnectWithoutPlayersInput>
    createMany?: account_viplistCreateManyPlayersInputEnvelope
    connect?: Enumerable<account_viplistWhereUniqueInput>
  }

  export type guild_invitesUncheckedCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<guild_invitesCreateWithoutPlayersInput>, Enumerable<guild_invitesUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<guild_invitesCreateOrConnectWithoutPlayersInput>
    createMany?: guild_invitesCreateManyPlayersInputEnvelope
    connect?: Enumerable<guild_invitesWhereUniqueInput>
  }

  export type guild_membershipUncheckedCreateNestedOneWithoutPlayersInput = {
    create?: XOR<guild_membershipCreateWithoutPlayersInput, guild_membershipUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: guild_membershipCreateOrConnectWithoutPlayersInput
    connect?: guild_membershipWhereUniqueInput
  }

  export type guildsUncheckedCreateNestedOneWithoutPlayersInput = {
    create?: XOR<guildsCreateWithoutPlayersInput, guildsUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: guildsCreateOrConnectWithoutPlayersInput
    connect?: guildsWhereUniqueInput
  }

  export type ip_bansUncheckedCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<ip_bansCreateWithoutPlayersInput>, Enumerable<ip_bansUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<ip_bansCreateOrConnectWithoutPlayersInput>
    createMany?: ip_bansCreateManyPlayersInputEnvelope
    connect?: Enumerable<ip_bansWhereUniqueInput>
  }

  export type market_historyUncheckedCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<market_historyCreateWithoutPlayersInput>, Enumerable<market_historyUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<market_historyCreateOrConnectWithoutPlayersInput>
    createMany?: market_historyCreateManyPlayersInputEnvelope
    connect?: Enumerable<market_historyWhereUniqueInput>
  }

  export type market_offersUncheckedCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<market_offersCreateWithoutPlayersInput>, Enumerable<market_offersUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<market_offersCreateOrConnectWithoutPlayersInput>
    createMany?: market_offersCreateManyPlayersInputEnvelope
    connect?: Enumerable<market_offersWhereUniqueInput>
  }

  export type player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<player_depotitemsCreateWithoutPlayersInput>, Enumerable<player_depotitemsUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_depotitemsCreateOrConnectWithoutPlayersInput>
    createMany?: player_depotitemsCreateManyPlayersInputEnvelope
    connect?: Enumerable<player_depotitemsWhereUniqueInput>
  }

  export type player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<player_inboxitemsCreateWithoutPlayersInput>, Enumerable<player_inboxitemsUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_inboxitemsCreateOrConnectWithoutPlayersInput>
    createMany?: player_inboxitemsCreateManyPlayersInputEnvelope
    connect?: Enumerable<player_inboxitemsWhereUniqueInput>
  }

  export type player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput = {
    create?: XOR<player_namelocksCreateWithoutPlayers_player_namelocks_player_idToplayersInput, player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_player_idToplayersInput>
    connectOrCreate?: player_namelocksCreateOrConnectWithoutPlayers_player_namelocks_player_idToplayersInput
    connect?: player_namelocksWhereUniqueInput
  }

  export type player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput = {
    create?: XOR<Enumerable<player_namelocksCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput>, Enumerable<player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput>>
    connectOrCreate?: Enumerable<player_namelocksCreateOrConnectWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
    createMany?: player_namelocksCreateManyPlayers_player_namelocks_namelocked_byToplayersInputEnvelope
    connect?: Enumerable<player_namelocksWhereUniqueInput>
  }

  export type player_storageUncheckedCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<player_storageCreateWithoutPlayersInput>, Enumerable<player_storageUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_storageCreateOrConnectWithoutPlayersInput>
    createMany?: player_storageCreateManyPlayersInputEnvelope
    connect?: Enumerable<player_storageWhereUniqueInput>
  }

  export type player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput = {
    create?: XOR<Enumerable<player_storeinboxitemsCreateWithoutPlayersInput>, Enumerable<player_storeinboxitemsUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_storeinboxitemsCreateOrConnectWithoutPlayersInput>
    createMany?: player_storeinboxitemsCreateManyPlayersInputEnvelope
    connect?: Enumerable<player_storeinboxitemsWhereUniqueInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type account_ban_historyUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<account_ban_historyCreateWithoutPlayersInput>, Enumerable<account_ban_historyUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<account_ban_historyCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<account_ban_historyUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: account_ban_historyCreateManyPlayersInputEnvelope
    set?: Enumerable<account_ban_historyWhereUniqueInput>
    disconnect?: Enumerable<account_ban_historyWhereUniqueInput>
    delete?: Enumerable<account_ban_historyWhereUniqueInput>
    connect?: Enumerable<account_ban_historyWhereUniqueInput>
    update?: Enumerable<account_ban_historyUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<account_ban_historyUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<account_ban_historyScalarWhereInput>
  }

  export type account_bansUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<account_bansCreateWithoutPlayersInput>, Enumerable<account_bansUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<account_bansCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<account_bansUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: account_bansCreateManyPlayersInputEnvelope
    set?: Enumerable<account_bansWhereUniqueInput>
    disconnect?: Enumerable<account_bansWhereUniqueInput>
    delete?: Enumerable<account_bansWhereUniqueInput>
    connect?: Enumerable<account_bansWhereUniqueInput>
    update?: Enumerable<account_bansUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<account_bansUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<account_bansScalarWhereInput>
  }

  export type account_viplistUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<account_viplistCreateWithoutPlayersInput>, Enumerable<account_viplistUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<account_viplistCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<account_viplistUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: account_viplistCreateManyPlayersInputEnvelope
    set?: Enumerable<account_viplistWhereUniqueInput>
    disconnect?: Enumerable<account_viplistWhereUniqueInput>
    delete?: Enumerable<account_viplistWhereUniqueInput>
    connect?: Enumerable<account_viplistWhereUniqueInput>
    update?: Enumerable<account_viplistUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<account_viplistUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<account_viplistScalarWhereInput>
  }

  export type guild_invitesUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<guild_invitesCreateWithoutPlayersInput>, Enumerable<guild_invitesUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<guild_invitesCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<guild_invitesUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: guild_invitesCreateManyPlayersInputEnvelope
    set?: Enumerable<guild_invitesWhereUniqueInput>
    disconnect?: Enumerable<guild_invitesWhereUniqueInput>
    delete?: Enumerable<guild_invitesWhereUniqueInput>
    connect?: Enumerable<guild_invitesWhereUniqueInput>
    update?: Enumerable<guild_invitesUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<guild_invitesUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<guild_invitesScalarWhereInput>
  }

  export type guild_membershipUpdateOneWithoutPlayersNestedInput = {
    create?: XOR<guild_membershipCreateWithoutPlayersInput, guild_membershipUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: guild_membershipCreateOrConnectWithoutPlayersInput
    upsert?: guild_membershipUpsertWithoutPlayersInput
    disconnect?: boolean
    delete?: boolean
    connect?: guild_membershipWhereUniqueInput
    update?: XOR<guild_membershipUpdateWithoutPlayersInput, guild_membershipUncheckedUpdateWithoutPlayersInput>
  }

  export type guildsUpdateOneWithoutPlayersNestedInput = {
    create?: XOR<guildsCreateWithoutPlayersInput, guildsUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: guildsCreateOrConnectWithoutPlayersInput
    upsert?: guildsUpsertWithoutPlayersInput
    disconnect?: boolean
    delete?: boolean
    connect?: guildsWhereUniqueInput
    update?: XOR<guildsUpdateWithoutPlayersInput, guildsUncheckedUpdateWithoutPlayersInput>
  }

  export type ip_bansUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<ip_bansCreateWithoutPlayersInput>, Enumerable<ip_bansUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<ip_bansCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<ip_bansUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: ip_bansCreateManyPlayersInputEnvelope
    set?: Enumerable<ip_bansWhereUniqueInput>
    disconnect?: Enumerable<ip_bansWhereUniqueInput>
    delete?: Enumerable<ip_bansWhereUniqueInput>
    connect?: Enumerable<ip_bansWhereUniqueInput>
    update?: Enumerable<ip_bansUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<ip_bansUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<ip_bansScalarWhereInput>
  }

  export type market_historyUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<market_historyCreateWithoutPlayersInput>, Enumerable<market_historyUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<market_historyCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<market_historyUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: market_historyCreateManyPlayersInputEnvelope
    set?: Enumerable<market_historyWhereUniqueInput>
    disconnect?: Enumerable<market_historyWhereUniqueInput>
    delete?: Enumerable<market_historyWhereUniqueInput>
    connect?: Enumerable<market_historyWhereUniqueInput>
    update?: Enumerable<market_historyUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<market_historyUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<market_historyScalarWhereInput>
  }

  export type market_offersUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<market_offersCreateWithoutPlayersInput>, Enumerable<market_offersUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<market_offersCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<market_offersUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: market_offersCreateManyPlayersInputEnvelope
    set?: Enumerable<market_offersWhereUniqueInput>
    disconnect?: Enumerable<market_offersWhereUniqueInput>
    delete?: Enumerable<market_offersWhereUniqueInput>
    connect?: Enumerable<market_offersWhereUniqueInput>
    update?: Enumerable<market_offersUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<market_offersUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<market_offersScalarWhereInput>
  }

  export type player_depotitemsUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<player_depotitemsCreateWithoutPlayersInput>, Enumerable<player_depotitemsUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_depotitemsCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<player_depotitemsUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: player_depotitemsCreateManyPlayersInputEnvelope
    set?: Enumerable<player_depotitemsWhereUniqueInput>
    disconnect?: Enumerable<player_depotitemsWhereUniqueInput>
    delete?: Enumerable<player_depotitemsWhereUniqueInput>
    connect?: Enumerable<player_depotitemsWhereUniqueInput>
    update?: Enumerable<player_depotitemsUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<player_depotitemsUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<player_depotitemsScalarWhereInput>
  }

  export type player_inboxitemsUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<player_inboxitemsCreateWithoutPlayersInput>, Enumerable<player_inboxitemsUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_inboxitemsCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<player_inboxitemsUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: player_inboxitemsCreateManyPlayersInputEnvelope
    set?: Enumerable<player_inboxitemsWhereUniqueInput>
    disconnect?: Enumerable<player_inboxitemsWhereUniqueInput>
    delete?: Enumerable<player_inboxitemsWhereUniqueInput>
    connect?: Enumerable<player_inboxitemsWhereUniqueInput>
    update?: Enumerable<player_inboxitemsUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<player_inboxitemsUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<player_inboxitemsScalarWhereInput>
  }

  export type player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput = {
    create?: XOR<player_namelocksCreateWithoutPlayers_player_namelocks_player_idToplayersInput, player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_player_idToplayersInput>
    connectOrCreate?: player_namelocksCreateOrConnectWithoutPlayers_player_namelocks_player_idToplayersInput
    upsert?: player_namelocksUpsertWithoutPlayers_player_namelocks_player_idToplayersInput
    disconnect?: boolean
    delete?: boolean
    connect?: player_namelocksWhereUniqueInput
    update?: XOR<player_namelocksUpdateWithoutPlayers_player_namelocks_player_idToplayersInput, player_namelocksUncheckedUpdateWithoutPlayers_player_namelocks_player_idToplayersInput>
  }

  export type player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput = {
    create?: XOR<Enumerable<player_namelocksCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput>, Enumerable<player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput>>
    connectOrCreate?: Enumerable<player_namelocksCreateOrConnectWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
    upsert?: Enumerable<player_namelocksUpsertWithWhereUniqueWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
    createMany?: player_namelocksCreateManyPlayers_player_namelocks_namelocked_byToplayersInputEnvelope
    set?: Enumerable<player_namelocksWhereUniqueInput>
    disconnect?: Enumerable<player_namelocksWhereUniqueInput>
    delete?: Enumerable<player_namelocksWhereUniqueInput>
    connect?: Enumerable<player_namelocksWhereUniqueInput>
    update?: Enumerable<player_namelocksUpdateWithWhereUniqueWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
    updateMany?: Enumerable<player_namelocksUpdateManyWithWhereWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
    deleteMany?: Enumerable<player_namelocksScalarWhereInput>
  }

  export type player_storageUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<player_storageCreateWithoutPlayersInput>, Enumerable<player_storageUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_storageCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<player_storageUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: player_storageCreateManyPlayersInputEnvelope
    set?: Enumerable<player_storageWhereUniqueInput>
    disconnect?: Enumerable<player_storageWhereUniqueInput>
    delete?: Enumerable<player_storageWhereUniqueInput>
    connect?: Enumerable<player_storageWhereUniqueInput>
    update?: Enumerable<player_storageUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<player_storageUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<player_storageScalarWhereInput>
  }

  export type player_storeinboxitemsUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<player_storeinboxitemsCreateWithoutPlayersInput>, Enumerable<player_storeinboxitemsUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_storeinboxitemsCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<player_storeinboxitemsUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: player_storeinboxitemsCreateManyPlayersInputEnvelope
    set?: Enumerable<player_storeinboxitemsWhereUniqueInput>
    disconnect?: Enumerable<player_storeinboxitemsWhereUniqueInput>
    delete?: Enumerable<player_storeinboxitemsWhereUniqueInput>
    connect?: Enumerable<player_storeinboxitemsWhereUniqueInput>
    update?: Enumerable<player_storeinboxitemsUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<player_storeinboxitemsUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<player_storeinboxitemsScalarWhereInput>
  }

  export type AccountUpdateOneRequiredWithoutPlayersNestedInput = {
    create?: XOR<AccountCreateWithoutPlayersInput, AccountUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPlayersInput
    upsert?: AccountUpsertWithoutPlayersInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutPlayersInput, AccountUncheckedUpdateWithoutPlayersInput>
  }

  export type account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<account_ban_historyCreateWithoutPlayersInput>, Enumerable<account_ban_historyUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<account_ban_historyCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<account_ban_historyUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: account_ban_historyCreateManyPlayersInputEnvelope
    set?: Enumerable<account_ban_historyWhereUniqueInput>
    disconnect?: Enumerable<account_ban_historyWhereUniqueInput>
    delete?: Enumerable<account_ban_historyWhereUniqueInput>
    connect?: Enumerable<account_ban_historyWhereUniqueInput>
    update?: Enumerable<account_ban_historyUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<account_ban_historyUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<account_ban_historyScalarWhereInput>
  }

  export type account_bansUncheckedUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<account_bansCreateWithoutPlayersInput>, Enumerable<account_bansUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<account_bansCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<account_bansUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: account_bansCreateManyPlayersInputEnvelope
    set?: Enumerable<account_bansWhereUniqueInput>
    disconnect?: Enumerable<account_bansWhereUniqueInput>
    delete?: Enumerable<account_bansWhereUniqueInput>
    connect?: Enumerable<account_bansWhereUniqueInput>
    update?: Enumerable<account_bansUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<account_bansUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<account_bansScalarWhereInput>
  }

  export type account_viplistUncheckedUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<account_viplistCreateWithoutPlayersInput>, Enumerable<account_viplistUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<account_viplistCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<account_viplistUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: account_viplistCreateManyPlayersInputEnvelope
    set?: Enumerable<account_viplistWhereUniqueInput>
    disconnect?: Enumerable<account_viplistWhereUniqueInput>
    delete?: Enumerable<account_viplistWhereUniqueInput>
    connect?: Enumerable<account_viplistWhereUniqueInput>
    update?: Enumerable<account_viplistUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<account_viplistUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<account_viplistScalarWhereInput>
  }

  export type guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<guild_invitesCreateWithoutPlayersInput>, Enumerable<guild_invitesUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<guild_invitesCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<guild_invitesUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: guild_invitesCreateManyPlayersInputEnvelope
    set?: Enumerable<guild_invitesWhereUniqueInput>
    disconnect?: Enumerable<guild_invitesWhereUniqueInput>
    delete?: Enumerable<guild_invitesWhereUniqueInput>
    connect?: Enumerable<guild_invitesWhereUniqueInput>
    update?: Enumerable<guild_invitesUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<guild_invitesUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<guild_invitesScalarWhereInput>
  }

  export type guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput = {
    create?: XOR<guild_membershipCreateWithoutPlayersInput, guild_membershipUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: guild_membershipCreateOrConnectWithoutPlayersInput
    upsert?: guild_membershipUpsertWithoutPlayersInput
    disconnect?: boolean
    delete?: boolean
    connect?: guild_membershipWhereUniqueInput
    update?: XOR<guild_membershipUpdateWithoutPlayersInput, guild_membershipUncheckedUpdateWithoutPlayersInput>
  }

  export type guildsUncheckedUpdateOneWithoutPlayersNestedInput = {
    create?: XOR<guildsCreateWithoutPlayersInput, guildsUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: guildsCreateOrConnectWithoutPlayersInput
    upsert?: guildsUpsertWithoutPlayersInput
    disconnect?: boolean
    delete?: boolean
    connect?: guildsWhereUniqueInput
    update?: XOR<guildsUpdateWithoutPlayersInput, guildsUncheckedUpdateWithoutPlayersInput>
  }

  export type ip_bansUncheckedUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<ip_bansCreateWithoutPlayersInput>, Enumerable<ip_bansUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<ip_bansCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<ip_bansUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: ip_bansCreateManyPlayersInputEnvelope
    set?: Enumerable<ip_bansWhereUniqueInput>
    disconnect?: Enumerable<ip_bansWhereUniqueInput>
    delete?: Enumerable<ip_bansWhereUniqueInput>
    connect?: Enumerable<ip_bansWhereUniqueInput>
    update?: Enumerable<ip_bansUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<ip_bansUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<ip_bansScalarWhereInput>
  }

  export type market_historyUncheckedUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<market_historyCreateWithoutPlayersInput>, Enumerable<market_historyUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<market_historyCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<market_historyUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: market_historyCreateManyPlayersInputEnvelope
    set?: Enumerable<market_historyWhereUniqueInput>
    disconnect?: Enumerable<market_historyWhereUniqueInput>
    delete?: Enumerable<market_historyWhereUniqueInput>
    connect?: Enumerable<market_historyWhereUniqueInput>
    update?: Enumerable<market_historyUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<market_historyUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<market_historyScalarWhereInput>
  }

  export type market_offersUncheckedUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<market_offersCreateWithoutPlayersInput>, Enumerable<market_offersUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<market_offersCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<market_offersUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: market_offersCreateManyPlayersInputEnvelope
    set?: Enumerable<market_offersWhereUniqueInput>
    disconnect?: Enumerable<market_offersWhereUniqueInput>
    delete?: Enumerable<market_offersWhereUniqueInput>
    connect?: Enumerable<market_offersWhereUniqueInput>
    update?: Enumerable<market_offersUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<market_offersUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<market_offersScalarWhereInput>
  }

  export type player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<player_depotitemsCreateWithoutPlayersInput>, Enumerable<player_depotitemsUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_depotitemsCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<player_depotitemsUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: player_depotitemsCreateManyPlayersInputEnvelope
    set?: Enumerable<player_depotitemsWhereUniqueInput>
    disconnect?: Enumerable<player_depotitemsWhereUniqueInput>
    delete?: Enumerable<player_depotitemsWhereUniqueInput>
    connect?: Enumerable<player_depotitemsWhereUniqueInput>
    update?: Enumerable<player_depotitemsUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<player_depotitemsUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<player_depotitemsScalarWhereInput>
  }

  export type player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<player_inboxitemsCreateWithoutPlayersInput>, Enumerable<player_inboxitemsUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_inboxitemsCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<player_inboxitemsUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: player_inboxitemsCreateManyPlayersInputEnvelope
    set?: Enumerable<player_inboxitemsWhereUniqueInput>
    disconnect?: Enumerable<player_inboxitemsWhereUniqueInput>
    delete?: Enumerable<player_inboxitemsWhereUniqueInput>
    connect?: Enumerable<player_inboxitemsWhereUniqueInput>
    update?: Enumerable<player_inboxitemsUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<player_inboxitemsUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<player_inboxitemsScalarWhereInput>
  }

  export type player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput = {
    create?: XOR<player_namelocksCreateWithoutPlayers_player_namelocks_player_idToplayersInput, player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_player_idToplayersInput>
    connectOrCreate?: player_namelocksCreateOrConnectWithoutPlayers_player_namelocks_player_idToplayersInput
    upsert?: player_namelocksUpsertWithoutPlayers_player_namelocks_player_idToplayersInput
    disconnect?: boolean
    delete?: boolean
    connect?: player_namelocksWhereUniqueInput
    update?: XOR<player_namelocksUpdateWithoutPlayers_player_namelocks_player_idToplayersInput, player_namelocksUncheckedUpdateWithoutPlayers_player_namelocks_player_idToplayersInput>
  }

  export type player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput = {
    create?: XOR<Enumerable<player_namelocksCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput>, Enumerable<player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput>>
    connectOrCreate?: Enumerable<player_namelocksCreateOrConnectWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
    upsert?: Enumerable<player_namelocksUpsertWithWhereUniqueWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
    createMany?: player_namelocksCreateManyPlayers_player_namelocks_namelocked_byToplayersInputEnvelope
    set?: Enumerable<player_namelocksWhereUniqueInput>
    disconnect?: Enumerable<player_namelocksWhereUniqueInput>
    delete?: Enumerable<player_namelocksWhereUniqueInput>
    connect?: Enumerable<player_namelocksWhereUniqueInput>
    update?: Enumerable<player_namelocksUpdateWithWhereUniqueWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
    updateMany?: Enumerable<player_namelocksUpdateManyWithWhereWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
    deleteMany?: Enumerable<player_namelocksScalarWhereInput>
  }

  export type player_storageUncheckedUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<player_storageCreateWithoutPlayersInput>, Enumerable<player_storageUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_storageCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<player_storageUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: player_storageCreateManyPlayersInputEnvelope
    set?: Enumerable<player_storageWhereUniqueInput>
    disconnect?: Enumerable<player_storageWhereUniqueInput>
    delete?: Enumerable<player_storageWhereUniqueInput>
    connect?: Enumerable<player_storageWhereUniqueInput>
    update?: Enumerable<player_storageUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<player_storageUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<player_storageScalarWhereInput>
  }

  export type player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput = {
    create?: XOR<Enumerable<player_storeinboxitemsCreateWithoutPlayersInput>, Enumerable<player_storeinboxitemsUncheckedCreateWithoutPlayersInput>>
    connectOrCreate?: Enumerable<player_storeinboxitemsCreateOrConnectWithoutPlayersInput>
    upsert?: Enumerable<player_storeinboxitemsUpsertWithWhereUniqueWithoutPlayersInput>
    createMany?: player_storeinboxitemsCreateManyPlayersInputEnvelope
    set?: Enumerable<player_storeinboxitemsWhereUniqueInput>
    disconnect?: Enumerable<player_storeinboxitemsWhereUniqueInput>
    delete?: Enumerable<player_storeinboxitemsWhereUniqueInput>
    connect?: Enumerable<player_storeinboxitemsWhereUniqueInput>
    update?: Enumerable<player_storeinboxitemsUpdateWithWhereUniqueWithoutPlayersInput>
    updateMany?: Enumerable<player_storeinboxitemsUpdateManyWithWhereWithoutPlayersInput>
    deleteMany?: Enumerable<player_storeinboxitemsScalarWhereInput>
  }

  export type AccountCreateNestedOneWithoutAccount_ban_historyInput = {
    create?: XOR<AccountCreateWithoutAccount_ban_historyInput, AccountUncheckedCreateWithoutAccount_ban_historyInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_ban_historyInput
    connect?: AccountWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutAccount_ban_historyInput = {
    create?: XOR<PlayerCreateWithoutAccount_ban_historyInput, PlayerUncheckedCreateWithoutAccount_ban_historyInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutAccount_ban_historyInput
    connect?: PlayerWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAccount_ban_historyNestedInput = {
    create?: XOR<AccountCreateWithoutAccount_ban_historyInput, AccountUncheckedCreateWithoutAccount_ban_historyInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_ban_historyInput
    upsert?: AccountUpsertWithoutAccount_ban_historyInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutAccount_ban_historyInput, AccountUncheckedUpdateWithoutAccount_ban_historyInput>
  }

  export type PlayerUpdateOneRequiredWithoutAccount_ban_historyNestedInput = {
    create?: XOR<PlayerCreateWithoutAccount_ban_historyInput, PlayerUncheckedCreateWithoutAccount_ban_historyInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutAccount_ban_historyInput
    upsert?: PlayerUpsertWithoutAccount_ban_historyInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutAccount_ban_historyInput, PlayerUncheckedUpdateWithoutAccount_ban_historyInput>
  }

  export type AccountCreateNestedOneWithoutAccount_bansInput = {
    create?: XOR<AccountCreateWithoutAccount_bansInput, AccountUncheckedCreateWithoutAccount_bansInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_bansInput
    connect?: AccountWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutAccount_bansInput = {
    create?: XOR<PlayerCreateWithoutAccount_bansInput, PlayerUncheckedCreateWithoutAccount_bansInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutAccount_bansInput
    connect?: PlayerWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAccount_bansNestedInput = {
    create?: XOR<AccountCreateWithoutAccount_bansInput, AccountUncheckedCreateWithoutAccount_bansInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_bansInput
    upsert?: AccountUpsertWithoutAccount_bansInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutAccount_bansInput, AccountUncheckedUpdateWithoutAccount_bansInput>
  }

  export type PlayerUpdateOneRequiredWithoutAccount_bansNestedInput = {
    create?: XOR<PlayerCreateWithoutAccount_bansInput, PlayerUncheckedCreateWithoutAccount_bansInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutAccount_bansInput
    upsert?: PlayerUpsertWithoutAccount_bansInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutAccount_bansInput, PlayerUncheckedUpdateWithoutAccount_bansInput>
  }

  export type AccountCreateNestedOneWithoutAccount_storageInput = {
    create?: XOR<AccountCreateWithoutAccount_storageInput, AccountUncheckedCreateWithoutAccount_storageInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_storageInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAccount_storageNestedInput = {
    create?: XOR<AccountCreateWithoutAccount_storageInput, AccountUncheckedCreateWithoutAccount_storageInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_storageInput
    upsert?: AccountUpsertWithoutAccount_storageInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutAccount_storageInput, AccountUncheckedUpdateWithoutAccount_storageInput>
  }

  export type AccountCreateNestedOneWithoutAccount_viplistInput = {
    create?: XOR<AccountCreateWithoutAccount_viplistInput, AccountUncheckedCreateWithoutAccount_viplistInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_viplistInput
    connect?: AccountWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutAccount_viplistInput = {
    create?: XOR<PlayerCreateWithoutAccount_viplistInput, PlayerUncheckedCreateWithoutAccount_viplistInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutAccount_viplistInput
    connect?: PlayerWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAccount_viplistNestedInput = {
    create?: XOR<AccountCreateWithoutAccount_viplistInput, AccountUncheckedCreateWithoutAccount_viplistInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccount_viplistInput
    upsert?: AccountUpsertWithoutAccount_viplistInput
    connect?: AccountWhereUniqueInput
    update?: XOR<AccountUpdateWithoutAccount_viplistInput, AccountUncheckedUpdateWithoutAccount_viplistInput>
  }

  export type PlayerUpdateOneRequiredWithoutAccount_viplistNestedInput = {
    create?: XOR<PlayerCreateWithoutAccount_viplistInput, PlayerUncheckedCreateWithoutAccount_viplistInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutAccount_viplistInput
    upsert?: PlayerUpsertWithoutAccount_viplistInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutAccount_viplistInput, PlayerUncheckedUpdateWithoutAccount_viplistInput>
  }

  export type PlayerCreateNestedOneWithoutGuild_invitesInput = {
    create?: XOR<PlayerCreateWithoutGuild_invitesInput, PlayerUncheckedCreateWithoutGuild_invitesInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutGuild_invitesInput
    connect?: PlayerWhereUniqueInput
  }

  export type guildsCreateNestedOneWithoutGuild_invitesInput = {
    create?: XOR<guildsCreateWithoutGuild_invitesInput, guildsUncheckedCreateWithoutGuild_invitesInput>
    connectOrCreate?: guildsCreateOrConnectWithoutGuild_invitesInput
    connect?: guildsWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutGuild_invitesNestedInput = {
    create?: XOR<PlayerCreateWithoutGuild_invitesInput, PlayerUncheckedCreateWithoutGuild_invitesInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutGuild_invitesInput
    upsert?: PlayerUpsertWithoutGuild_invitesInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutGuild_invitesInput, PlayerUncheckedUpdateWithoutGuild_invitesInput>
  }

  export type guildsUpdateOneRequiredWithoutGuild_invitesNestedInput = {
    create?: XOR<guildsCreateWithoutGuild_invitesInput, guildsUncheckedCreateWithoutGuild_invitesInput>
    connectOrCreate?: guildsCreateOrConnectWithoutGuild_invitesInput
    upsert?: guildsUpsertWithoutGuild_invitesInput
    connect?: guildsWhereUniqueInput
    update?: XOR<guildsUpdateWithoutGuild_invitesInput, guildsUncheckedUpdateWithoutGuild_invitesInput>
  }

  export type PlayerCreateNestedOneWithoutGuild_membershipInput = {
    create?: XOR<PlayerCreateWithoutGuild_membershipInput, PlayerUncheckedCreateWithoutGuild_membershipInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutGuild_membershipInput
    connect?: PlayerWhereUniqueInput
  }

  export type guildsCreateNestedOneWithoutGuild_membershipInput = {
    create?: XOR<guildsCreateWithoutGuild_membershipInput, guildsUncheckedCreateWithoutGuild_membershipInput>
    connectOrCreate?: guildsCreateOrConnectWithoutGuild_membershipInput
    connect?: guildsWhereUniqueInput
  }

  export type guild_ranksCreateNestedOneWithoutGuild_membershipInput = {
    create?: XOR<guild_ranksCreateWithoutGuild_membershipInput, guild_ranksUncheckedCreateWithoutGuild_membershipInput>
    connectOrCreate?: guild_ranksCreateOrConnectWithoutGuild_membershipInput
    connect?: guild_ranksWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutGuild_membershipNestedInput = {
    create?: XOR<PlayerCreateWithoutGuild_membershipInput, PlayerUncheckedCreateWithoutGuild_membershipInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutGuild_membershipInput
    upsert?: PlayerUpsertWithoutGuild_membershipInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutGuild_membershipInput, PlayerUncheckedUpdateWithoutGuild_membershipInput>
  }

  export type guildsUpdateOneRequiredWithoutGuild_membershipNestedInput = {
    create?: XOR<guildsCreateWithoutGuild_membershipInput, guildsUncheckedCreateWithoutGuild_membershipInput>
    connectOrCreate?: guildsCreateOrConnectWithoutGuild_membershipInput
    upsert?: guildsUpsertWithoutGuild_membershipInput
    connect?: guildsWhereUniqueInput
    update?: XOR<guildsUpdateWithoutGuild_membershipInput, guildsUncheckedUpdateWithoutGuild_membershipInput>
  }

  export type guild_ranksUpdateOneRequiredWithoutGuild_membershipNestedInput = {
    create?: XOR<guild_ranksCreateWithoutGuild_membershipInput, guild_ranksUncheckedCreateWithoutGuild_membershipInput>
    connectOrCreate?: guild_ranksCreateOrConnectWithoutGuild_membershipInput
    upsert?: guild_ranksUpsertWithoutGuild_membershipInput
    connect?: guild_ranksWhereUniqueInput
    update?: XOR<guild_ranksUpdateWithoutGuild_membershipInput, guild_ranksUncheckedUpdateWithoutGuild_membershipInput>
  }

  export type guild_membershipCreateNestedManyWithoutGuild_ranksInput = {
    create?: XOR<Enumerable<guild_membershipCreateWithoutGuild_ranksInput>, Enumerable<guild_membershipUncheckedCreateWithoutGuild_ranksInput>>
    connectOrCreate?: Enumerable<guild_membershipCreateOrConnectWithoutGuild_ranksInput>
    createMany?: guild_membershipCreateManyGuild_ranksInputEnvelope
    connect?: Enumerable<guild_membershipWhereUniqueInput>
  }

  export type guildsCreateNestedOneWithoutGuild_ranksInput = {
    create?: XOR<guildsCreateWithoutGuild_ranksInput, guildsUncheckedCreateWithoutGuild_ranksInput>
    connectOrCreate?: guildsCreateOrConnectWithoutGuild_ranksInput
    connect?: guildsWhereUniqueInput
  }

  export type guild_membershipUncheckedCreateNestedManyWithoutGuild_ranksInput = {
    create?: XOR<Enumerable<guild_membershipCreateWithoutGuild_ranksInput>, Enumerable<guild_membershipUncheckedCreateWithoutGuild_ranksInput>>
    connectOrCreate?: Enumerable<guild_membershipCreateOrConnectWithoutGuild_ranksInput>
    createMany?: guild_membershipCreateManyGuild_ranksInputEnvelope
    connect?: Enumerable<guild_membershipWhereUniqueInput>
  }

  export type guild_membershipUpdateManyWithoutGuild_ranksNestedInput = {
    create?: XOR<Enumerable<guild_membershipCreateWithoutGuild_ranksInput>, Enumerable<guild_membershipUncheckedCreateWithoutGuild_ranksInput>>
    connectOrCreate?: Enumerable<guild_membershipCreateOrConnectWithoutGuild_ranksInput>
    upsert?: Enumerable<guild_membershipUpsertWithWhereUniqueWithoutGuild_ranksInput>
    createMany?: guild_membershipCreateManyGuild_ranksInputEnvelope
    set?: Enumerable<guild_membershipWhereUniqueInput>
    disconnect?: Enumerable<guild_membershipWhereUniqueInput>
    delete?: Enumerable<guild_membershipWhereUniqueInput>
    connect?: Enumerable<guild_membershipWhereUniqueInput>
    update?: Enumerable<guild_membershipUpdateWithWhereUniqueWithoutGuild_ranksInput>
    updateMany?: Enumerable<guild_membershipUpdateManyWithWhereWithoutGuild_ranksInput>
    deleteMany?: Enumerable<guild_membershipScalarWhereInput>
  }

  export type guildsUpdateOneRequiredWithoutGuild_ranksNestedInput = {
    create?: XOR<guildsCreateWithoutGuild_ranksInput, guildsUncheckedCreateWithoutGuild_ranksInput>
    connectOrCreate?: guildsCreateOrConnectWithoutGuild_ranksInput
    upsert?: guildsUpsertWithoutGuild_ranksInput
    connect?: guildsWhereUniqueInput
    update?: XOR<guildsUpdateWithoutGuild_ranksInput, guildsUncheckedUpdateWithoutGuild_ranksInput>
  }

  export type guild_membershipUncheckedUpdateManyWithoutGuild_ranksNestedInput = {
    create?: XOR<Enumerable<guild_membershipCreateWithoutGuild_ranksInput>, Enumerable<guild_membershipUncheckedCreateWithoutGuild_ranksInput>>
    connectOrCreate?: Enumerable<guild_membershipCreateOrConnectWithoutGuild_ranksInput>
    upsert?: Enumerable<guild_membershipUpsertWithWhereUniqueWithoutGuild_ranksInput>
    createMany?: guild_membershipCreateManyGuild_ranksInputEnvelope
    set?: Enumerable<guild_membershipWhereUniqueInput>
    disconnect?: Enumerable<guild_membershipWhereUniqueInput>
    delete?: Enumerable<guild_membershipWhereUniqueInput>
    connect?: Enumerable<guild_membershipWhereUniqueInput>
    update?: Enumerable<guild_membershipUpdateWithWhereUniqueWithoutGuild_ranksInput>
    updateMany?: Enumerable<guild_membershipUpdateManyWithWhereWithoutGuild_ranksInput>
    deleteMany?: Enumerable<guild_membershipScalarWhereInput>
  }

  export type guildwar_killsCreateNestedManyWithoutGuild_warsInput = {
    create?: XOR<Enumerable<guildwar_killsCreateWithoutGuild_warsInput>, Enumerable<guildwar_killsUncheckedCreateWithoutGuild_warsInput>>
    connectOrCreate?: Enumerable<guildwar_killsCreateOrConnectWithoutGuild_warsInput>
    createMany?: guildwar_killsCreateManyGuild_warsInputEnvelope
    connect?: Enumerable<guildwar_killsWhereUniqueInput>
  }

  export type guildwar_killsUncheckedCreateNestedManyWithoutGuild_warsInput = {
    create?: XOR<Enumerable<guildwar_killsCreateWithoutGuild_warsInput>, Enumerable<guildwar_killsUncheckedCreateWithoutGuild_warsInput>>
    connectOrCreate?: Enumerable<guildwar_killsCreateOrConnectWithoutGuild_warsInput>
    createMany?: guildwar_killsCreateManyGuild_warsInputEnvelope
    connect?: Enumerable<guildwar_killsWhereUniqueInput>
  }

  export type guildwar_killsUpdateManyWithoutGuild_warsNestedInput = {
    create?: XOR<Enumerable<guildwar_killsCreateWithoutGuild_warsInput>, Enumerable<guildwar_killsUncheckedCreateWithoutGuild_warsInput>>
    connectOrCreate?: Enumerable<guildwar_killsCreateOrConnectWithoutGuild_warsInput>
    upsert?: Enumerable<guildwar_killsUpsertWithWhereUniqueWithoutGuild_warsInput>
    createMany?: guildwar_killsCreateManyGuild_warsInputEnvelope
    set?: Enumerable<guildwar_killsWhereUniqueInput>
    disconnect?: Enumerable<guildwar_killsWhereUniqueInput>
    delete?: Enumerable<guildwar_killsWhereUniqueInput>
    connect?: Enumerable<guildwar_killsWhereUniqueInput>
    update?: Enumerable<guildwar_killsUpdateWithWhereUniqueWithoutGuild_warsInput>
    updateMany?: Enumerable<guildwar_killsUpdateManyWithWhereWithoutGuild_warsInput>
    deleteMany?: Enumerable<guildwar_killsScalarWhereInput>
  }

  export type guildwar_killsUncheckedUpdateManyWithoutGuild_warsNestedInput = {
    create?: XOR<Enumerable<guildwar_killsCreateWithoutGuild_warsInput>, Enumerable<guildwar_killsUncheckedCreateWithoutGuild_warsInput>>
    connectOrCreate?: Enumerable<guildwar_killsCreateOrConnectWithoutGuild_warsInput>
    upsert?: Enumerable<guildwar_killsUpsertWithWhereUniqueWithoutGuild_warsInput>
    createMany?: guildwar_killsCreateManyGuild_warsInputEnvelope
    set?: Enumerable<guildwar_killsWhereUniqueInput>
    disconnect?: Enumerable<guildwar_killsWhereUniqueInput>
    delete?: Enumerable<guildwar_killsWhereUniqueInput>
    connect?: Enumerable<guildwar_killsWhereUniqueInput>
    update?: Enumerable<guildwar_killsUpdateWithWhereUniqueWithoutGuild_warsInput>
    updateMany?: Enumerable<guildwar_killsUpdateManyWithWhereWithoutGuild_warsInput>
    deleteMany?: Enumerable<guildwar_killsScalarWhereInput>
  }

  export type guild_invitesCreateNestedManyWithoutGuildsInput = {
    create?: XOR<Enumerable<guild_invitesCreateWithoutGuildsInput>, Enumerable<guild_invitesUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<guild_invitesCreateOrConnectWithoutGuildsInput>
    createMany?: guild_invitesCreateManyGuildsInputEnvelope
    connect?: Enumerable<guild_invitesWhereUniqueInput>
  }

  export type guild_membershipCreateNestedManyWithoutGuildsInput = {
    create?: XOR<Enumerable<guild_membershipCreateWithoutGuildsInput>, Enumerable<guild_membershipUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<guild_membershipCreateOrConnectWithoutGuildsInput>
    createMany?: guild_membershipCreateManyGuildsInputEnvelope
    connect?: Enumerable<guild_membershipWhereUniqueInput>
  }

  export type guild_ranksCreateNestedManyWithoutGuildsInput = {
    create?: XOR<Enumerable<guild_ranksCreateWithoutGuildsInput>, Enumerable<guild_ranksUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<guild_ranksCreateOrConnectWithoutGuildsInput>
    createMany?: guild_ranksCreateManyGuildsInputEnvelope
    connect?: Enumerable<guild_ranksWhereUniqueInput>
  }

  export type PlayerCreateNestedOneWithoutGuildsInput = {
    create?: XOR<PlayerCreateWithoutGuildsInput, PlayerUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutGuildsInput
    connect?: PlayerWhereUniqueInput
  }

  export type guild_invitesUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<Enumerable<guild_invitesCreateWithoutGuildsInput>, Enumerable<guild_invitesUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<guild_invitesCreateOrConnectWithoutGuildsInput>
    createMany?: guild_invitesCreateManyGuildsInputEnvelope
    connect?: Enumerable<guild_invitesWhereUniqueInput>
  }

  export type guild_membershipUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<Enumerable<guild_membershipCreateWithoutGuildsInput>, Enumerable<guild_membershipUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<guild_membershipCreateOrConnectWithoutGuildsInput>
    createMany?: guild_membershipCreateManyGuildsInputEnvelope
    connect?: Enumerable<guild_membershipWhereUniqueInput>
  }

  export type guild_ranksUncheckedCreateNestedManyWithoutGuildsInput = {
    create?: XOR<Enumerable<guild_ranksCreateWithoutGuildsInput>, Enumerable<guild_ranksUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<guild_ranksCreateOrConnectWithoutGuildsInput>
    createMany?: guild_ranksCreateManyGuildsInputEnvelope
    connect?: Enumerable<guild_ranksWhereUniqueInput>
  }

  export type guild_invitesUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<Enumerable<guild_invitesCreateWithoutGuildsInput>, Enumerable<guild_invitesUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<guild_invitesCreateOrConnectWithoutGuildsInput>
    upsert?: Enumerable<guild_invitesUpsertWithWhereUniqueWithoutGuildsInput>
    createMany?: guild_invitesCreateManyGuildsInputEnvelope
    set?: Enumerable<guild_invitesWhereUniqueInput>
    disconnect?: Enumerable<guild_invitesWhereUniqueInput>
    delete?: Enumerable<guild_invitesWhereUniqueInput>
    connect?: Enumerable<guild_invitesWhereUniqueInput>
    update?: Enumerable<guild_invitesUpdateWithWhereUniqueWithoutGuildsInput>
    updateMany?: Enumerable<guild_invitesUpdateManyWithWhereWithoutGuildsInput>
    deleteMany?: Enumerable<guild_invitesScalarWhereInput>
  }

  export type guild_membershipUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<Enumerable<guild_membershipCreateWithoutGuildsInput>, Enumerable<guild_membershipUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<guild_membershipCreateOrConnectWithoutGuildsInput>
    upsert?: Enumerable<guild_membershipUpsertWithWhereUniqueWithoutGuildsInput>
    createMany?: guild_membershipCreateManyGuildsInputEnvelope
    set?: Enumerable<guild_membershipWhereUniqueInput>
    disconnect?: Enumerable<guild_membershipWhereUniqueInput>
    delete?: Enumerable<guild_membershipWhereUniqueInput>
    connect?: Enumerable<guild_membershipWhereUniqueInput>
    update?: Enumerable<guild_membershipUpdateWithWhereUniqueWithoutGuildsInput>
    updateMany?: Enumerable<guild_membershipUpdateManyWithWhereWithoutGuildsInput>
    deleteMany?: Enumerable<guild_membershipScalarWhereInput>
  }

  export type guild_ranksUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<Enumerable<guild_ranksCreateWithoutGuildsInput>, Enumerable<guild_ranksUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<guild_ranksCreateOrConnectWithoutGuildsInput>
    upsert?: Enumerable<guild_ranksUpsertWithWhereUniqueWithoutGuildsInput>
    createMany?: guild_ranksCreateManyGuildsInputEnvelope
    set?: Enumerable<guild_ranksWhereUniqueInput>
    disconnect?: Enumerable<guild_ranksWhereUniqueInput>
    delete?: Enumerable<guild_ranksWhereUniqueInput>
    connect?: Enumerable<guild_ranksWhereUniqueInput>
    update?: Enumerable<guild_ranksUpdateWithWhereUniqueWithoutGuildsInput>
    updateMany?: Enumerable<guild_ranksUpdateManyWithWhereWithoutGuildsInput>
    deleteMany?: Enumerable<guild_ranksScalarWhereInput>
  }

  export type PlayerUpdateOneRequiredWithoutGuildsNestedInput = {
    create?: XOR<PlayerCreateWithoutGuildsInput, PlayerUncheckedCreateWithoutGuildsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutGuildsInput
    upsert?: PlayerUpsertWithoutGuildsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutGuildsInput, PlayerUncheckedUpdateWithoutGuildsInput>
  }

  export type guild_invitesUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<Enumerable<guild_invitesCreateWithoutGuildsInput>, Enumerable<guild_invitesUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<guild_invitesCreateOrConnectWithoutGuildsInput>
    upsert?: Enumerable<guild_invitesUpsertWithWhereUniqueWithoutGuildsInput>
    createMany?: guild_invitesCreateManyGuildsInputEnvelope
    set?: Enumerable<guild_invitesWhereUniqueInput>
    disconnect?: Enumerable<guild_invitesWhereUniqueInput>
    delete?: Enumerable<guild_invitesWhereUniqueInput>
    connect?: Enumerable<guild_invitesWhereUniqueInput>
    update?: Enumerable<guild_invitesUpdateWithWhereUniqueWithoutGuildsInput>
    updateMany?: Enumerable<guild_invitesUpdateManyWithWhereWithoutGuildsInput>
    deleteMany?: Enumerable<guild_invitesScalarWhereInput>
  }

  export type guild_membershipUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<Enumerable<guild_membershipCreateWithoutGuildsInput>, Enumerable<guild_membershipUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<guild_membershipCreateOrConnectWithoutGuildsInput>
    upsert?: Enumerable<guild_membershipUpsertWithWhereUniqueWithoutGuildsInput>
    createMany?: guild_membershipCreateManyGuildsInputEnvelope
    set?: Enumerable<guild_membershipWhereUniqueInput>
    disconnect?: Enumerable<guild_membershipWhereUniqueInput>
    delete?: Enumerable<guild_membershipWhereUniqueInput>
    connect?: Enumerable<guild_membershipWhereUniqueInput>
    update?: Enumerable<guild_membershipUpdateWithWhereUniqueWithoutGuildsInput>
    updateMany?: Enumerable<guild_membershipUpdateManyWithWhereWithoutGuildsInput>
    deleteMany?: Enumerable<guild_membershipScalarWhereInput>
  }

  export type guild_ranksUncheckedUpdateManyWithoutGuildsNestedInput = {
    create?: XOR<Enumerable<guild_ranksCreateWithoutGuildsInput>, Enumerable<guild_ranksUncheckedCreateWithoutGuildsInput>>
    connectOrCreate?: Enumerable<guild_ranksCreateOrConnectWithoutGuildsInput>
    upsert?: Enumerable<guild_ranksUpsertWithWhereUniqueWithoutGuildsInput>
    createMany?: guild_ranksCreateManyGuildsInputEnvelope
    set?: Enumerable<guild_ranksWhereUniqueInput>
    disconnect?: Enumerable<guild_ranksWhereUniqueInput>
    delete?: Enumerable<guild_ranksWhereUniqueInput>
    connect?: Enumerable<guild_ranksWhereUniqueInput>
    update?: Enumerable<guild_ranksUpdateWithWhereUniqueWithoutGuildsInput>
    updateMany?: Enumerable<guild_ranksUpdateManyWithWhereWithoutGuildsInput>
    deleteMany?: Enumerable<guild_ranksScalarWhereInput>
  }

  export type guild_warsCreateNestedOneWithoutGuildwar_killsInput = {
    create?: XOR<guild_warsCreateWithoutGuildwar_killsInput, guild_warsUncheckedCreateWithoutGuildwar_killsInput>
    connectOrCreate?: guild_warsCreateOrConnectWithoutGuildwar_killsInput
    connect?: guild_warsWhereUniqueInput
  }

  export type guild_warsUpdateOneRequiredWithoutGuildwar_killsNestedInput = {
    create?: XOR<guild_warsCreateWithoutGuildwar_killsInput, guild_warsUncheckedCreateWithoutGuildwar_killsInput>
    connectOrCreate?: guild_warsCreateOrConnectWithoutGuildwar_killsInput
    upsert?: guild_warsUpsertWithoutGuildwar_killsInput
    connect?: guild_warsWhereUniqueInput
    update?: XOR<guild_warsUpdateWithoutGuildwar_killsInput, guild_warsUncheckedUpdateWithoutGuildwar_killsInput>
  }

  export type PlayerCreateNestedOneWithoutIp_bansInput = {
    create?: XOR<PlayerCreateWithoutIp_bansInput, PlayerUncheckedCreateWithoutIp_bansInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutIp_bansInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutIp_bansNestedInput = {
    create?: XOR<PlayerCreateWithoutIp_bansInput, PlayerUncheckedCreateWithoutIp_bansInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutIp_bansInput
    upsert?: PlayerUpsertWithoutIp_bansInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutIp_bansInput, PlayerUncheckedUpdateWithoutIp_bansInput>
  }

  export type PlayerCreateNestedOneWithoutMarket_historyInput = {
    create?: XOR<PlayerCreateWithoutMarket_historyInput, PlayerUncheckedCreateWithoutMarket_historyInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMarket_historyInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutMarket_historyNestedInput = {
    create?: XOR<PlayerCreateWithoutMarket_historyInput, PlayerUncheckedCreateWithoutMarket_historyInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMarket_historyInput
    upsert?: PlayerUpsertWithoutMarket_historyInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutMarket_historyInput, PlayerUncheckedUpdateWithoutMarket_historyInput>
  }

  export type PlayerCreateNestedOneWithoutMarket_offersInput = {
    create?: XOR<PlayerCreateWithoutMarket_offersInput, PlayerUncheckedCreateWithoutMarket_offersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMarket_offersInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutMarket_offersNestedInput = {
    create?: XOR<PlayerCreateWithoutMarket_offersInput, PlayerUncheckedCreateWithoutMarket_offersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMarket_offersInput
    upsert?: PlayerUpsertWithoutMarket_offersInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutMarket_offersInput, PlayerUncheckedUpdateWithoutMarket_offersInput>
  }

  export type PlayerCreateNestedOneWithoutPlayer_depotitemsInput = {
    create?: XOR<PlayerCreateWithoutPlayer_depotitemsInput, PlayerUncheckedCreateWithoutPlayer_depotitemsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_depotitemsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutPlayer_depotitemsNestedInput = {
    create?: XOR<PlayerCreateWithoutPlayer_depotitemsInput, PlayerUncheckedCreateWithoutPlayer_depotitemsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_depotitemsInput
    upsert?: PlayerUpsertWithoutPlayer_depotitemsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutPlayer_depotitemsInput, PlayerUncheckedUpdateWithoutPlayer_depotitemsInput>
  }

  export type PlayerCreateNestedOneWithoutPlayer_inboxitemsInput = {
    create?: XOR<PlayerCreateWithoutPlayer_inboxitemsInput, PlayerUncheckedCreateWithoutPlayer_inboxitemsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_inboxitemsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutPlayer_inboxitemsNestedInput = {
    create?: XOR<PlayerCreateWithoutPlayer_inboxitemsInput, PlayerUncheckedCreateWithoutPlayer_inboxitemsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_inboxitemsInput
    upsert?: PlayerUpsertWithoutPlayer_inboxitemsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutPlayer_inboxitemsInput, PlayerUncheckedUpdateWithoutPlayer_inboxitemsInput>
  }

  export type PlayerCreateNestedOneWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput = {
    create?: XOR<PlayerCreateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput, PlayerUncheckedCreateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput = {
    create?: XOR<PlayerCreateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput, PlayerUncheckedCreateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutPlayer_namelocks_player_namelocks_player_idToplayersNestedInput = {
    create?: XOR<PlayerCreateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput, PlayerUncheckedCreateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput
    upsert?: PlayerUpsertWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput, PlayerUncheckedUpdateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput>
  }

  export type PlayerUpdateOneRequiredWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersNestedInput = {
    create?: XOR<PlayerCreateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput, PlayerUncheckedCreateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput
    upsert?: PlayerUpsertWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput, PlayerUncheckedUpdateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput>
  }

  export type PlayerCreateNestedOneWithoutPlayer_storageInput = {
    create?: XOR<PlayerCreateWithoutPlayer_storageInput, PlayerUncheckedCreateWithoutPlayer_storageInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_storageInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutPlayer_storageNestedInput = {
    create?: XOR<PlayerCreateWithoutPlayer_storageInput, PlayerUncheckedCreateWithoutPlayer_storageInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_storageInput
    upsert?: PlayerUpsertWithoutPlayer_storageInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutPlayer_storageInput, PlayerUncheckedUpdateWithoutPlayer_storageInput>
  }

  export type PlayerCreateNestedOneWithoutPlayer_storeinboxitemsInput = {
    create?: XOR<PlayerCreateWithoutPlayer_storeinboxitemsInput, PlayerUncheckedCreateWithoutPlayer_storeinboxitemsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_storeinboxitemsInput
    connect?: PlayerWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutPlayer_storeinboxitemsNestedInput = {
    create?: XOR<PlayerCreateWithoutPlayer_storeinboxitemsInput, PlayerUncheckedCreateWithoutPlayer_storeinboxitemsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPlayer_storeinboxitemsInput
    upsert?: PlayerUpsertWithoutPlayer_storeinboxitemsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<PlayerUpdateWithoutPlayer_storeinboxitemsInput, PlayerUncheckedUpdateWithoutPlayer_storeinboxitemsInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedBytesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer> | Buffer
    notIn?: Enumerable<Buffer> | Buffer
    not?: NestedBytesFilter | Buffer
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number> | bigint | number
    notIn?: Enumerable<bigint> | Enumerable<number> | bigint | number
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedBytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer> | Buffer
    notIn?: Enumerable<Buffer> | Buffer
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type account_ban_historyCreateWithoutAccountsInput = {
    reason: string
    banned_at: bigint | number
    expired_at: bigint | number
    players: PlayerCreateNestedOneWithoutAccount_ban_historyInput
  }

  export type account_ban_historyUncheckedCreateWithoutAccountsInput = {
    id?: number
    reason: string
    banned_at: bigint | number
    expired_at: bigint | number
    banned_by: number
  }

  export type account_ban_historyCreateOrConnectWithoutAccountsInput = {
    where: account_ban_historyWhereUniqueInput
    create: XOR<account_ban_historyCreateWithoutAccountsInput, account_ban_historyUncheckedCreateWithoutAccountsInput>
  }

  export type account_ban_historyCreateManyAccountsInputEnvelope = {
    data: Enumerable<account_ban_historyCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type account_bansCreateWithoutAccountsInput = {
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
    players: PlayerCreateNestedOneWithoutAccount_bansInput
  }

  export type account_bansUncheckedCreateWithoutAccountsInput = {
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
    banned_by: number
  }

  export type account_bansCreateOrConnectWithoutAccountsInput = {
    where: account_bansWhereUniqueInput
    create: XOR<account_bansCreateWithoutAccountsInput, account_bansUncheckedCreateWithoutAccountsInput>
  }

  export type account_storageCreateWithoutAccountsInput = {
    key: number
    value: number
  }

  export type account_storageUncheckedCreateWithoutAccountsInput = {
    key: number
    value: number
  }

  export type account_storageCreateOrConnectWithoutAccountsInput = {
    where: account_storageWhereUniqueInput
    create: XOR<account_storageCreateWithoutAccountsInput, account_storageUncheckedCreateWithoutAccountsInput>
  }

  export type account_storageCreateManyAccountsInputEnvelope = {
    data: Enumerable<account_storageCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type account_viplistCreateWithoutAccountsInput = {
    description?: string
    icon?: number
    notify?: boolean
    players: PlayerCreateNestedOneWithoutAccount_viplistInput
  }

  export type account_viplistUncheckedCreateWithoutAccountsInput = {
    player_id: number
    description?: string
    icon?: number
    notify?: boolean
  }

  export type account_viplistCreateOrConnectWithoutAccountsInput = {
    where: account_viplistWhereUniqueInput
    create: XOR<account_viplistCreateWithoutAccountsInput, account_viplistUncheckedCreateWithoutAccountsInput>
  }

  export type account_viplistCreateManyAccountsInputEnvelope = {
    data: Enumerable<account_viplistCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type PlayerCreateWithoutAccountsInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutAccountsInput = {
    id?: number
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutAccountsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutAccountsInput, PlayerUncheckedCreateWithoutAccountsInput>
  }

  export type PlayerCreateManyAccountsInputEnvelope = {
    data: Enumerable<PlayerCreateManyAccountsInput>
    skipDuplicates?: boolean
  }

  export type account_ban_historyUpsertWithWhereUniqueWithoutAccountsInput = {
    where: account_ban_historyWhereUniqueInput
    update: XOR<account_ban_historyUpdateWithoutAccountsInput, account_ban_historyUncheckedUpdateWithoutAccountsInput>
    create: XOR<account_ban_historyCreateWithoutAccountsInput, account_ban_historyUncheckedCreateWithoutAccountsInput>
  }

  export type account_ban_historyUpdateWithWhereUniqueWithoutAccountsInput = {
    where: account_ban_historyWhereUniqueInput
    data: XOR<account_ban_historyUpdateWithoutAccountsInput, account_ban_historyUncheckedUpdateWithoutAccountsInput>
  }

  export type account_ban_historyUpdateManyWithWhereWithoutAccountsInput = {
    where: account_ban_historyScalarWhereInput
    data: XOR<account_ban_historyUpdateManyMutationInput, account_ban_historyUncheckedUpdateManyWithoutAccount_ban_historyInput>
  }

  export type account_ban_historyScalarWhereInput = {
    AND?: Enumerable<account_ban_historyScalarWhereInput>
    OR?: Enumerable<account_ban_historyScalarWhereInput>
    NOT?: Enumerable<account_ban_historyScalarWhereInput>
    id?: IntFilter | number
    account_id?: IntFilter | number
    reason?: StringFilter | string
    banned_at?: BigIntFilter | bigint | number
    expired_at?: BigIntFilter | bigint | number
    banned_by?: IntFilter | number
  }

  export type account_bansUpsertWithoutAccountsInput = {
    update: XOR<account_bansUpdateWithoutAccountsInput, account_bansUncheckedUpdateWithoutAccountsInput>
    create: XOR<account_bansCreateWithoutAccountsInput, account_bansUncheckedCreateWithoutAccountsInput>
  }

  export type account_bansUpdateWithoutAccountsInput = {
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    players?: PlayerUpdateOneRequiredWithoutAccount_bansNestedInput
  }

  export type account_bansUncheckedUpdateWithoutAccountsInput = {
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    banned_by?: IntFieldUpdateOperationsInput | number
  }

  export type account_storageUpsertWithWhereUniqueWithoutAccountsInput = {
    where: account_storageWhereUniqueInput
    update: XOR<account_storageUpdateWithoutAccountsInput, account_storageUncheckedUpdateWithoutAccountsInput>
    create: XOR<account_storageCreateWithoutAccountsInput, account_storageUncheckedCreateWithoutAccountsInput>
  }

  export type account_storageUpdateWithWhereUniqueWithoutAccountsInput = {
    where: account_storageWhereUniqueInput
    data: XOR<account_storageUpdateWithoutAccountsInput, account_storageUncheckedUpdateWithoutAccountsInput>
  }

  export type account_storageUpdateManyWithWhereWithoutAccountsInput = {
    where: account_storageScalarWhereInput
    data: XOR<account_storageUpdateManyMutationInput, account_storageUncheckedUpdateManyWithoutAccount_storageInput>
  }

  export type account_storageScalarWhereInput = {
    AND?: Enumerable<account_storageScalarWhereInput>
    OR?: Enumerable<account_storageScalarWhereInput>
    NOT?: Enumerable<account_storageScalarWhereInput>
    account_id?: IntFilter | number
    key?: IntFilter | number
    value?: IntFilter | number
  }

  export type account_viplistUpsertWithWhereUniqueWithoutAccountsInput = {
    where: account_viplistWhereUniqueInput
    update: XOR<account_viplistUpdateWithoutAccountsInput, account_viplistUncheckedUpdateWithoutAccountsInput>
    create: XOR<account_viplistCreateWithoutAccountsInput, account_viplistUncheckedCreateWithoutAccountsInput>
  }

  export type account_viplistUpdateWithWhereUniqueWithoutAccountsInput = {
    where: account_viplistWhereUniqueInput
    data: XOR<account_viplistUpdateWithoutAccountsInput, account_viplistUncheckedUpdateWithoutAccountsInput>
  }

  export type account_viplistUpdateManyWithWhereWithoutAccountsInput = {
    where: account_viplistScalarWhereInput
    data: XOR<account_viplistUpdateManyMutationInput, account_viplistUncheckedUpdateManyWithoutAccount_viplistInput>
  }

  export type account_viplistScalarWhereInput = {
    AND?: Enumerable<account_viplistScalarWhereInput>
    OR?: Enumerable<account_viplistScalarWhereInput>
    NOT?: Enumerable<account_viplistScalarWhereInput>
    account_id?: IntFilter | number
    player_id?: IntFilter | number
    description?: StringFilter | string
    icon?: IntFilter | number
    notify?: BoolFilter | boolean
  }

  export type PlayerUpsertWithWhereUniqueWithoutAccountsInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutAccountsInput, PlayerUncheckedUpdateWithoutAccountsInput>
    create: XOR<PlayerCreateWithoutAccountsInput, PlayerUncheckedCreateWithoutAccountsInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutAccountsInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutAccountsInput, PlayerUncheckedUpdateWithoutAccountsInput>
  }

  export type PlayerUpdateManyWithWhereWithoutAccountsInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutPlayersInput>
  }

  export type PlayerScalarWhereInput = {
    AND?: Enumerable<PlayerScalarWhereInput>
    OR?: Enumerable<PlayerScalarWhereInput>
    NOT?: Enumerable<PlayerScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    group_id?: IntFilter | number
    account_id?: IntFilter | number
    level?: IntFilter | number
    vocation?: IntFilter | number
    health?: IntFilter | number
    healthmax?: IntFilter | number
    experience?: BigIntFilter | bigint | number
    lookbody?: IntFilter | number
    lookfeet?: IntFilter | number
    lookhead?: IntFilter | number
    looklegs?: IntFilter | number
    looktype?: IntFilter | number
    lookaddons?: IntFilter | number
    direction?: IntFilter | number
    maglevel?: IntFilter | number
    mana?: IntFilter | number
    manamax?: IntFilter | number
    manaspent?: BigIntFilter | bigint | number
    soul?: IntFilter | number
    town_id?: IntFilter | number
    posx?: IntFilter | number
    posy?: IntFilter | number
    posz?: IntFilter | number
    conditions?: BytesFilter | Buffer
    cap?: IntFilter | number
    sex?: IntFilter | number
    lastlogin?: BigIntFilter | bigint | number
    lastip?: IntFilter | number
    save?: BoolFilter | boolean
    skull?: BoolFilter | boolean
    skulltime?: BigIntFilter | bigint | number
    lastlogout?: BigIntFilter | bigint | number
    blessings?: IntFilter | number
    onlinetime?: BigIntFilter | bigint | number
    deletion?: BigIntFilter | bigint | number
    balance?: BigIntFilter | bigint | number
    offlinetraining_time?: IntFilter | number
    offlinetraining_skill?: IntFilter | number
    stamina?: IntFilter | number
    skill_fist?: IntFilter | number
    skill_fist_tries?: BigIntFilter | bigint | number
    skill_club?: IntFilter | number
    skill_club_tries?: BigIntFilter | bigint | number
    skill_sword?: IntFilter | number
    skill_sword_tries?: BigIntFilter | bigint | number
    skill_axe?: IntFilter | number
    skill_axe_tries?: BigIntFilter | bigint | number
    skill_dist?: IntFilter | number
    skill_dist_tries?: BigIntFilter | bigint | number
    skill_shielding?: IntFilter | number
    skill_shielding_tries?: BigIntFilter | bigint | number
    skill_fishing?: IntFilter | number
    skill_fishing_tries?: BigIntFilter | bigint | number
    stat_str?: IntFilter | number
    stat_int?: IntFilter | number
    stat_dex?: IntFilter | number
    stat_vit?: IntFilter | number
    stat_spr?: IntFilter | number
    stat_wis?: IntFilter | number
  }

  export type account_ban_historyCreateWithoutPlayersInput = {
    reason: string
    banned_at: bigint | number
    expired_at: bigint | number
    accounts: AccountCreateNestedOneWithoutAccount_ban_historyInput
  }

  export type account_ban_historyUncheckedCreateWithoutPlayersInput = {
    id?: number
    account_id: number
    reason: string
    banned_at: bigint | number
    expired_at: bigint | number
  }

  export type account_ban_historyCreateOrConnectWithoutPlayersInput = {
    where: account_ban_historyWhereUniqueInput
    create: XOR<account_ban_historyCreateWithoutPlayersInput, account_ban_historyUncheckedCreateWithoutPlayersInput>
  }

  export type account_ban_historyCreateManyPlayersInputEnvelope = {
    data: Enumerable<account_ban_historyCreateManyPlayersInput>
    skipDuplicates?: boolean
  }

  export type account_bansCreateWithoutPlayersInput = {
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
    accounts: AccountCreateNestedOneWithoutAccount_bansInput
  }

  export type account_bansUncheckedCreateWithoutPlayersInput = {
    account_id: number
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
  }

  export type account_bansCreateOrConnectWithoutPlayersInput = {
    where: account_bansWhereUniqueInput
    create: XOR<account_bansCreateWithoutPlayersInput, account_bansUncheckedCreateWithoutPlayersInput>
  }

  export type account_bansCreateManyPlayersInputEnvelope = {
    data: Enumerable<account_bansCreateManyPlayersInput>
    skipDuplicates?: boolean
  }

  export type account_viplistCreateWithoutPlayersInput = {
    description?: string
    icon?: number
    notify?: boolean
    accounts: AccountCreateNestedOneWithoutAccount_viplistInput
  }

  export type account_viplistUncheckedCreateWithoutPlayersInput = {
    account_id: number
    description?: string
    icon?: number
    notify?: boolean
  }

  export type account_viplistCreateOrConnectWithoutPlayersInput = {
    where: account_viplistWhereUniqueInput
    create: XOR<account_viplistCreateWithoutPlayersInput, account_viplistUncheckedCreateWithoutPlayersInput>
  }

  export type account_viplistCreateManyPlayersInputEnvelope = {
    data: Enumerable<account_viplistCreateManyPlayersInput>
    skipDuplicates?: boolean
  }

  export type guild_invitesCreateWithoutPlayersInput = {
    guilds?: guildsCreateNestedOneWithoutGuild_invitesInput
  }

  export type guild_invitesUncheckedCreateWithoutPlayersInput = {
    guild_id?: number
  }

  export type guild_invitesCreateOrConnectWithoutPlayersInput = {
    where: guild_invitesWhereUniqueInput
    create: XOR<guild_invitesCreateWithoutPlayersInput, guild_invitesUncheckedCreateWithoutPlayersInput>
  }

  export type guild_invitesCreateManyPlayersInputEnvelope = {
    data: Enumerable<guild_invitesCreateManyPlayersInput>
    skipDuplicates?: boolean
  }

  export type guild_membershipCreateWithoutPlayersInput = {
    nick?: string
    guilds: guildsCreateNestedOneWithoutGuild_membershipInput
    guild_ranks: guild_ranksCreateNestedOneWithoutGuild_membershipInput
  }

  export type guild_membershipUncheckedCreateWithoutPlayersInput = {
    guild_id: number
    rank_id: number
    nick?: string
  }

  export type guild_membershipCreateOrConnectWithoutPlayersInput = {
    where: guild_membershipWhereUniqueInput
    create: XOR<guild_membershipCreateWithoutPlayersInput, guild_membershipUncheckedCreateWithoutPlayersInput>
  }

  export type guildsCreateWithoutPlayersInput = {
    name: string
    creationdata: number
    motd?: string
    guild_invites?: guild_invitesCreateNestedManyWithoutGuildsInput
    guild_membership?: guild_membershipCreateNestedManyWithoutGuildsInput
    guild_ranks?: guild_ranksCreateNestedManyWithoutGuildsInput
  }

  export type guildsUncheckedCreateWithoutPlayersInput = {
    id?: number
    name: string
    creationdata: number
    motd?: string
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutGuildsInput
    guild_membership?: guild_membershipUncheckedCreateNestedManyWithoutGuildsInput
    guild_ranks?: guild_ranksUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type guildsCreateOrConnectWithoutPlayersInput = {
    where: guildsWhereUniqueInput
    create: XOR<guildsCreateWithoutPlayersInput, guildsUncheckedCreateWithoutPlayersInput>
  }

  export type ip_bansCreateWithoutPlayersInput = {
    ip: number
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
  }

  export type ip_bansUncheckedCreateWithoutPlayersInput = {
    ip: number
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
  }

  export type ip_bansCreateOrConnectWithoutPlayersInput = {
    where: ip_bansWhereUniqueInput
    create: XOR<ip_bansCreateWithoutPlayersInput, ip_bansUncheckedCreateWithoutPlayersInput>
  }

  export type ip_bansCreateManyPlayersInputEnvelope = {
    data: Enumerable<ip_bansCreateManyPlayersInput>
    skipDuplicates?: boolean
  }

  export type market_historyCreateWithoutPlayersInput = {
    sale?: boolean
    itemtype: number
    amount: number
    price?: number
    expires_at: bigint | number
    inserted: bigint | number
    state: number
  }

  export type market_historyUncheckedCreateWithoutPlayersInput = {
    id?: number
    sale?: boolean
    itemtype: number
    amount: number
    price?: number
    expires_at: bigint | number
    inserted: bigint | number
    state: number
  }

  export type market_historyCreateOrConnectWithoutPlayersInput = {
    where: market_historyWhereUniqueInput
    create: XOR<market_historyCreateWithoutPlayersInput, market_historyUncheckedCreateWithoutPlayersInput>
  }

  export type market_historyCreateManyPlayersInputEnvelope = {
    data: Enumerable<market_historyCreateManyPlayersInput>
    skipDuplicates?: boolean
  }

  export type market_offersCreateWithoutPlayersInput = {
    sale?: boolean
    itemtype: number
    amount: number
    created: bigint | number
    anonymous?: boolean
    price?: number
  }

  export type market_offersUncheckedCreateWithoutPlayersInput = {
    id?: number
    sale?: boolean
    itemtype: number
    amount: number
    created: bigint | number
    anonymous?: boolean
    price?: number
  }

  export type market_offersCreateOrConnectWithoutPlayersInput = {
    where: market_offersWhereUniqueInput
    create: XOR<market_offersCreateWithoutPlayersInput, market_offersUncheckedCreateWithoutPlayersInput>
  }

  export type market_offersCreateManyPlayersInputEnvelope = {
    data: Enumerable<market_offersCreateManyPlayersInput>
    skipDuplicates?: boolean
  }

  export type player_depotitemsCreateWithoutPlayersInput = {
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_depotitemsUncheckedCreateWithoutPlayersInput = {
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_depotitemsCreateOrConnectWithoutPlayersInput = {
    where: player_depotitemsWhereUniqueInput
    create: XOR<player_depotitemsCreateWithoutPlayersInput, player_depotitemsUncheckedCreateWithoutPlayersInput>
  }

  export type player_depotitemsCreateManyPlayersInputEnvelope = {
    data: Enumerable<player_depotitemsCreateManyPlayersInput>
    skipDuplicates?: boolean
  }

  export type player_inboxitemsCreateWithoutPlayersInput = {
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_inboxitemsUncheckedCreateWithoutPlayersInput = {
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_inboxitemsCreateOrConnectWithoutPlayersInput = {
    where: player_inboxitemsWhereUniqueInput
    create: XOR<player_inboxitemsCreateWithoutPlayersInput, player_inboxitemsUncheckedCreateWithoutPlayersInput>
  }

  export type player_inboxitemsCreateManyPlayersInputEnvelope = {
    data: Enumerable<player_inboxitemsCreateManyPlayersInput>
    skipDuplicates?: boolean
  }

  export type player_namelocksCreateWithoutPlayers_player_namelocks_player_idToplayersInput = {
    reason: string
    namelocked_at: bigint | number
    players_player_namelocks_namelocked_byToplayers: PlayerCreateNestedOneWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput
  }

  export type player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_player_idToplayersInput = {
    reason: string
    namelocked_at: bigint | number
    namelocked_by: number
  }

  export type player_namelocksCreateOrConnectWithoutPlayers_player_namelocks_player_idToplayersInput = {
    where: player_namelocksWhereUniqueInput
    create: XOR<player_namelocksCreateWithoutPlayers_player_namelocks_player_idToplayersInput, player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_player_idToplayersInput>
  }

  export type player_namelocksCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput = {
    reason: string
    namelocked_at: bigint | number
    players_player_namelocks_player_idToplayers: PlayerCreateNestedOneWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput
  }

  export type player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput = {
    player_id: number
    reason: string
    namelocked_at: bigint | number
  }

  export type player_namelocksCreateOrConnectWithoutPlayers_player_namelocks_namelocked_byToplayersInput = {
    where: player_namelocksWhereUniqueInput
    create: XOR<player_namelocksCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput, player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
  }

  export type player_namelocksCreateManyPlayers_player_namelocks_namelocked_byToplayersInputEnvelope = {
    data: Enumerable<player_namelocksCreateManyPlayers_player_namelocks_namelocked_byToplayersInput>
    skipDuplicates?: boolean
  }

  export type player_storageCreateWithoutPlayersInput = {
    key?: number
    value?: number
  }

  export type player_storageUncheckedCreateWithoutPlayersInput = {
    key?: number
    value?: number
  }

  export type player_storageCreateOrConnectWithoutPlayersInput = {
    where: player_storageWhereUniqueInput
    create: XOR<player_storageCreateWithoutPlayersInput, player_storageUncheckedCreateWithoutPlayersInput>
  }

  export type player_storageCreateManyPlayersInputEnvelope = {
    data: Enumerable<player_storageCreateManyPlayersInput>
    skipDuplicates?: boolean
  }

  export type player_storeinboxitemsCreateWithoutPlayersInput = {
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_storeinboxitemsUncheckedCreateWithoutPlayersInput = {
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_storeinboxitemsCreateOrConnectWithoutPlayersInput = {
    where: player_storeinboxitemsWhereUniqueInput
    create: XOR<player_storeinboxitemsCreateWithoutPlayersInput, player_storeinboxitemsUncheckedCreateWithoutPlayersInput>
  }

  export type player_storeinboxitemsCreateManyPlayersInputEnvelope = {
    data: Enumerable<player_storeinboxitemsCreateManyPlayersInput>
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutPlayersInput = {
    name: string
    password: string
    secret?: string | null
    type?: number
    premium_ends_at?: number
    email?: string
    creation?: number
    premium_points?: number
    premdays: number
    wallet?: string | null
    alpha_key?: string | null
    account_ban_history?: account_ban_historyCreateNestedManyWithoutAccountsInput
    account_bans?: account_bansCreateNestedOneWithoutAccountsInput
    account_storage?: account_storageCreateNestedManyWithoutAccountsInput
    account_viplist?: account_viplistCreateNestedManyWithoutAccountsInput
  }

  export type AccountUncheckedCreateWithoutPlayersInput = {
    id?: number
    name: string
    password: string
    secret?: string | null
    type?: number
    premium_ends_at?: number
    email?: string
    creation?: number
    premium_points?: number
    premdays: number
    wallet?: string | null
    alpha_key?: string | null
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutAccountsInput
    account_bans?: account_bansUncheckedCreateNestedOneWithoutAccountsInput
    account_storage?: account_storageUncheckedCreateNestedManyWithoutAccountsInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type AccountCreateOrConnectWithoutPlayersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutPlayersInput, AccountUncheckedCreateWithoutPlayersInput>
  }

  export type account_ban_historyUpsertWithWhereUniqueWithoutPlayersInput = {
    where: account_ban_historyWhereUniqueInput
    update: XOR<account_ban_historyUpdateWithoutPlayersInput, account_ban_historyUncheckedUpdateWithoutPlayersInput>
    create: XOR<account_ban_historyCreateWithoutPlayersInput, account_ban_historyUncheckedCreateWithoutPlayersInput>
  }

  export type account_ban_historyUpdateWithWhereUniqueWithoutPlayersInput = {
    where: account_ban_historyWhereUniqueInput
    data: XOR<account_ban_historyUpdateWithoutPlayersInput, account_ban_historyUncheckedUpdateWithoutPlayersInput>
  }

  export type account_ban_historyUpdateManyWithWhereWithoutPlayersInput = {
    where: account_ban_historyScalarWhereInput
    data: XOR<account_ban_historyUpdateManyMutationInput, account_ban_historyUncheckedUpdateManyWithoutAccount_ban_historyInput>
  }

  export type account_bansUpsertWithWhereUniqueWithoutPlayersInput = {
    where: account_bansWhereUniqueInput
    update: XOR<account_bansUpdateWithoutPlayersInput, account_bansUncheckedUpdateWithoutPlayersInput>
    create: XOR<account_bansCreateWithoutPlayersInput, account_bansUncheckedCreateWithoutPlayersInput>
  }

  export type account_bansUpdateWithWhereUniqueWithoutPlayersInput = {
    where: account_bansWhereUniqueInput
    data: XOR<account_bansUpdateWithoutPlayersInput, account_bansUncheckedUpdateWithoutPlayersInput>
  }

  export type account_bansUpdateManyWithWhereWithoutPlayersInput = {
    where: account_bansScalarWhereInput
    data: XOR<account_bansUpdateManyMutationInput, account_bansUncheckedUpdateManyWithoutAccount_bansInput>
  }

  export type account_bansScalarWhereInput = {
    AND?: Enumerable<account_bansScalarWhereInput>
    OR?: Enumerable<account_bansScalarWhereInput>
    NOT?: Enumerable<account_bansScalarWhereInput>
    account_id?: IntFilter | number
    reason?: StringFilter | string
    banned_at?: BigIntFilter | bigint | number
    expires_at?: BigIntFilter | bigint | number
    banned_by?: IntFilter | number
  }

  export type account_viplistUpsertWithWhereUniqueWithoutPlayersInput = {
    where: account_viplistWhereUniqueInput
    update: XOR<account_viplistUpdateWithoutPlayersInput, account_viplistUncheckedUpdateWithoutPlayersInput>
    create: XOR<account_viplistCreateWithoutPlayersInput, account_viplistUncheckedCreateWithoutPlayersInput>
  }

  export type account_viplistUpdateWithWhereUniqueWithoutPlayersInput = {
    where: account_viplistWhereUniqueInput
    data: XOR<account_viplistUpdateWithoutPlayersInput, account_viplistUncheckedUpdateWithoutPlayersInput>
  }

  export type account_viplistUpdateManyWithWhereWithoutPlayersInput = {
    where: account_viplistScalarWhereInput
    data: XOR<account_viplistUpdateManyMutationInput, account_viplistUncheckedUpdateManyWithoutAccount_viplistInput>
  }

  export type guild_invitesUpsertWithWhereUniqueWithoutPlayersInput = {
    where: guild_invitesWhereUniqueInput
    update: XOR<guild_invitesUpdateWithoutPlayersInput, guild_invitesUncheckedUpdateWithoutPlayersInput>
    create: XOR<guild_invitesCreateWithoutPlayersInput, guild_invitesUncheckedCreateWithoutPlayersInput>
  }

  export type guild_invitesUpdateWithWhereUniqueWithoutPlayersInput = {
    where: guild_invitesWhereUniqueInput
    data: XOR<guild_invitesUpdateWithoutPlayersInput, guild_invitesUncheckedUpdateWithoutPlayersInput>
  }

  export type guild_invitesUpdateManyWithWhereWithoutPlayersInput = {
    where: guild_invitesScalarWhereInput
    data: XOR<guild_invitesUpdateManyMutationInput, guild_invitesUncheckedUpdateManyWithoutGuild_invitesInput>
  }

  export type guild_invitesScalarWhereInput = {
    AND?: Enumerable<guild_invitesScalarWhereInput>
    OR?: Enumerable<guild_invitesScalarWhereInput>
    NOT?: Enumerable<guild_invitesScalarWhereInput>
    player_id?: IntFilter | number
    guild_id?: IntFilter | number
  }

  export type guild_membershipUpsertWithoutPlayersInput = {
    update: XOR<guild_membershipUpdateWithoutPlayersInput, guild_membershipUncheckedUpdateWithoutPlayersInput>
    create: XOR<guild_membershipCreateWithoutPlayersInput, guild_membershipUncheckedCreateWithoutPlayersInput>
  }

  export type guild_membershipUpdateWithoutPlayersInput = {
    nick?: StringFieldUpdateOperationsInput | string
    guilds?: guildsUpdateOneRequiredWithoutGuild_membershipNestedInput
    guild_ranks?: guild_ranksUpdateOneRequiredWithoutGuild_membershipNestedInput
  }

  export type guild_membershipUncheckedUpdateWithoutPlayersInput = {
    guild_id?: IntFieldUpdateOperationsInput | number
    rank_id?: IntFieldUpdateOperationsInput | number
    nick?: StringFieldUpdateOperationsInput | string
  }

  export type guildsUpsertWithoutPlayersInput = {
    update: XOR<guildsUpdateWithoutPlayersInput, guildsUncheckedUpdateWithoutPlayersInput>
    create: XOR<guildsCreateWithoutPlayersInput, guildsUncheckedCreateWithoutPlayersInput>
  }

  export type guildsUpdateWithoutPlayersInput = {
    name?: StringFieldUpdateOperationsInput | string
    creationdata?: IntFieldUpdateOperationsInput | number
    motd?: StringFieldUpdateOperationsInput | string
    guild_invites?: guild_invitesUpdateManyWithoutGuildsNestedInput
    guild_membership?: guild_membershipUpdateManyWithoutGuildsNestedInput
    guild_ranks?: guild_ranksUpdateManyWithoutGuildsNestedInput
  }

  export type guildsUncheckedUpdateWithoutPlayersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    creationdata?: IntFieldUpdateOperationsInput | number
    motd?: StringFieldUpdateOperationsInput | string
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutGuildsNestedInput
    guild_membership?: guild_membershipUncheckedUpdateManyWithoutGuildsNestedInput
    guild_ranks?: guild_ranksUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type ip_bansUpsertWithWhereUniqueWithoutPlayersInput = {
    where: ip_bansWhereUniqueInput
    update: XOR<ip_bansUpdateWithoutPlayersInput, ip_bansUncheckedUpdateWithoutPlayersInput>
    create: XOR<ip_bansCreateWithoutPlayersInput, ip_bansUncheckedCreateWithoutPlayersInput>
  }

  export type ip_bansUpdateWithWhereUniqueWithoutPlayersInput = {
    where: ip_bansWhereUniqueInput
    data: XOR<ip_bansUpdateWithoutPlayersInput, ip_bansUncheckedUpdateWithoutPlayersInput>
  }

  export type ip_bansUpdateManyWithWhereWithoutPlayersInput = {
    where: ip_bansScalarWhereInput
    data: XOR<ip_bansUpdateManyMutationInput, ip_bansUncheckedUpdateManyWithoutIp_bansInput>
  }

  export type ip_bansScalarWhereInput = {
    AND?: Enumerable<ip_bansScalarWhereInput>
    OR?: Enumerable<ip_bansScalarWhereInput>
    NOT?: Enumerable<ip_bansScalarWhereInput>
    ip?: IntFilter | number
    reason?: StringFilter | string
    banned_at?: BigIntFilter | bigint | number
    expires_at?: BigIntFilter | bigint | number
    banned_by?: IntFilter | number
  }

  export type market_historyUpsertWithWhereUniqueWithoutPlayersInput = {
    where: market_historyWhereUniqueInput
    update: XOR<market_historyUpdateWithoutPlayersInput, market_historyUncheckedUpdateWithoutPlayersInput>
    create: XOR<market_historyCreateWithoutPlayersInput, market_historyUncheckedCreateWithoutPlayersInput>
  }

  export type market_historyUpdateWithWhereUniqueWithoutPlayersInput = {
    where: market_historyWhereUniqueInput
    data: XOR<market_historyUpdateWithoutPlayersInput, market_historyUncheckedUpdateWithoutPlayersInput>
  }

  export type market_historyUpdateManyWithWhereWithoutPlayersInput = {
    where: market_historyScalarWhereInput
    data: XOR<market_historyUpdateManyMutationInput, market_historyUncheckedUpdateManyWithoutMarket_historyInput>
  }

  export type market_historyScalarWhereInput = {
    AND?: Enumerable<market_historyScalarWhereInput>
    OR?: Enumerable<market_historyScalarWhereInput>
    NOT?: Enumerable<market_historyScalarWhereInput>
    id?: IntFilter | number
    player_id?: IntFilter | number
    sale?: BoolFilter | boolean
    itemtype?: IntFilter | number
    amount?: IntFilter | number
    price?: IntFilter | number
    expires_at?: BigIntFilter | bigint | number
    inserted?: BigIntFilter | bigint | number
    state?: IntFilter | number
  }

  export type market_offersUpsertWithWhereUniqueWithoutPlayersInput = {
    where: market_offersWhereUniqueInput
    update: XOR<market_offersUpdateWithoutPlayersInput, market_offersUncheckedUpdateWithoutPlayersInput>
    create: XOR<market_offersCreateWithoutPlayersInput, market_offersUncheckedCreateWithoutPlayersInput>
  }

  export type market_offersUpdateWithWhereUniqueWithoutPlayersInput = {
    where: market_offersWhereUniqueInput
    data: XOR<market_offersUpdateWithoutPlayersInput, market_offersUncheckedUpdateWithoutPlayersInput>
  }

  export type market_offersUpdateManyWithWhereWithoutPlayersInput = {
    where: market_offersScalarWhereInput
    data: XOR<market_offersUpdateManyMutationInput, market_offersUncheckedUpdateManyWithoutMarket_offersInput>
  }

  export type market_offersScalarWhereInput = {
    AND?: Enumerable<market_offersScalarWhereInput>
    OR?: Enumerable<market_offersScalarWhereInput>
    NOT?: Enumerable<market_offersScalarWhereInput>
    id?: IntFilter | number
    player_id?: IntFilter | number
    sale?: BoolFilter | boolean
    itemtype?: IntFilter | number
    amount?: IntFilter | number
    created?: BigIntFilter | bigint | number
    anonymous?: BoolFilter | boolean
    price?: IntFilter | number
  }

  export type player_depotitemsUpsertWithWhereUniqueWithoutPlayersInput = {
    where: player_depotitemsWhereUniqueInput
    update: XOR<player_depotitemsUpdateWithoutPlayersInput, player_depotitemsUncheckedUpdateWithoutPlayersInput>
    create: XOR<player_depotitemsCreateWithoutPlayersInput, player_depotitemsUncheckedCreateWithoutPlayersInput>
  }

  export type player_depotitemsUpdateWithWhereUniqueWithoutPlayersInput = {
    where: player_depotitemsWhereUniqueInput
    data: XOR<player_depotitemsUpdateWithoutPlayersInput, player_depotitemsUncheckedUpdateWithoutPlayersInput>
  }

  export type player_depotitemsUpdateManyWithWhereWithoutPlayersInput = {
    where: player_depotitemsScalarWhereInput
    data: XOR<player_depotitemsUpdateManyMutationInput, player_depotitemsUncheckedUpdateManyWithoutPlayer_depotitemsInput>
  }

  export type player_depotitemsScalarWhereInput = {
    AND?: Enumerable<player_depotitemsScalarWhereInput>
    OR?: Enumerable<player_depotitemsScalarWhereInput>
    NOT?: Enumerable<player_depotitemsScalarWhereInput>
    player_id?: IntFilter | number
    sid?: IntFilter | number
    pid?: IntFilter | number
    itemtype?: IntFilter | number
    count?: IntFilter | number
    attributes?: BytesFilter | Buffer
    json_data?: JsonNullableFilter
  }

  export type player_inboxitemsUpsertWithWhereUniqueWithoutPlayersInput = {
    where: player_inboxitemsWhereUniqueInput
    update: XOR<player_inboxitemsUpdateWithoutPlayersInput, player_inboxitemsUncheckedUpdateWithoutPlayersInput>
    create: XOR<player_inboxitemsCreateWithoutPlayersInput, player_inboxitemsUncheckedCreateWithoutPlayersInput>
  }

  export type player_inboxitemsUpdateWithWhereUniqueWithoutPlayersInput = {
    where: player_inboxitemsWhereUniqueInput
    data: XOR<player_inboxitemsUpdateWithoutPlayersInput, player_inboxitemsUncheckedUpdateWithoutPlayersInput>
  }

  export type player_inboxitemsUpdateManyWithWhereWithoutPlayersInput = {
    where: player_inboxitemsScalarWhereInput
    data: XOR<player_inboxitemsUpdateManyMutationInput, player_inboxitemsUncheckedUpdateManyWithoutPlayer_inboxitemsInput>
  }

  export type player_inboxitemsScalarWhereInput = {
    AND?: Enumerable<player_inboxitemsScalarWhereInput>
    OR?: Enumerable<player_inboxitemsScalarWhereInput>
    NOT?: Enumerable<player_inboxitemsScalarWhereInput>
    player_id?: IntFilter | number
    sid?: IntFilter | number
    pid?: IntFilter | number
    itemtype?: IntFilter | number
    count?: IntFilter | number
    attributes?: BytesFilter | Buffer
    json_data?: JsonNullableFilter
  }

  export type player_namelocksUpsertWithoutPlayers_player_namelocks_player_idToplayersInput = {
    update: XOR<player_namelocksUpdateWithoutPlayers_player_namelocks_player_idToplayersInput, player_namelocksUncheckedUpdateWithoutPlayers_player_namelocks_player_idToplayersInput>
    create: XOR<player_namelocksCreateWithoutPlayers_player_namelocks_player_idToplayersInput, player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_player_idToplayersInput>
  }

  export type player_namelocksUpdateWithoutPlayers_player_namelocks_player_idToplayersInput = {
    reason?: StringFieldUpdateOperationsInput | string
    namelocked_at?: BigIntFieldUpdateOperationsInput | bigint | number
    players_player_namelocks_namelocked_byToplayers?: PlayerUpdateOneRequiredWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersNestedInput
  }

  export type player_namelocksUncheckedUpdateWithoutPlayers_player_namelocks_player_idToplayersInput = {
    reason?: StringFieldUpdateOperationsInput | string
    namelocked_at?: BigIntFieldUpdateOperationsInput | bigint | number
    namelocked_by?: IntFieldUpdateOperationsInput | number
  }

  export type player_namelocksUpsertWithWhereUniqueWithoutPlayers_player_namelocks_namelocked_byToplayersInput = {
    where: player_namelocksWhereUniqueInput
    update: XOR<player_namelocksUpdateWithoutPlayers_player_namelocks_namelocked_byToplayersInput, player_namelocksUncheckedUpdateWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
    create: XOR<player_namelocksCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput, player_namelocksUncheckedCreateWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
  }

  export type player_namelocksUpdateWithWhereUniqueWithoutPlayers_player_namelocks_namelocked_byToplayersInput = {
    where: player_namelocksWhereUniqueInput
    data: XOR<player_namelocksUpdateWithoutPlayers_player_namelocks_namelocked_byToplayersInput, player_namelocksUncheckedUpdateWithoutPlayers_player_namelocks_namelocked_byToplayersInput>
  }

  export type player_namelocksUpdateManyWithWhereWithoutPlayers_player_namelocks_namelocked_byToplayersInput = {
    where: player_namelocksScalarWhereInput
    data: XOR<player_namelocksUpdateManyMutationInput, player_namelocksUncheckedUpdateManyWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput>
  }

  export type player_namelocksScalarWhereInput = {
    AND?: Enumerable<player_namelocksScalarWhereInput>
    OR?: Enumerable<player_namelocksScalarWhereInput>
    NOT?: Enumerable<player_namelocksScalarWhereInput>
    player_id?: IntFilter | number
    reason?: StringFilter | string
    namelocked_at?: BigIntFilter | bigint | number
    namelocked_by?: IntFilter | number
  }

  export type player_storageUpsertWithWhereUniqueWithoutPlayersInput = {
    where: player_storageWhereUniqueInput
    update: XOR<player_storageUpdateWithoutPlayersInput, player_storageUncheckedUpdateWithoutPlayersInput>
    create: XOR<player_storageCreateWithoutPlayersInput, player_storageUncheckedCreateWithoutPlayersInput>
  }

  export type player_storageUpdateWithWhereUniqueWithoutPlayersInput = {
    where: player_storageWhereUniqueInput
    data: XOR<player_storageUpdateWithoutPlayersInput, player_storageUncheckedUpdateWithoutPlayersInput>
  }

  export type player_storageUpdateManyWithWhereWithoutPlayersInput = {
    where: player_storageScalarWhereInput
    data: XOR<player_storageUpdateManyMutationInput, player_storageUncheckedUpdateManyWithoutPlayer_storageInput>
  }

  export type player_storageScalarWhereInput = {
    AND?: Enumerable<player_storageScalarWhereInput>
    OR?: Enumerable<player_storageScalarWhereInput>
    NOT?: Enumerable<player_storageScalarWhereInput>
    player_id?: IntFilter | number
    key?: IntFilter | number
    value?: IntFilter | number
  }

  export type player_storeinboxitemsUpsertWithWhereUniqueWithoutPlayersInput = {
    where: player_storeinboxitemsWhereUniqueInput
    update: XOR<player_storeinboxitemsUpdateWithoutPlayersInput, player_storeinboxitemsUncheckedUpdateWithoutPlayersInput>
    create: XOR<player_storeinboxitemsCreateWithoutPlayersInput, player_storeinboxitemsUncheckedCreateWithoutPlayersInput>
  }

  export type player_storeinboxitemsUpdateWithWhereUniqueWithoutPlayersInput = {
    where: player_storeinboxitemsWhereUniqueInput
    data: XOR<player_storeinboxitemsUpdateWithoutPlayersInput, player_storeinboxitemsUncheckedUpdateWithoutPlayersInput>
  }

  export type player_storeinboxitemsUpdateManyWithWhereWithoutPlayersInput = {
    where: player_storeinboxitemsScalarWhereInput
    data: XOR<player_storeinboxitemsUpdateManyMutationInput, player_storeinboxitemsUncheckedUpdateManyWithoutPlayer_storeinboxitemsInput>
  }

  export type player_storeinboxitemsScalarWhereInput = {
    AND?: Enumerable<player_storeinboxitemsScalarWhereInput>
    OR?: Enumerable<player_storeinboxitemsScalarWhereInput>
    NOT?: Enumerable<player_storeinboxitemsScalarWhereInput>
    player_id?: IntFilter | number
    sid?: IntFilter | number
    pid?: IntFilter | number
    itemtype?: IntFilter | number
    count?: IntFilter | number
    attributes?: BytesFilter | Buffer
    json_data?: JsonNullableFilter
  }

  export type AccountUpsertWithoutPlayersInput = {
    update: XOR<AccountUpdateWithoutPlayersInput, AccountUncheckedUpdateWithoutPlayersInput>
    create: XOR<AccountCreateWithoutPlayersInput, AccountUncheckedCreateWithoutPlayersInput>
  }

  export type AccountUpdateWithoutPlayersInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
    account_ban_history?: account_ban_historyUpdateManyWithoutAccountsNestedInput
    account_bans?: account_bansUpdateOneWithoutAccountsNestedInput
    account_storage?: account_storageUpdateManyWithoutAccountsNestedInput
    account_viplist?: account_viplistUpdateManyWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateWithoutPlayersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutAccountsNestedInput
    account_bans?: account_bansUncheckedUpdateOneWithoutAccountsNestedInput
    account_storage?: account_storageUncheckedUpdateManyWithoutAccountsNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type AccountCreateWithoutAccount_ban_historyInput = {
    name: string
    password: string
    secret?: string | null
    type?: number
    premium_ends_at?: number
    email?: string
    creation?: number
    premium_points?: number
    premdays: number
    wallet?: string | null
    alpha_key?: string | null
    account_bans?: account_bansCreateNestedOneWithoutAccountsInput
    account_storage?: account_storageCreateNestedManyWithoutAccountsInput
    account_viplist?: account_viplistCreateNestedManyWithoutAccountsInput
    players?: PlayerCreateNestedManyWithoutAccountsInput
  }

  export type AccountUncheckedCreateWithoutAccount_ban_historyInput = {
    id?: number
    name: string
    password: string
    secret?: string | null
    type?: number
    premium_ends_at?: number
    email?: string
    creation?: number
    premium_points?: number
    premdays: number
    wallet?: string | null
    alpha_key?: string | null
    account_bans?: account_bansUncheckedCreateNestedOneWithoutAccountsInput
    account_storage?: account_storageUncheckedCreateNestedManyWithoutAccountsInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutAccountsInput
    players?: PlayerUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type AccountCreateOrConnectWithoutAccount_ban_historyInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccount_ban_historyInput, AccountUncheckedCreateWithoutAccount_ban_historyInput>
  }

  export type PlayerCreateWithoutAccount_ban_historyInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutAccount_ban_historyInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutAccount_ban_historyInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutAccount_ban_historyInput, PlayerUncheckedCreateWithoutAccount_ban_historyInput>
  }

  export type AccountUpsertWithoutAccount_ban_historyInput = {
    update: XOR<AccountUpdateWithoutAccount_ban_historyInput, AccountUncheckedUpdateWithoutAccount_ban_historyInput>
    create: XOR<AccountCreateWithoutAccount_ban_historyInput, AccountUncheckedCreateWithoutAccount_ban_historyInput>
  }

  export type AccountUpdateWithoutAccount_ban_historyInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
    account_bans?: account_bansUpdateOneWithoutAccountsNestedInput
    account_storage?: account_storageUpdateManyWithoutAccountsNestedInput
    account_viplist?: account_viplistUpdateManyWithoutAccountsNestedInput
    players?: PlayerUpdateManyWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateWithoutAccount_ban_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
    account_bans?: account_bansUncheckedUpdateOneWithoutAccountsNestedInput
    account_storage?: account_storageUncheckedUpdateManyWithoutAccountsNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutAccountsNestedInput
    players?: PlayerUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type PlayerUpsertWithoutAccount_ban_historyInput = {
    update: XOR<PlayerUpdateWithoutAccount_ban_historyInput, PlayerUncheckedUpdateWithoutAccount_ban_historyInput>
    create: XOR<PlayerCreateWithoutAccount_ban_historyInput, PlayerUncheckedCreateWithoutAccount_ban_historyInput>
  }

  export type PlayerUpdateWithoutAccount_ban_historyInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutAccount_ban_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type AccountCreateWithoutAccount_bansInput = {
    name: string
    password: string
    secret?: string | null
    type?: number
    premium_ends_at?: number
    email?: string
    creation?: number
    premium_points?: number
    premdays: number
    wallet?: string | null
    alpha_key?: string | null
    account_ban_history?: account_ban_historyCreateNestedManyWithoutAccountsInput
    account_storage?: account_storageCreateNestedManyWithoutAccountsInput
    account_viplist?: account_viplistCreateNestedManyWithoutAccountsInput
    players?: PlayerCreateNestedManyWithoutAccountsInput
  }

  export type AccountUncheckedCreateWithoutAccount_bansInput = {
    id?: number
    name: string
    password: string
    secret?: string | null
    type?: number
    premium_ends_at?: number
    email?: string
    creation?: number
    premium_points?: number
    premdays: number
    wallet?: string | null
    alpha_key?: string | null
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutAccountsInput
    account_storage?: account_storageUncheckedCreateNestedManyWithoutAccountsInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutAccountsInput
    players?: PlayerUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type AccountCreateOrConnectWithoutAccount_bansInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccount_bansInput, AccountUncheckedCreateWithoutAccount_bansInput>
  }

  export type PlayerCreateWithoutAccount_bansInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutAccount_bansInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutAccount_bansInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutAccount_bansInput, PlayerUncheckedCreateWithoutAccount_bansInput>
  }

  export type AccountUpsertWithoutAccount_bansInput = {
    update: XOR<AccountUpdateWithoutAccount_bansInput, AccountUncheckedUpdateWithoutAccount_bansInput>
    create: XOR<AccountCreateWithoutAccount_bansInput, AccountUncheckedCreateWithoutAccount_bansInput>
  }

  export type AccountUpdateWithoutAccount_bansInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
    account_ban_history?: account_ban_historyUpdateManyWithoutAccountsNestedInput
    account_storage?: account_storageUpdateManyWithoutAccountsNestedInput
    account_viplist?: account_viplistUpdateManyWithoutAccountsNestedInput
    players?: PlayerUpdateManyWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateWithoutAccount_bansInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutAccountsNestedInput
    account_storage?: account_storageUncheckedUpdateManyWithoutAccountsNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutAccountsNestedInput
    players?: PlayerUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type PlayerUpsertWithoutAccount_bansInput = {
    update: XOR<PlayerUpdateWithoutAccount_bansInput, PlayerUncheckedUpdateWithoutAccount_bansInput>
    create: XOR<PlayerCreateWithoutAccount_bansInput, PlayerUncheckedCreateWithoutAccount_bansInput>
  }

  export type PlayerUpdateWithoutAccount_bansInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutAccount_bansInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type AccountCreateWithoutAccount_storageInput = {
    name: string
    password: string
    secret?: string | null
    type?: number
    premium_ends_at?: number
    email?: string
    creation?: number
    premium_points?: number
    premdays: number
    wallet?: string | null
    alpha_key?: string | null
    account_ban_history?: account_ban_historyCreateNestedManyWithoutAccountsInput
    account_bans?: account_bansCreateNestedOneWithoutAccountsInput
    account_viplist?: account_viplistCreateNestedManyWithoutAccountsInput
    players?: PlayerCreateNestedManyWithoutAccountsInput
  }

  export type AccountUncheckedCreateWithoutAccount_storageInput = {
    id?: number
    name: string
    password: string
    secret?: string | null
    type?: number
    premium_ends_at?: number
    email?: string
    creation?: number
    premium_points?: number
    premdays: number
    wallet?: string | null
    alpha_key?: string | null
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutAccountsInput
    account_bans?: account_bansUncheckedCreateNestedOneWithoutAccountsInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutAccountsInput
    players?: PlayerUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type AccountCreateOrConnectWithoutAccount_storageInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccount_storageInput, AccountUncheckedCreateWithoutAccount_storageInput>
  }

  export type AccountUpsertWithoutAccount_storageInput = {
    update: XOR<AccountUpdateWithoutAccount_storageInput, AccountUncheckedUpdateWithoutAccount_storageInput>
    create: XOR<AccountCreateWithoutAccount_storageInput, AccountUncheckedCreateWithoutAccount_storageInput>
  }

  export type AccountUpdateWithoutAccount_storageInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
    account_ban_history?: account_ban_historyUpdateManyWithoutAccountsNestedInput
    account_bans?: account_bansUpdateOneWithoutAccountsNestedInput
    account_viplist?: account_viplistUpdateManyWithoutAccountsNestedInput
    players?: PlayerUpdateManyWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateWithoutAccount_storageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutAccountsNestedInput
    account_bans?: account_bansUncheckedUpdateOneWithoutAccountsNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutAccountsNestedInput
    players?: PlayerUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type AccountCreateWithoutAccount_viplistInput = {
    name: string
    password: string
    secret?: string | null
    type?: number
    premium_ends_at?: number
    email?: string
    creation?: number
    premium_points?: number
    premdays: number
    wallet?: string | null
    alpha_key?: string | null
    account_ban_history?: account_ban_historyCreateNestedManyWithoutAccountsInput
    account_bans?: account_bansCreateNestedOneWithoutAccountsInput
    account_storage?: account_storageCreateNestedManyWithoutAccountsInput
    players?: PlayerCreateNestedManyWithoutAccountsInput
  }

  export type AccountUncheckedCreateWithoutAccount_viplistInput = {
    id?: number
    name: string
    password: string
    secret?: string | null
    type?: number
    premium_ends_at?: number
    email?: string
    creation?: number
    premium_points?: number
    premdays: number
    wallet?: string | null
    alpha_key?: string | null
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutAccountsInput
    account_bans?: account_bansUncheckedCreateNestedOneWithoutAccountsInput
    account_storage?: account_storageUncheckedCreateNestedManyWithoutAccountsInput
    players?: PlayerUncheckedCreateNestedManyWithoutAccountsInput
  }

  export type AccountCreateOrConnectWithoutAccount_viplistInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccount_viplistInput, AccountUncheckedCreateWithoutAccount_viplistInput>
  }

  export type PlayerCreateWithoutAccount_viplistInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutAccount_viplistInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutAccount_viplistInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutAccount_viplistInput, PlayerUncheckedCreateWithoutAccount_viplistInput>
  }

  export type AccountUpsertWithoutAccount_viplistInput = {
    update: XOR<AccountUpdateWithoutAccount_viplistInput, AccountUncheckedUpdateWithoutAccount_viplistInput>
    create: XOR<AccountCreateWithoutAccount_viplistInput, AccountUncheckedCreateWithoutAccount_viplistInput>
  }

  export type AccountUpdateWithoutAccount_viplistInput = {
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
    account_ban_history?: account_ban_historyUpdateManyWithoutAccountsNestedInput
    account_bans?: account_bansUpdateOneWithoutAccountsNestedInput
    account_storage?: account_storageUpdateManyWithoutAccountsNestedInput
    players?: PlayerUpdateManyWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateWithoutAccount_viplistInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    premium_ends_at?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    creation?: IntFieldUpdateOperationsInput | number
    premium_points?: IntFieldUpdateOperationsInput | number
    premdays?: IntFieldUpdateOperationsInput | number
    wallet?: NullableStringFieldUpdateOperationsInput | string | null
    alpha_key?: NullableStringFieldUpdateOperationsInput | string | null
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutAccountsNestedInput
    account_bans?: account_bansUncheckedUpdateOneWithoutAccountsNestedInput
    account_storage?: account_storageUncheckedUpdateManyWithoutAccountsNestedInput
    players?: PlayerUncheckedUpdateManyWithoutAccountsNestedInput
  }

  export type PlayerUpsertWithoutAccount_viplistInput = {
    update: XOR<PlayerUpdateWithoutAccount_viplistInput, PlayerUncheckedUpdateWithoutAccount_viplistInput>
    create: XOR<PlayerCreateWithoutAccount_viplistInput, PlayerUncheckedCreateWithoutAccount_viplistInput>
  }

  export type PlayerUpdateWithoutAccount_viplistInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutAccount_viplistInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type PlayerCreateWithoutGuild_invitesInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutGuild_invitesInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutGuild_invitesInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutGuild_invitesInput, PlayerUncheckedCreateWithoutGuild_invitesInput>
  }

  export type guildsCreateWithoutGuild_invitesInput = {
    name: string
    creationdata: number
    motd?: string
    guild_membership?: guild_membershipCreateNestedManyWithoutGuildsInput
    guild_ranks?: guild_ranksCreateNestedManyWithoutGuildsInput
    players: PlayerCreateNestedOneWithoutGuildsInput
  }

  export type guildsUncheckedCreateWithoutGuild_invitesInput = {
    id?: number
    name: string
    ownerid: number
    creationdata: number
    motd?: string
    guild_membership?: guild_membershipUncheckedCreateNestedManyWithoutGuildsInput
    guild_ranks?: guild_ranksUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type guildsCreateOrConnectWithoutGuild_invitesInput = {
    where: guildsWhereUniqueInput
    create: XOR<guildsCreateWithoutGuild_invitesInput, guildsUncheckedCreateWithoutGuild_invitesInput>
  }

  export type PlayerUpsertWithoutGuild_invitesInput = {
    update: XOR<PlayerUpdateWithoutGuild_invitesInput, PlayerUncheckedUpdateWithoutGuild_invitesInput>
    create: XOR<PlayerCreateWithoutGuild_invitesInput, PlayerUncheckedCreateWithoutGuild_invitesInput>
  }

  export type PlayerUpdateWithoutGuild_invitesInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutGuild_invitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type guildsUpsertWithoutGuild_invitesInput = {
    update: XOR<guildsUpdateWithoutGuild_invitesInput, guildsUncheckedUpdateWithoutGuild_invitesInput>
    create: XOR<guildsCreateWithoutGuild_invitesInput, guildsUncheckedCreateWithoutGuild_invitesInput>
  }

  export type guildsUpdateWithoutGuild_invitesInput = {
    name?: StringFieldUpdateOperationsInput | string
    creationdata?: IntFieldUpdateOperationsInput | number
    motd?: StringFieldUpdateOperationsInput | string
    guild_membership?: guild_membershipUpdateManyWithoutGuildsNestedInput
    guild_ranks?: guild_ranksUpdateManyWithoutGuildsNestedInput
    players?: PlayerUpdateOneRequiredWithoutGuildsNestedInput
  }

  export type guildsUncheckedUpdateWithoutGuild_invitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerid?: IntFieldUpdateOperationsInput | number
    creationdata?: IntFieldUpdateOperationsInput | number
    motd?: StringFieldUpdateOperationsInput | string
    guild_membership?: guild_membershipUncheckedUpdateManyWithoutGuildsNestedInput
    guild_ranks?: guild_ranksUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type PlayerCreateWithoutGuild_membershipInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutGuild_membershipInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutGuild_membershipInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutGuild_membershipInput, PlayerUncheckedCreateWithoutGuild_membershipInput>
  }

  export type guildsCreateWithoutGuild_membershipInput = {
    name: string
    creationdata: number
    motd?: string
    guild_invites?: guild_invitesCreateNestedManyWithoutGuildsInput
    guild_ranks?: guild_ranksCreateNestedManyWithoutGuildsInput
    players: PlayerCreateNestedOneWithoutGuildsInput
  }

  export type guildsUncheckedCreateWithoutGuild_membershipInput = {
    id?: number
    name: string
    ownerid: number
    creationdata: number
    motd?: string
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutGuildsInput
    guild_ranks?: guild_ranksUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type guildsCreateOrConnectWithoutGuild_membershipInput = {
    where: guildsWhereUniqueInput
    create: XOR<guildsCreateWithoutGuild_membershipInput, guildsUncheckedCreateWithoutGuild_membershipInput>
  }

  export type guild_ranksCreateWithoutGuild_membershipInput = {
    name: string
    level: number
    guilds: guildsCreateNestedOneWithoutGuild_ranksInput
  }

  export type guild_ranksUncheckedCreateWithoutGuild_membershipInput = {
    id?: number
    guild_id: number
    name: string
    level: number
  }

  export type guild_ranksCreateOrConnectWithoutGuild_membershipInput = {
    where: guild_ranksWhereUniqueInput
    create: XOR<guild_ranksCreateWithoutGuild_membershipInput, guild_ranksUncheckedCreateWithoutGuild_membershipInput>
  }

  export type PlayerUpsertWithoutGuild_membershipInput = {
    update: XOR<PlayerUpdateWithoutGuild_membershipInput, PlayerUncheckedUpdateWithoutGuild_membershipInput>
    create: XOR<PlayerCreateWithoutGuild_membershipInput, PlayerUncheckedCreateWithoutGuild_membershipInput>
  }

  export type PlayerUpdateWithoutGuild_membershipInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutGuild_membershipInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type guildsUpsertWithoutGuild_membershipInput = {
    update: XOR<guildsUpdateWithoutGuild_membershipInput, guildsUncheckedUpdateWithoutGuild_membershipInput>
    create: XOR<guildsCreateWithoutGuild_membershipInput, guildsUncheckedCreateWithoutGuild_membershipInput>
  }

  export type guildsUpdateWithoutGuild_membershipInput = {
    name?: StringFieldUpdateOperationsInput | string
    creationdata?: IntFieldUpdateOperationsInput | number
    motd?: StringFieldUpdateOperationsInput | string
    guild_invites?: guild_invitesUpdateManyWithoutGuildsNestedInput
    guild_ranks?: guild_ranksUpdateManyWithoutGuildsNestedInput
    players?: PlayerUpdateOneRequiredWithoutGuildsNestedInput
  }

  export type guildsUncheckedUpdateWithoutGuild_membershipInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerid?: IntFieldUpdateOperationsInput | number
    creationdata?: IntFieldUpdateOperationsInput | number
    motd?: StringFieldUpdateOperationsInput | string
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutGuildsNestedInput
    guild_ranks?: guild_ranksUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type guild_ranksUpsertWithoutGuild_membershipInput = {
    update: XOR<guild_ranksUpdateWithoutGuild_membershipInput, guild_ranksUncheckedUpdateWithoutGuild_membershipInput>
    create: XOR<guild_ranksCreateWithoutGuild_membershipInput, guild_ranksUncheckedCreateWithoutGuild_membershipInput>
  }

  export type guild_ranksUpdateWithoutGuild_membershipInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    guilds?: guildsUpdateOneRequiredWithoutGuild_ranksNestedInput
  }

  export type guild_ranksUncheckedUpdateWithoutGuild_membershipInput = {
    id?: IntFieldUpdateOperationsInput | number
    guild_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type guild_membershipCreateWithoutGuild_ranksInput = {
    nick?: string
    players: PlayerCreateNestedOneWithoutGuild_membershipInput
    guilds: guildsCreateNestedOneWithoutGuild_membershipInput
  }

  export type guild_membershipUncheckedCreateWithoutGuild_ranksInput = {
    player_id: number
    guild_id: number
    nick?: string
  }

  export type guild_membershipCreateOrConnectWithoutGuild_ranksInput = {
    where: guild_membershipWhereUniqueInput
    create: XOR<guild_membershipCreateWithoutGuild_ranksInput, guild_membershipUncheckedCreateWithoutGuild_ranksInput>
  }

  export type guild_membershipCreateManyGuild_ranksInputEnvelope = {
    data: Enumerable<guild_membershipCreateManyGuild_ranksInput>
    skipDuplicates?: boolean
  }

  export type guildsCreateWithoutGuild_ranksInput = {
    name: string
    creationdata: number
    motd?: string
    guild_invites?: guild_invitesCreateNestedManyWithoutGuildsInput
    guild_membership?: guild_membershipCreateNestedManyWithoutGuildsInput
    players: PlayerCreateNestedOneWithoutGuildsInput
  }

  export type guildsUncheckedCreateWithoutGuild_ranksInput = {
    id?: number
    name: string
    ownerid: number
    creationdata: number
    motd?: string
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutGuildsInput
    guild_membership?: guild_membershipUncheckedCreateNestedManyWithoutGuildsInput
  }

  export type guildsCreateOrConnectWithoutGuild_ranksInput = {
    where: guildsWhereUniqueInput
    create: XOR<guildsCreateWithoutGuild_ranksInput, guildsUncheckedCreateWithoutGuild_ranksInput>
  }

  export type guild_membershipUpsertWithWhereUniqueWithoutGuild_ranksInput = {
    where: guild_membershipWhereUniqueInput
    update: XOR<guild_membershipUpdateWithoutGuild_ranksInput, guild_membershipUncheckedUpdateWithoutGuild_ranksInput>
    create: XOR<guild_membershipCreateWithoutGuild_ranksInput, guild_membershipUncheckedCreateWithoutGuild_ranksInput>
  }

  export type guild_membershipUpdateWithWhereUniqueWithoutGuild_ranksInput = {
    where: guild_membershipWhereUniqueInput
    data: XOR<guild_membershipUpdateWithoutGuild_ranksInput, guild_membershipUncheckedUpdateWithoutGuild_ranksInput>
  }

  export type guild_membershipUpdateManyWithWhereWithoutGuild_ranksInput = {
    where: guild_membershipScalarWhereInput
    data: XOR<guild_membershipUpdateManyMutationInput, guild_membershipUncheckedUpdateManyWithoutGuild_membershipInput>
  }

  export type guild_membershipScalarWhereInput = {
    AND?: Enumerable<guild_membershipScalarWhereInput>
    OR?: Enumerable<guild_membershipScalarWhereInput>
    NOT?: Enumerable<guild_membershipScalarWhereInput>
    player_id?: IntFilter | number
    guild_id?: IntFilter | number
    rank_id?: IntFilter | number
    nick?: StringFilter | string
  }

  export type guildsUpsertWithoutGuild_ranksInput = {
    update: XOR<guildsUpdateWithoutGuild_ranksInput, guildsUncheckedUpdateWithoutGuild_ranksInput>
    create: XOR<guildsCreateWithoutGuild_ranksInput, guildsUncheckedCreateWithoutGuild_ranksInput>
  }

  export type guildsUpdateWithoutGuild_ranksInput = {
    name?: StringFieldUpdateOperationsInput | string
    creationdata?: IntFieldUpdateOperationsInput | number
    motd?: StringFieldUpdateOperationsInput | string
    guild_invites?: guild_invitesUpdateManyWithoutGuildsNestedInput
    guild_membership?: guild_membershipUpdateManyWithoutGuildsNestedInput
    players?: PlayerUpdateOneRequiredWithoutGuildsNestedInput
  }

  export type guildsUncheckedUpdateWithoutGuild_ranksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ownerid?: IntFieldUpdateOperationsInput | number
    creationdata?: IntFieldUpdateOperationsInput | number
    motd?: StringFieldUpdateOperationsInput | string
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutGuildsNestedInput
    guild_membership?: guild_membershipUncheckedUpdateManyWithoutGuildsNestedInput
  }

  export type guildwar_killsCreateWithoutGuild_warsInput = {
    killer: string
    target: string
    killerguild?: number
    targetguild?: number
    time: bigint | number
  }

  export type guildwar_killsUncheckedCreateWithoutGuild_warsInput = {
    id?: number
    killer: string
    target: string
    killerguild?: number
    targetguild?: number
    time: bigint | number
  }

  export type guildwar_killsCreateOrConnectWithoutGuild_warsInput = {
    where: guildwar_killsWhereUniqueInput
    create: XOR<guildwar_killsCreateWithoutGuild_warsInput, guildwar_killsUncheckedCreateWithoutGuild_warsInput>
  }

  export type guildwar_killsCreateManyGuild_warsInputEnvelope = {
    data: Enumerable<guildwar_killsCreateManyGuild_warsInput>
    skipDuplicates?: boolean
  }

  export type guildwar_killsUpsertWithWhereUniqueWithoutGuild_warsInput = {
    where: guildwar_killsWhereUniqueInput
    update: XOR<guildwar_killsUpdateWithoutGuild_warsInput, guildwar_killsUncheckedUpdateWithoutGuild_warsInput>
    create: XOR<guildwar_killsCreateWithoutGuild_warsInput, guildwar_killsUncheckedCreateWithoutGuild_warsInput>
  }

  export type guildwar_killsUpdateWithWhereUniqueWithoutGuild_warsInput = {
    where: guildwar_killsWhereUniqueInput
    data: XOR<guildwar_killsUpdateWithoutGuild_warsInput, guildwar_killsUncheckedUpdateWithoutGuild_warsInput>
  }

  export type guildwar_killsUpdateManyWithWhereWithoutGuild_warsInput = {
    where: guildwar_killsScalarWhereInput
    data: XOR<guildwar_killsUpdateManyMutationInput, guildwar_killsUncheckedUpdateManyWithoutGuildwar_killsInput>
  }

  export type guildwar_killsScalarWhereInput = {
    AND?: Enumerable<guildwar_killsScalarWhereInput>
    OR?: Enumerable<guildwar_killsScalarWhereInput>
    NOT?: Enumerable<guildwar_killsScalarWhereInput>
    id?: IntFilter | number
    killer?: StringFilter | string
    target?: StringFilter | string
    killerguild?: IntFilter | number
    targetguild?: IntFilter | number
    warid?: IntFilter | number
    time?: BigIntFilter | bigint | number
  }

  export type guild_invitesCreateWithoutGuildsInput = {
    players?: PlayerCreateNestedOneWithoutGuild_invitesInput
  }

  export type guild_invitesUncheckedCreateWithoutGuildsInput = {
    player_id?: number
  }

  export type guild_invitesCreateOrConnectWithoutGuildsInput = {
    where: guild_invitesWhereUniqueInput
    create: XOR<guild_invitesCreateWithoutGuildsInput, guild_invitesUncheckedCreateWithoutGuildsInput>
  }

  export type guild_invitesCreateManyGuildsInputEnvelope = {
    data: Enumerable<guild_invitesCreateManyGuildsInput>
    skipDuplicates?: boolean
  }

  export type guild_membershipCreateWithoutGuildsInput = {
    nick?: string
    players: PlayerCreateNestedOneWithoutGuild_membershipInput
    guild_ranks: guild_ranksCreateNestedOneWithoutGuild_membershipInput
  }

  export type guild_membershipUncheckedCreateWithoutGuildsInput = {
    player_id: number
    rank_id: number
    nick?: string
  }

  export type guild_membershipCreateOrConnectWithoutGuildsInput = {
    where: guild_membershipWhereUniqueInput
    create: XOR<guild_membershipCreateWithoutGuildsInput, guild_membershipUncheckedCreateWithoutGuildsInput>
  }

  export type guild_membershipCreateManyGuildsInputEnvelope = {
    data: Enumerable<guild_membershipCreateManyGuildsInput>
    skipDuplicates?: boolean
  }

  export type guild_ranksCreateWithoutGuildsInput = {
    name: string
    level: number
    guild_membership?: guild_membershipCreateNestedManyWithoutGuild_ranksInput
  }

  export type guild_ranksUncheckedCreateWithoutGuildsInput = {
    id?: number
    name: string
    level: number
    guild_membership?: guild_membershipUncheckedCreateNestedManyWithoutGuild_ranksInput
  }

  export type guild_ranksCreateOrConnectWithoutGuildsInput = {
    where: guild_ranksWhereUniqueInput
    create: XOR<guild_ranksCreateWithoutGuildsInput, guild_ranksUncheckedCreateWithoutGuildsInput>
  }

  export type guild_ranksCreateManyGuildsInputEnvelope = {
    data: Enumerable<guild_ranksCreateManyGuildsInput>
    skipDuplicates?: boolean
  }

  export type PlayerCreateWithoutGuildsInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutGuildsInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutGuildsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutGuildsInput, PlayerUncheckedCreateWithoutGuildsInput>
  }

  export type guild_invitesUpsertWithWhereUniqueWithoutGuildsInput = {
    where: guild_invitesWhereUniqueInput
    update: XOR<guild_invitesUpdateWithoutGuildsInput, guild_invitesUncheckedUpdateWithoutGuildsInput>
    create: XOR<guild_invitesCreateWithoutGuildsInput, guild_invitesUncheckedCreateWithoutGuildsInput>
  }

  export type guild_invitesUpdateWithWhereUniqueWithoutGuildsInput = {
    where: guild_invitesWhereUniqueInput
    data: XOR<guild_invitesUpdateWithoutGuildsInput, guild_invitesUncheckedUpdateWithoutGuildsInput>
  }

  export type guild_invitesUpdateManyWithWhereWithoutGuildsInput = {
    where: guild_invitesScalarWhereInput
    data: XOR<guild_invitesUpdateManyMutationInput, guild_invitesUncheckedUpdateManyWithoutGuild_invitesInput>
  }

  export type guild_membershipUpsertWithWhereUniqueWithoutGuildsInput = {
    where: guild_membershipWhereUniqueInput
    update: XOR<guild_membershipUpdateWithoutGuildsInput, guild_membershipUncheckedUpdateWithoutGuildsInput>
    create: XOR<guild_membershipCreateWithoutGuildsInput, guild_membershipUncheckedCreateWithoutGuildsInput>
  }

  export type guild_membershipUpdateWithWhereUniqueWithoutGuildsInput = {
    where: guild_membershipWhereUniqueInput
    data: XOR<guild_membershipUpdateWithoutGuildsInput, guild_membershipUncheckedUpdateWithoutGuildsInput>
  }

  export type guild_membershipUpdateManyWithWhereWithoutGuildsInput = {
    where: guild_membershipScalarWhereInput
    data: XOR<guild_membershipUpdateManyMutationInput, guild_membershipUncheckedUpdateManyWithoutGuild_membershipInput>
  }

  export type guild_ranksUpsertWithWhereUniqueWithoutGuildsInput = {
    where: guild_ranksWhereUniqueInput
    update: XOR<guild_ranksUpdateWithoutGuildsInput, guild_ranksUncheckedUpdateWithoutGuildsInput>
    create: XOR<guild_ranksCreateWithoutGuildsInput, guild_ranksUncheckedCreateWithoutGuildsInput>
  }

  export type guild_ranksUpdateWithWhereUniqueWithoutGuildsInput = {
    where: guild_ranksWhereUniqueInput
    data: XOR<guild_ranksUpdateWithoutGuildsInput, guild_ranksUncheckedUpdateWithoutGuildsInput>
  }

  export type guild_ranksUpdateManyWithWhereWithoutGuildsInput = {
    where: guild_ranksScalarWhereInput
    data: XOR<guild_ranksUpdateManyMutationInput, guild_ranksUncheckedUpdateManyWithoutGuild_ranksInput>
  }

  export type guild_ranksScalarWhereInput = {
    AND?: Enumerable<guild_ranksScalarWhereInput>
    OR?: Enumerable<guild_ranksScalarWhereInput>
    NOT?: Enumerable<guild_ranksScalarWhereInput>
    id?: IntFilter | number
    guild_id?: IntFilter | number
    name?: StringFilter | string
    level?: IntFilter | number
  }

  export type PlayerUpsertWithoutGuildsInput = {
    update: XOR<PlayerUpdateWithoutGuildsInput, PlayerUncheckedUpdateWithoutGuildsInput>
    create: XOR<PlayerCreateWithoutGuildsInput, PlayerUncheckedCreateWithoutGuildsInput>
  }

  export type PlayerUpdateWithoutGuildsInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutGuildsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type guild_warsCreateWithoutGuildwar_killsInput = {
    guild1?: number
    guild2?: number
    name1: string
    name2: string
    status?: number
    started?: bigint | number
    ended?: bigint | number
  }

  export type guild_warsUncheckedCreateWithoutGuildwar_killsInput = {
    id?: number
    guild1?: number
    guild2?: number
    name1: string
    name2: string
    status?: number
    started?: bigint | number
    ended?: bigint | number
  }

  export type guild_warsCreateOrConnectWithoutGuildwar_killsInput = {
    where: guild_warsWhereUniqueInput
    create: XOR<guild_warsCreateWithoutGuildwar_killsInput, guild_warsUncheckedCreateWithoutGuildwar_killsInput>
  }

  export type guild_warsUpsertWithoutGuildwar_killsInput = {
    update: XOR<guild_warsUpdateWithoutGuildwar_killsInput, guild_warsUncheckedUpdateWithoutGuildwar_killsInput>
    create: XOR<guild_warsCreateWithoutGuildwar_killsInput, guild_warsUncheckedCreateWithoutGuildwar_killsInput>
  }

  export type guild_warsUpdateWithoutGuildwar_killsInput = {
    guild1?: IntFieldUpdateOperationsInput | number
    guild2?: IntFieldUpdateOperationsInput | number
    name1?: StringFieldUpdateOperationsInput | string
    name2?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    started?: BigIntFieldUpdateOperationsInput | bigint | number
    ended?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type guild_warsUncheckedUpdateWithoutGuildwar_killsInput = {
    id?: IntFieldUpdateOperationsInput | number
    guild1?: IntFieldUpdateOperationsInput | number
    guild2?: IntFieldUpdateOperationsInput | number
    name1?: StringFieldUpdateOperationsInput | string
    name2?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    started?: BigIntFieldUpdateOperationsInput | bigint | number
    ended?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type PlayerCreateWithoutIp_bansInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutIp_bansInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutIp_bansInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutIp_bansInput, PlayerUncheckedCreateWithoutIp_bansInput>
  }

  export type PlayerUpsertWithoutIp_bansInput = {
    update: XOR<PlayerUpdateWithoutIp_bansInput, PlayerUncheckedUpdateWithoutIp_bansInput>
    create: XOR<PlayerCreateWithoutIp_bansInput, PlayerUncheckedCreateWithoutIp_bansInput>
  }

  export type PlayerUpdateWithoutIp_bansInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutIp_bansInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type PlayerCreateWithoutMarket_historyInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutMarket_historyInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutMarket_historyInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutMarket_historyInput, PlayerUncheckedCreateWithoutMarket_historyInput>
  }

  export type PlayerUpsertWithoutMarket_historyInput = {
    update: XOR<PlayerUpdateWithoutMarket_historyInput, PlayerUncheckedUpdateWithoutMarket_historyInput>
    create: XOR<PlayerCreateWithoutMarket_historyInput, PlayerUncheckedCreateWithoutMarket_historyInput>
  }

  export type PlayerUpdateWithoutMarket_historyInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutMarket_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type PlayerCreateWithoutMarket_offersInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutMarket_offersInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutMarket_offersInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutMarket_offersInput, PlayerUncheckedCreateWithoutMarket_offersInput>
  }

  export type PlayerUpsertWithoutMarket_offersInput = {
    update: XOR<PlayerUpdateWithoutMarket_offersInput, PlayerUncheckedUpdateWithoutMarket_offersInput>
    create: XOR<PlayerCreateWithoutMarket_offersInput, PlayerUncheckedCreateWithoutMarket_offersInput>
  }

  export type PlayerUpdateWithoutMarket_offersInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutMarket_offersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type PlayerCreateWithoutPlayer_depotitemsInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutPlayer_depotitemsInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutPlayer_depotitemsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPlayer_depotitemsInput, PlayerUncheckedCreateWithoutPlayer_depotitemsInput>
  }

  export type PlayerUpsertWithoutPlayer_depotitemsInput = {
    update: XOR<PlayerUpdateWithoutPlayer_depotitemsInput, PlayerUncheckedUpdateWithoutPlayer_depotitemsInput>
    create: XOR<PlayerCreateWithoutPlayer_depotitemsInput, PlayerUncheckedCreateWithoutPlayer_depotitemsInput>
  }

  export type PlayerUpdateWithoutPlayer_depotitemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPlayer_depotitemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type PlayerCreateWithoutPlayer_inboxitemsInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutPlayer_inboxitemsInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutPlayer_inboxitemsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPlayer_inboxitemsInput, PlayerUncheckedCreateWithoutPlayer_inboxitemsInput>
  }

  export type PlayerUpsertWithoutPlayer_inboxitemsInput = {
    update: XOR<PlayerUpdateWithoutPlayer_inboxitemsInput, PlayerUncheckedUpdateWithoutPlayer_inboxitemsInput>
    create: XOR<PlayerCreateWithoutPlayer_inboxitemsInput, PlayerUncheckedCreateWithoutPlayer_inboxitemsInput>
  }

  export type PlayerUpdateWithoutPlayer_inboxitemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPlayer_inboxitemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type PlayerCreateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput, PlayerUncheckedCreateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput>
  }

  export type PlayerCreateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput, PlayerUncheckedCreateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput>
  }

  export type PlayerUpsertWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput = {
    update: XOR<PlayerUpdateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput, PlayerUncheckedUpdateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput>
    create: XOR<PlayerCreateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput, PlayerUncheckedCreateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput>
  }

  export type PlayerUpdateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPlayer_namelocks_player_namelocks_player_idToplayersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type PlayerUpsertWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput = {
    update: XOR<PlayerUpdateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput, PlayerUncheckedUpdateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput>
    create: XOR<PlayerCreateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput, PlayerUncheckedCreateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput>
  }

  export type PlayerUpdateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type PlayerCreateWithoutPlayer_storageInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storeinboxitems?: player_storeinboxitemsCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutPlayer_storageInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutPlayer_storageInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPlayer_storageInput, PlayerUncheckedCreateWithoutPlayer_storageInput>
  }

  export type PlayerUpsertWithoutPlayer_storageInput = {
    update: XOR<PlayerUpdateWithoutPlayer_storageInput, PlayerUncheckedUpdateWithoutPlayer_storageInput>
    create: XOR<PlayerCreateWithoutPlayer_storageInput, PlayerUncheckedCreateWithoutPlayer_storageInput>
  }

  export type PlayerUpdateWithoutPlayer_storageInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPlayer_storageInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type PlayerCreateWithoutPlayer_storeinboxitemsInput = {
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipCreateNestedOneWithoutPlayersInput
    guilds?: guildsCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansCreateNestedManyWithoutPlayersInput
    market_history?: market_historyCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageCreateNestedManyWithoutPlayersInput
    accounts?: AccountCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutPlayer_storeinboxitemsInput = {
    id?: number
    name: string
    group_id?: number
    account_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
    account_ban_history?: account_ban_historyUncheckedCreateNestedManyWithoutPlayersInput
    account_bans?: account_bansUncheckedCreateNestedManyWithoutPlayersInput
    account_viplist?: account_viplistUncheckedCreateNestedManyWithoutPlayersInput
    guild_invites?: guild_invitesUncheckedCreateNestedManyWithoutPlayersInput
    guild_membership?: guild_membershipUncheckedCreateNestedOneWithoutPlayersInput
    guilds?: guildsUncheckedCreateNestedOneWithoutPlayersInput
    ip_bans?: ip_bansUncheckedCreateNestedManyWithoutPlayersInput
    market_history?: market_historyUncheckedCreateNestedManyWithoutPlayersInput
    market_offers?: market_offersUncheckedCreateNestedManyWithoutPlayersInput
    player_depotitems?: player_depotitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_inboxitems?: player_inboxitemsUncheckedCreateNestedManyWithoutPlayersInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedCreateNestedOneWithoutPlayers_player_namelocks_player_idToplayersInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedCreateNestedManyWithoutPlayers_player_namelocks_namelocked_byToplayersInput
    player_storage?: player_storageUncheckedCreateNestedManyWithoutPlayersInput
  }

  export type PlayerCreateOrConnectWithoutPlayer_storeinboxitemsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPlayer_storeinboxitemsInput, PlayerUncheckedCreateWithoutPlayer_storeinboxitemsInput>
  }

  export type PlayerUpsertWithoutPlayer_storeinboxitemsInput = {
    update: XOR<PlayerUpdateWithoutPlayer_storeinboxitemsInput, PlayerUncheckedUpdateWithoutPlayer_storeinboxitemsInput>
    create: XOR<PlayerCreateWithoutPlayer_storeinboxitemsInput, PlayerUncheckedCreateWithoutPlayer_storeinboxitemsInput>
  }

  export type PlayerUpdateWithoutPlayer_storeinboxitemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    accounts?: AccountUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPlayer_storeinboxitemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type account_ban_historyCreateManyAccountsInput = {
    id?: number
    reason: string
    banned_at: bigint | number
    expired_at: bigint | number
    banned_by: number
  }

  export type account_storageCreateManyAccountsInput = {
    key: number
    value: number
  }

  export type account_viplistCreateManyAccountsInput = {
    player_id: number
    description?: string
    icon?: number
    notify?: boolean
  }

  export type PlayerCreateManyAccountsInput = {
    id?: number
    name: string
    group_id?: number
    level?: number
    vocation?: number
    health?: number
    healthmax?: number
    experience?: bigint | number
    lookbody?: number
    lookfeet?: number
    lookhead?: number
    looklegs?: number
    looktype?: number
    lookaddons?: number
    direction?: number
    maglevel?: number
    mana?: number
    manamax?: number
    manaspent?: bigint | number
    soul?: number
    town_id?: number
    posx?: number
    posy?: number
    posz?: number
    conditions: Buffer
    cap?: number
    sex?: number
    lastlogin?: bigint | number
    lastip?: number
    save?: boolean
    skull?: boolean
    skulltime?: bigint | number
    lastlogout?: bigint | number
    blessings?: number
    onlinetime?: bigint | number
    deletion?: bigint | number
    balance?: bigint | number
    offlinetraining_time?: number
    offlinetraining_skill?: number
    stamina?: number
    skill_fist?: number
    skill_fist_tries?: bigint | number
    skill_club?: number
    skill_club_tries?: bigint | number
    skill_sword?: number
    skill_sword_tries?: bigint | number
    skill_axe?: number
    skill_axe_tries?: bigint | number
    skill_dist?: number
    skill_dist_tries?: bigint | number
    skill_shielding?: number
    skill_shielding_tries?: bigint | number
    skill_fishing?: number
    skill_fishing_tries?: bigint | number
    stat_str?: number
    stat_int?: number
    stat_dex?: number
    stat_vit?: number
    stat_spr?: number
    stat_wis?: number
  }

  export type account_ban_historyUpdateWithoutAccountsInput = {
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expired_at?: BigIntFieldUpdateOperationsInput | bigint | number
    players?: PlayerUpdateOneRequiredWithoutAccount_ban_historyNestedInput
  }

  export type account_ban_historyUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expired_at?: BigIntFieldUpdateOperationsInput | bigint | number
    banned_by?: IntFieldUpdateOperationsInput | number
  }

  export type account_ban_historyUncheckedUpdateManyWithoutAccount_ban_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expired_at?: BigIntFieldUpdateOperationsInput | bigint | number
    banned_by?: IntFieldUpdateOperationsInput | number
  }

  export type account_storageUpdateWithoutAccountsInput = {
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type account_storageUncheckedUpdateWithoutAccountsInput = {
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type account_storageUncheckedUpdateManyWithoutAccount_storageInput = {
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type account_viplistUpdateWithoutAccountsInput = {
    description?: StringFieldUpdateOperationsInput | string
    icon?: IntFieldUpdateOperationsInput | number
    notify?: BoolFieldUpdateOperationsInput | boolean
    players?: PlayerUpdateOneRequiredWithoutAccount_viplistNestedInput
  }

  export type account_viplistUncheckedUpdateWithoutAccountsInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    icon?: IntFieldUpdateOperationsInput | number
    notify?: BoolFieldUpdateOperationsInput | boolean
  }

  export type account_viplistUncheckedUpdateManyWithoutAccount_viplistInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    icon?: IntFieldUpdateOperationsInput | number
    notify?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerUpdateWithoutAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUpdateManyWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
    account_ban_history?: account_ban_historyUncheckedUpdateManyWithoutPlayersNestedInput
    account_bans?: account_bansUncheckedUpdateManyWithoutPlayersNestedInput
    account_viplist?: account_viplistUncheckedUpdateManyWithoutPlayersNestedInput
    guild_invites?: guild_invitesUncheckedUpdateManyWithoutPlayersNestedInput
    guild_membership?: guild_membershipUncheckedUpdateOneWithoutPlayersNestedInput
    guilds?: guildsUncheckedUpdateOneWithoutPlayersNestedInput
    ip_bans?: ip_bansUncheckedUpdateManyWithoutPlayersNestedInput
    market_history?: market_historyUncheckedUpdateManyWithoutPlayersNestedInput
    market_offers?: market_offersUncheckedUpdateManyWithoutPlayersNestedInput
    player_depotitems?: player_depotitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_inboxitems?: player_inboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
    player_namelocks_player_namelocks_player_idToplayers?: player_namelocksUncheckedUpdateOneWithoutPlayers_player_namelocks_player_idToplayersNestedInput
    player_namelocks_player_namelocks_namelocked_byToplayers?: player_namelocksUncheckedUpdateManyWithoutPlayers_player_namelocks_namelocked_byToplayersNestedInput
    player_storage?: player_storageUncheckedUpdateManyWithoutPlayersNestedInput
    player_storeinboxitems?: player_storeinboxitemsUncheckedUpdateManyWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutPlayersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    group_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    vocation?: IntFieldUpdateOperationsInput | number
    health?: IntFieldUpdateOperationsInput | number
    healthmax?: IntFieldUpdateOperationsInput | number
    experience?: BigIntFieldUpdateOperationsInput | bigint | number
    lookbody?: IntFieldUpdateOperationsInput | number
    lookfeet?: IntFieldUpdateOperationsInput | number
    lookhead?: IntFieldUpdateOperationsInput | number
    looklegs?: IntFieldUpdateOperationsInput | number
    looktype?: IntFieldUpdateOperationsInput | number
    lookaddons?: IntFieldUpdateOperationsInput | number
    direction?: IntFieldUpdateOperationsInput | number
    maglevel?: IntFieldUpdateOperationsInput | number
    mana?: IntFieldUpdateOperationsInput | number
    manamax?: IntFieldUpdateOperationsInput | number
    manaspent?: BigIntFieldUpdateOperationsInput | bigint | number
    soul?: IntFieldUpdateOperationsInput | number
    town_id?: IntFieldUpdateOperationsInput | number
    posx?: IntFieldUpdateOperationsInput | number
    posy?: IntFieldUpdateOperationsInput | number
    posz?: IntFieldUpdateOperationsInput | number
    conditions?: BytesFieldUpdateOperationsInput | Buffer
    cap?: IntFieldUpdateOperationsInput | number
    sex?: IntFieldUpdateOperationsInput | number
    lastlogin?: BigIntFieldUpdateOperationsInput | bigint | number
    lastip?: IntFieldUpdateOperationsInput | number
    save?: BoolFieldUpdateOperationsInput | boolean
    skull?: BoolFieldUpdateOperationsInput | boolean
    skulltime?: BigIntFieldUpdateOperationsInput | bigint | number
    lastlogout?: BigIntFieldUpdateOperationsInput | bigint | number
    blessings?: IntFieldUpdateOperationsInput | number
    onlinetime?: BigIntFieldUpdateOperationsInput | bigint | number
    deletion?: BigIntFieldUpdateOperationsInput | bigint | number
    balance?: BigIntFieldUpdateOperationsInput | bigint | number
    offlinetraining_time?: IntFieldUpdateOperationsInput | number
    offlinetraining_skill?: IntFieldUpdateOperationsInput | number
    stamina?: IntFieldUpdateOperationsInput | number
    skill_fist?: IntFieldUpdateOperationsInput | number
    skill_fist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_club?: IntFieldUpdateOperationsInput | number
    skill_club_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_sword?: IntFieldUpdateOperationsInput | number
    skill_sword_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_axe?: IntFieldUpdateOperationsInput | number
    skill_axe_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_dist?: IntFieldUpdateOperationsInput | number
    skill_dist_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_shielding?: IntFieldUpdateOperationsInput | number
    skill_shielding_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    skill_fishing?: IntFieldUpdateOperationsInput | number
    skill_fishing_tries?: BigIntFieldUpdateOperationsInput | bigint | number
    stat_str?: IntFieldUpdateOperationsInput | number
    stat_int?: IntFieldUpdateOperationsInput | number
    stat_dex?: IntFieldUpdateOperationsInput | number
    stat_vit?: IntFieldUpdateOperationsInput | number
    stat_spr?: IntFieldUpdateOperationsInput | number
    stat_wis?: IntFieldUpdateOperationsInput | number
  }

  export type account_ban_historyCreateManyPlayersInput = {
    id?: number
    account_id: number
    reason: string
    banned_at: bigint | number
    expired_at: bigint | number
  }

  export type account_bansCreateManyPlayersInput = {
    account_id: number
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
  }

  export type account_viplistCreateManyPlayersInput = {
    account_id: number
    description?: string
    icon?: number
    notify?: boolean
  }

  export type guild_invitesCreateManyPlayersInput = {
    guild_id?: number
  }

  export type ip_bansCreateManyPlayersInput = {
    ip: number
    reason: string
    banned_at: bigint | number
    expires_at: bigint | number
  }

  export type market_historyCreateManyPlayersInput = {
    id?: number
    sale?: boolean
    itemtype: number
    amount: number
    price?: number
    expires_at: bigint | number
    inserted: bigint | number
    state: number
  }

  export type market_offersCreateManyPlayersInput = {
    id?: number
    sale?: boolean
    itemtype: number
    amount: number
    created: bigint | number
    anonymous?: boolean
    price?: number
  }

  export type player_depotitemsCreateManyPlayersInput = {
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_inboxitemsCreateManyPlayersInput = {
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_namelocksCreateManyPlayers_player_namelocks_namelocked_byToplayersInput = {
    player_id: number
    reason: string
    namelocked_at: bigint | number
  }

  export type player_storageCreateManyPlayersInput = {
    key?: number
    value?: number
  }

  export type player_storeinboxitemsCreateManyPlayersInput = {
    sid: number
    pid?: number
    itemtype: number
    count?: number
    attributes: Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type account_ban_historyUpdateWithoutPlayersInput = {
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expired_at?: BigIntFieldUpdateOperationsInput | bigint | number
    accounts?: AccountUpdateOneRequiredWithoutAccount_ban_historyNestedInput
  }

  export type account_ban_historyUncheckedUpdateWithoutPlayersInput = {
    id?: IntFieldUpdateOperationsInput | number
    account_id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expired_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type account_bansUpdateWithoutPlayersInput = {
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    accounts?: AccountUpdateOneRequiredWithoutAccount_bansNestedInput
  }

  export type account_bansUncheckedUpdateWithoutPlayersInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type account_bansUncheckedUpdateManyWithoutAccount_bansInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type account_viplistUpdateWithoutPlayersInput = {
    description?: StringFieldUpdateOperationsInput | string
    icon?: IntFieldUpdateOperationsInput | number
    notify?: BoolFieldUpdateOperationsInput | boolean
    accounts?: AccountUpdateOneRequiredWithoutAccount_viplistNestedInput
  }

  export type account_viplistUncheckedUpdateWithoutPlayersInput = {
    account_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    icon?: IntFieldUpdateOperationsInput | number
    notify?: BoolFieldUpdateOperationsInput | boolean
  }

  export type guild_invitesUpdateWithoutPlayersInput = {
    guilds?: guildsUpdateOneRequiredWithoutGuild_invitesNestedInput
  }

  export type guild_invitesUncheckedUpdateWithoutPlayersInput = {
    guild_id?: IntFieldUpdateOperationsInput | number
  }

  export type guild_invitesUncheckedUpdateManyWithoutGuild_invitesInput = {
    guild_id?: IntFieldUpdateOperationsInput | number
  }

  export type ip_bansUpdateWithoutPlayersInput = {
    ip?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ip_bansUncheckedUpdateWithoutPlayersInput = {
    ip?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ip_bansUncheckedUpdateManyWithoutIp_bansInput = {
    ip?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    banned_at?: BigIntFieldUpdateOperationsInput | bigint | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type market_historyUpdateWithoutPlayersInput = {
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    inserted?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: IntFieldUpdateOperationsInput | number
  }

  export type market_historyUncheckedUpdateWithoutPlayersInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    inserted?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: IntFieldUpdateOperationsInput | number
  }

  export type market_historyUncheckedUpdateManyWithoutMarket_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    expires_at?: BigIntFieldUpdateOperationsInput | bigint | number
    inserted?: BigIntFieldUpdateOperationsInput | bigint | number
    state?: IntFieldUpdateOperationsInput | number
  }

  export type market_offersUpdateWithoutPlayersInput = {
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    created?: BigIntFieldUpdateOperationsInput | bigint | number
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
  }

  export type market_offersUncheckedUpdateWithoutPlayersInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    created?: BigIntFieldUpdateOperationsInput | bigint | number
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
  }

  export type market_offersUncheckedUpdateManyWithoutMarket_offersInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale?: BoolFieldUpdateOperationsInput | boolean
    itemtype?: IntFieldUpdateOperationsInput | number
    amount?: IntFieldUpdateOperationsInput | number
    created?: BigIntFieldUpdateOperationsInput | bigint | number
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
  }

  export type player_depotitemsUpdateWithoutPlayersInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_depotitemsUncheckedUpdateWithoutPlayersInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_depotitemsUncheckedUpdateManyWithoutPlayer_depotitemsInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_inboxitemsUpdateWithoutPlayersInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_inboxitemsUncheckedUpdateWithoutPlayersInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_inboxitemsUncheckedUpdateManyWithoutPlayer_inboxitemsInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_namelocksUpdateWithoutPlayers_player_namelocks_namelocked_byToplayersInput = {
    reason?: StringFieldUpdateOperationsInput | string
    namelocked_at?: BigIntFieldUpdateOperationsInput | bigint | number
    players_player_namelocks_player_idToplayers?: PlayerUpdateOneRequiredWithoutPlayer_namelocks_player_namelocks_player_idToplayersNestedInput
  }

  export type player_namelocksUncheckedUpdateWithoutPlayers_player_namelocks_namelocked_byToplayersInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    namelocked_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type player_namelocksUncheckedUpdateManyWithoutPlayer_namelocks_player_namelocks_namelocked_byToplayersInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    namelocked_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type player_storageUpdateWithoutPlayersInput = {
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type player_storageUncheckedUpdateWithoutPlayersInput = {
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type player_storageUncheckedUpdateManyWithoutPlayer_storageInput = {
    key?: IntFieldUpdateOperationsInput | number
    value?: IntFieldUpdateOperationsInput | number
  }

  export type player_storeinboxitemsUpdateWithoutPlayersInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_storeinboxitemsUncheckedUpdateWithoutPlayersInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type player_storeinboxitemsUncheckedUpdateManyWithoutPlayer_storeinboxitemsInput = {
    sid?: IntFieldUpdateOperationsInput | number
    pid?: IntFieldUpdateOperationsInput | number
    itemtype?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    attributes?: BytesFieldUpdateOperationsInput | Buffer
    json_data?: NullableJsonNullValueInput | InputJsonValue
  }

  export type guild_membershipCreateManyGuild_ranksInput = {
    player_id: number
    guild_id: number
    nick?: string
  }

  export type guild_membershipUpdateWithoutGuild_ranksInput = {
    nick?: StringFieldUpdateOperationsInput | string
    players?: PlayerUpdateOneRequiredWithoutGuild_membershipNestedInput
    guilds?: guildsUpdateOneRequiredWithoutGuild_membershipNestedInput
  }

  export type guild_membershipUncheckedUpdateWithoutGuild_ranksInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    guild_id?: IntFieldUpdateOperationsInput | number
    nick?: StringFieldUpdateOperationsInput | string
  }

  export type guild_membershipUncheckedUpdateManyWithoutGuild_membershipInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    guild_id?: IntFieldUpdateOperationsInput | number
    nick?: StringFieldUpdateOperationsInput | string
  }

  export type guildwar_killsCreateManyGuild_warsInput = {
    id?: number
    killer: string
    target: string
    killerguild?: number
    targetguild?: number
    time: bigint | number
  }

  export type guildwar_killsUpdateWithoutGuild_warsInput = {
    killer?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    killerguild?: IntFieldUpdateOperationsInput | number
    targetguild?: IntFieldUpdateOperationsInput | number
    time?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type guildwar_killsUncheckedUpdateWithoutGuild_warsInput = {
    id?: IntFieldUpdateOperationsInput | number
    killer?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    killerguild?: IntFieldUpdateOperationsInput | number
    targetguild?: IntFieldUpdateOperationsInput | number
    time?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type guildwar_killsUncheckedUpdateManyWithoutGuildwar_killsInput = {
    id?: IntFieldUpdateOperationsInput | number
    killer?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    killerguild?: IntFieldUpdateOperationsInput | number
    targetguild?: IntFieldUpdateOperationsInput | number
    time?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type guild_invitesCreateManyGuildsInput = {
    player_id?: number
  }

  export type guild_membershipCreateManyGuildsInput = {
    player_id: number
    rank_id: number
    nick?: string
  }

  export type guild_ranksCreateManyGuildsInput = {
    id?: number
    name: string
    level: number
  }

  export type guild_invitesUpdateWithoutGuildsInput = {
    players?: PlayerUpdateOneRequiredWithoutGuild_invitesNestedInput
  }

  export type guild_invitesUncheckedUpdateWithoutGuildsInput = {
    player_id?: IntFieldUpdateOperationsInput | number
  }

  export type guild_membershipUpdateWithoutGuildsInput = {
    nick?: StringFieldUpdateOperationsInput | string
    players?: PlayerUpdateOneRequiredWithoutGuild_membershipNestedInput
    guild_ranks?: guild_ranksUpdateOneRequiredWithoutGuild_membershipNestedInput
  }

  export type guild_membershipUncheckedUpdateWithoutGuildsInput = {
    player_id?: IntFieldUpdateOperationsInput | number
    rank_id?: IntFieldUpdateOperationsInput | number
    nick?: StringFieldUpdateOperationsInput | string
  }

  export type guild_ranksUpdateWithoutGuildsInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    guild_membership?: guild_membershipUpdateManyWithoutGuild_ranksNestedInput
  }

  export type guild_ranksUncheckedUpdateWithoutGuildsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    guild_membership?: guild_membershipUncheckedUpdateManyWithoutGuild_ranksNestedInput
  }

  export type guild_ranksUncheckedUpdateManyWithoutGuild_ranksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}